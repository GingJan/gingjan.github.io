{"pages":[{"title":"About","text":"关于我 ^_^","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Linux-让耗时任务在后台运行","text":"让终端的任务/耗时任务在后台运行 ：我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？ 涉及命令ps -ef 查看进程pstree 查看进程树jobs 查看当前终端的任务列表commands &amp;，命令后加&amp;代表将该命令放置后台运行nohup commands &amp;setsid commands(commands &amp;) 效果同上面setsidctrl+z (暂停/挂起当前 作业，在使用编辑器时特别有用，退出编辑器时，保存了光标所在的当前位置，下次进入编辑器时不用再次寻找上次光标所处位置)bg %work_num如bg %1（把作业从挂起转为继续运行）disown -h %1work_num使某个作业忽略HUP信号disown -ah 所有作业忽略HUP信号disown -rh 使正在运行的作业忽略HUP信号screen -dmS session_name 建立一个断开模式的会话screen -list 列出所有会话screen -r session_name 重新连接指定会话 我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？ 一、逐个添加1.通过忽略hangup信号（此信号在终端关闭或者网络断开时就会发出），该种方式可通过jobs命令来查看作业列表nohup ping www.google.com &amp;查看进程ps -ef | grep www.google.com 2.通过把任务移为其他进程（非终端进程）的子进程来运行，这样就不会受到终端的HUP信号影响了，该种方式通过jobs命令是无法查看作业列表setsid ping www.google.com 3.把任务放置到子shell(subshell)下运行，这样就不会受到终端的HUP信号影响了，该种方式通过jobs命令是无法查看作业列表，因为任务已经不属于该终端的作业了(ping www.google.com &amp;) 二、补救如果我们执行了一个耗时任务，想在该耗时任务运行期间让它到后台运行，这时添加nohup或setsid已经迟了，怎么做？ disowndisown -h %1 三、一步完成当有很多耗时任务，而我们又不想一个一个去加nohup ,setsid时，怎么办？ screenscreen -dmS session_name 参考：https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/","link":"/2016/09/01/Linux-run-in-background/"},{"title":"访问修饰符的意义","text":"访问修饰符和访问控制的意义 ：本文主要讲解为何有些成员变量需要设置成私有的，为什么不能直接设置成public直接在外部访问，以及PHP魔术方法get()和set()的使用 先上一段代码好说明问题12345678910class User { private $_salary;//私用属性命名加_ //setter and getter public function getSalary() {//如果只有get，那么说明该 属性/成员变量 只是可读，不可写 return $this-&gt;_salary; } public function setSalary($salary) {//如果只有set，说明该 属性/成员变量 只是可写，不可读 $this-&gt;_salary = $salary; }} 如上，我们觉得好像private改成public也没什么大问题，但是如果有这样一个场景，调用代码中，多处调用了User的salary属性，有写的也有读的，但是有一天，你不想让调用者修改salary了（禁用写），那怎么办？要怎么保证调用者的代码中没有直接修改salary的代码？如果提供了setter，那么只要把setter删掉，一旦调用代码中有没清理干净的对salary进行写入/修改 的代码，那么就会抛出异常。而使用public $salary这种方式的话，改成private后，虽然是可以禁止写了但是连读取也被禁止了。 对写入数据的操作/过滤，使用setter和getter，可以统一对写入/读取 进行操作或者过滤，比如要去掉写入数据中的空格，如果使用public，那么要在每个调用处写上trim()，但是我们无法保证每处都写上trim了。如果用setter，那么我们可以在setter中写一次trim即可，而且也保证对每次写入都会进行过滤，不会有遗漏。 注意:由于 get() 和 set() 是在遍历所有成员变量，找不到匹配的成员变量时才被调用。因此，其效率是低于直接访问成员变量的形式。在一些表示数据结构、数据集合等简单情况下，且不需读写控制等， 可以考虑使用成员变量作为属性直接访问，这样可以提高一点效率。另外一个提高效率的技巧就是：使用 $k1 = $obj-&gt;getK1() 来代替 $k1 = $obj-&gt;K1 ， 用 $obj-&gt;setK1($value) 来代替 $obj-&gt;K1 = $value 。 这在功能上是完全一样的效果，但是避免了使用 get() 和 set() ，相当于绕过了遍历的过程。 这里还要区分，在类里成员变量和属性的区别。成员变量和属性的区别与联系在于： 成员变量是一个“内”概念，反映的是就类的结构构成而言的该你那。属性是一个“外”概念，反映的是类的功能逻辑意义而言的概念。 成员变量没有读写权限控制，而属性可以指定为只读或只写，或可读可写。 成员变量不对读出作任何后处理，不对写入作任何预处理，而属性则可以。 public成员变量可以视为一个可读可写、没有任何预处理或后处理的属性。 而private成员变量由于外部不可见，与属性“外”的特性不相符，所以不能视为属性。 虽然大多数情况下，属性会由某个或某些成员变量来表示，但属性与成员变量没有必然的对应关系， 比如与非门的 output 属性，就没有一个所谓的 $output 成员变量与之对应。 为了更形象，我们看个例子1234567891011121314151617class NotAndGate { private $_k1; private $_k2; public function setK1($value) { $this-&gt;$_k1 = $value; } public function setK2($value) { $this-&gt;$_k2 = $value; } public function getOutput() {//与非门有两个输入，当两个输入都为真时，与非门的输出为假，否则，输出为真。 if ( !$this-&gt;_k1 || !$this-&gt;_k2 ) return true; elseif ($this-&gt;_k1 &amp;&amp; $this-&gt;_k2) return false; }} 上面的代码中，与非门类有两个成员变量， $_k1 和 $_k2 。但是有3个属性，表示2个输入的 key1 和 key2 ，以及表示输出的 output。由于我们知道，属性一般是通过$obj-&gt;property方式来访问的，但是这里根本没有output这个成员变量呀？那还怎么访问呢？没错，这时候就要靠我们的魔术方法__get()来配合getter了，上__get()的代码： 12345678910public function __get($name) { $getter = 'get' . $name;//如此，当调用$obj-&gt;output属性时，就会去调用getOutput()，以达到具有output属性的效果 if (method_exists($this, $getter)) { return $this-&gt;$getter(); } elseif (method_exists($this, 'set'.$name)) { echo '只存在setter，也即该属性为只写'; } else { echo '无' , $name , '属性'; }} 欢迎转载但请附上链接，谢谢。 参考：http://www.digpage.com/property.html 如有什么错误，欢迎提出、讨论，大家共同进步 ^_^","link":"/2016/06/06/accessing-control-and-locator-qualifer-purpose/"},{"title":"在Yii中如何处理级联删除","text":"Yii的级联删除 ：本文讲解通过Yii在代码层进行级联删除 数据库表里使用了外键并且使用了Restrict模式，导致删除一张表的记录时，因为外键和其他表关联起来了，导致无法删除，需要把关联表的记录同时也删除了才可以操作目标表记录的删除操作。 第一步：重写beforeDelete()在Model里，重写beforeDelete()，然后在该方法的最后一行return parent::beforeDelete();即可当然与beforeDelete方法对应的afterDelete方法也能做其他事情。充分发挥before和after的作用吧123456789class D { public function beforeDelete() { $id = $this-&gt;id;; A::deleteAll(['id'=&gt;$id]);//级联删除 B::deleteAll(['id'=&gt;$id]); C::deleteAll(['id'=&gt;$id]); return parent::beforeDelete(); }}","link":"/2016/06/13/cascade-delete-in-yii/"},{"title":"顺时针螺旋原则","text":"顺时针螺旋原则 ：本文主要讲解何为顺时针螺旋原则并给出些许示例 基于顺时针螺旋原则，C可以解析复杂的类型声明按照以下三个步骤: 从变量名开始,沿着顺时针方向(变量名处向上走),从第一个类型声明符号开始,当遇到下一个类型声明符号则使用对应的自然语言描述它:[X] or []=&gt; [^Array X size of… or Array undefined size of…][^Array X size of… or Array undefined size of…]:(数组 大小为 X 的… or 数组 大小为 未知 的…)(type1, type2)=&gt; function passing type1 and type2 returning... (函数 传入 type1 和 type2 返回...)*=&gt; pointer(s) to... (指针 指向...) 继续沿着顺时针方向使用自然语言描述对应声明符号直到所有符号描述成为止 圆括号()内的符号要先描述 示例1:简单声明1234567 +-------+ | +-+ | | ^ | |char *str[10]; ^ ^ | | | +---+ | +-----------+ 首先问,变量str是什么str is an... (变量str 是一个 ...) 从变量名str开始沿着顺时针方向(向上)走,遇到第一个字符是[,即有数组,所以:str is an array 10 of... (变量str 是一个数组大小为10的..). 继续沿着顺时针方向,下一个遇到的字符是*,即有指针,所以:str is an array 10 of pointers to... (变量str 是一个数组大小为10的指针...) 继续沿着顺时针方向,下一个遇到的字符是本行结束符;,so跳过,下一个是char:str is an array 10 of pointers to char (变量str 是一个数组大小为10的指针指向char类型) 现在每个字符都遍历了,因此完结 示例2:指向函数的指针的声明123456789 +--------------------+ | +---+ | | |+-+| | | |^ || |char *(*fp)( int, float *); ^ ^ ^ || | | | +--+| | | +-----+ | +------------------------+ 首先问,变量fp是什么?fp is a... (fp是...) 从fp开始,沿着顺时针方向(向上)遇到的第一个是);因此fp是在圆括号()内的,所以在圆括号内以顺时针螺旋方式继续,下一个是*:fp is a pointer to... (fp是一个指针指向...) 继续,出了圆括号范围后看到的是(,也即有函数:fp is a pointer to a function passing an int and a pointer to float returning... (fp是一个指针指向函数,该函数传入int类型和指向float的指针类型) 继续,下个是*:fp is a pointer to a function passing an int and a pointer to float returning a pointer to... (fp是一个指针指向函数,该函数传入int类型和指向float的指针类型并返回一个指针) 继续,下个是;,虽然到了行结束符,但还没有遍历完全部声明符号,因此继续并最后遇到char:fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char ((fp是一个指针指向函数,该函数传入int类型和指向float的指针类型并返回一个指针,该指针指向char类型) 示例3:「究极版」123456789 +-----------------------------+ | +---+ | | +---+ |+-+| | | ^ | |^ || |void (*signal(int, void (*fp)(int)))(int); ^ ^ | ^ ^ || | | +------+ | +--+| | | +--------+ | +----------------------------------+ 首先问,signal是?注意signal是在圆括号内的,所以先描述 从signal按照顺时针方式先向上走,遇到(:signal is a function passing an int and a... 以同样方式从fp开始,遇到的第一个字符是)即fp在圆括号内,所以继续,下一个是*:fp is a pointer to... (fp是一个指针指向) 继续顺时针螺旋方向遇到的下一个字符是):fp is a pointer to a function passing int returning... fp是一个指针,指向一个函数,该函数传入int返回... 继续遇到的是void关键字:fp is a pointer to a function passing [int] returning [void] fp是一个指针,指向一个函数,该函数传入int返回void 到此完成了围绕变量fp声明的字符的描述,现在回到变量signal:signal is a function passing {an int and a pointer to a function passing [an int] returning [void]} returning {...} 接着下一个字符是*signal is a function passing {an int and a pointer to a function passing [an int] returning [void]} returning {a pointer to...} 现在圆括号内的字符都描述完毕,继续下一个字符是(signal is a function passing {an int and a pointer to a function passing [an int] returning [void]} returning {a pointer to a function passing [an int] returning [...]} 继续,最后一个字符是void,所以最后signal的描述/定义是:signal is a function passing {an int and a pointer to a function passing [an int] returning [void]} returning {a pointer to a function passing [an int] returning [void]} 同样,该原则可以应用到const常量和volatile: 示例4:1const char *chptr; chptr是什么? chptr is a pointer to a char constant. chptr是一个指针,指向char常量 示例5:1char * const chptr; chptr是什么? chptr is a constant pointer to char. chptr是一个常量指针,指向char 示例6:1volatile char * const chptr; chptr是什么? chptr is a constant pointer to a char volatile. chptr是一个常量指针,指向char volatile 欢迎转载但请附上原文链接，谢谢。 参考: The Clockwise/Spiral Rule 顺时针螺旋原则 搭配食用: Go’s Declaration Syntax 如有错误，欢迎指出、讨论，大家共同进步 ^_^","link":"/2020/04/30/clockwise-rule/"},{"title":"Composer常用基本命令","text":"Composer常用命令 ：本文讲解并且亲测了常用的Composer命令 命令 选项 参数 说明 composer required “xxx/xxx:v0.0.1” 更新包，自动判断包存不存在，不存在就安装，存在就更新 composer dump-autoload 不更新依赖,只更新autoload文件 composer install 根据composer.lock 更新/安装依赖 composer update 根据composer.json 更新/安装依赖 并更新composer.lock文件","link":"/2018/08/09/composer-command/"},{"title":"使用Composer的脚本&#x2F;scripts属性","text":"Composer.json ：该本文介绍该文件下的相关语法和关键字 我们在项目的根目录创建并定义composer.json文件，该文件里的JSON对象内定义一个&quot;scripts&quot;属性，该属性包含一系列事件对应要执行的回调脚本，一个事件可以用数组定义多个事件脚本。对于同一个事件，多个事件脚本会按照定义的顺序触发。 被执行的php回调脚本一定要定义成静态方法 定义脚本在项目根目录下的composer.json文件内定义脚本12345678910\"scripts\": { \"post-update-cmd\": [ //事件 \"php artisan clear-compiled\", //对应的事件脚本 \"php artisan ide-helper:generate\", \"php artisan optimize\" ], \"post-package-install\": [ \"MyVendor\\\\MyClass:postPackageInstall\" ]} 使用前面定义的例子，这里的MyVendor\\MyClass类，就可以被使用来执行 PHP 的回调：1234567891011121314151617181920212223242526&lt;?phpnamespace MyVendor;use Composer\\Script\\Event;class MyClass{ public static function postUpdate(Event $event) { //getComposer(): 返回当前的 Composer\\Composer 对象实例。 $composer = $event-&gt;getComposer(); // do something } public static function postPackageInstall(Event $event) { $installedPackage = $event-&gt;getOperation()-&gt;getPackage(); // do something } public static function warmCache(Event $event) { // make cache toasty }} 当一个事件被触发，Composer 的内部事件处理程序将接收一个Composer\\Script\\Event对象，这是传递给您的PHP回调函数的第一个参数。这个Event对象拥有一些如getter方法来帮助你取得当前事件的上下文(context)： getComposer(): 返回当前的Composer\\Composer对象实例。 getName(): 返回事件名称的字符串。 getIO(): 返回当前的输入\\输出流，它实现了Composer\\IO\\IOInterface接口，以便在控制台中使用。 上面是当事件发生时，composer自动调用对应的事件函数。当然我们也可以手动运行这些事件脚本 手动运行脚本使用下面的语法结构：composer run-script [--dev] [--no-dev] script如：composer run-script post-install-cmd将会按顺序运行所有post-install-cmd事件下定义的脚本。 事件列表在composer运行过程中将会触发下面的事件：(pre为执行前，post为执行后) 事件名称 说明 pre-install-cmd 在install命令执行前触发 post-install-cmd 在install命令执行后触发 pre-update-cmd 在update命令执行前触发 post-update-cmd 在update命令执行后触发 pre-status-cmd 在status命令执行前触发 post-status-cmd 在status命令执行后触发 pre-archive-cmd 在archive命令执行前触发 post-archive-cmd 在archive命令执行后触发 pre-package-install 在 资源包/第三方包/库 安装前触发 post-package-install 在 资源包/第三方包/库 安装后触发 pre-package-update 在 资源包/第三方包/库 更新前触发 post-package-update 在 资源包/第三方包/库 更新后触发 pre-package-uninstall 在 资源包/第三方包/库 卸载前触发 post-package-uninstall 在 资源包/第三方包/库 卸载后触发 pre-autoload-dump 在自动加载器被转储前触发，无论是install/update还是dump-autoload命令都会触发 post-autoload-dump 在自动加载器被转储后触发，无论是install/update还是dump-autoload命令都会触发 post-root-package-install 在create-project命令期间，根包安装完成后触发 post-create-project-cmd 在create-project命令执行后触发 注意：composer自会执行处于项目根目录下的composer.json文件里定义的脚本。不会去执行处于依赖包中的composer.json文件里的install或update定义的脚本。如果需要执行install或update命令的脚本，要确保他们都是在项目根目录下的composer.json中定义","link":"/2016/05/16/composer-scripts/"},{"title":"CSS响应式网页布局","text":"CSS响应式网页布局：目前，响应式网页布局有5种模式：mostly fluid , column drop , layout shifter , tiny tweaks , off canvas 目前，响应式网页布局有5种模式： 1.mostly fluid2.column drop3.layout shifter4.tiny tweaks5.off canvas 我们使用flexbox（弹性盒子）来讲解，我们使用一个主div，在这个主div下包含有多个div，用这几个div来讲解一下这5种模式。【关于flexbox弹性盒子请查看《CSS3 flexbox弹性盒模型》】 一、Mostly Fluid1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\" role=\"main\"&gt; &lt;div class=\"c1\"&gt;&lt;/div&gt; &lt;div class=\"c2\"&gt;&lt;/div&gt; &lt;div class=\"c3\"&gt;&lt;/div&gt; &lt;div class=\"c4\"&gt;&lt;/div&gt; &lt;div class=\"c5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最终效果共4种情况：首先在作为主div（main div）上设置样式，这个主div我们称它为容器container12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*将父元素设置为弹性盒子*/.container { /* -webkit- 代表浏览器提供商的前缀。前缀，添加上是为了浏览器兼容*/ /*关于浏览器前缀的问题，我会另外开文章讲解*/ display: -webkit-flex; display: flex; -webkit-flex-flow: row wrap; flex-flow: row wrap;}/*因为有下面媒体查询设置的影响，这里的样式起作用是当 0&lt;=浏览器宽度&lt;=600px时*/.c1, .c2, .c3, .c4, .c5 { /*使这几个子div占满整个父div元素的宽度。width:%代表占满父元素宽度的百分比*/ width: 100%;}/*注意，要分清 浏览器宽度 与 设备/屏幕宽度 的区别*//*媒体查询，当 浏览器 宽度&gt;=600px时，注意，因为下面还有&gt;=800的情况，因此，此样式是在600&lt;=浏览器宽度&lt;=800情况下起作用*/@media (min-width: 600px) { .c2, .c3, .c4, .c5 { width: 50%; }}/*媒体查询，浏览器宽度&gt;=800px*/@media (min-width: 800px) { .container { /*不再占满整个父元素的宽度，而是固定宽800px*/ width: 800px; /*auto代表根据剩下的空间自动平均分配给margin的左边和右边*/ margin-left: auto; margin-right: auto; } .c1 { width: 60%; } .c2 { width: 40%; } .c3, .c4, .c5 { width: 33.33%; } 玫红} 查看效果 浏览器宽度&lt;600px： 600px&lt;=浏览器宽度&lt;800px： 800px&lt;=浏览器宽度： 800px&lt;=浏览器宽度： 参考和练习，可以模式下面的网站自己做一次 A List Apart Media Queries SimpleBits 二、Column Drop此模式是对于需要实现 全宽度多列显示 的布局。当浏览器窗口太窄时，各列将会垂直排列(如下面第一张图)为此布局模式设置宽度范围断点时，要根据内容并且要将针对其他设计而改变。最终效果共4种情况：查看效果 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\" role=\"main\"&gt; &lt;div class=\"c1\"&gt;&lt;/div&gt; &lt;div class=\"c2\"&gt;&lt;/div&gt; &lt;div class=\"c3\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*同样需要设置container为弹性盒子*/.container { display: -webkit-flex; display: flex; -webkit-flex-flow: row wrap; flex-flow: row wrap;}.c1, .c2, .c3 { width: 100%;}/*600px&lt;=浏览器宽度&lt;800px*/@media (min-width: 600px) { .c1 { width: 60%; /*对order的说明:如果都不写出order的情况下，显示顺序跟文档流顺序一致，如果有其中一个写了，那么未写出的那些元素的显示顺序跟文档流顺序依然一致，但是写出了order并且没有赋值的元素，它的显示顺序将会处理最后，除非写出它的值如1*/ /*order:改变元素在文档流中的显示顺序，建议大家可以自定实验一下order的作用和影响效果*/ -webkit-order: 2; order: 2; } .c2 { width: 40%; -webkit-order: 1; order: 1; } .c3 { width: 100%; -webkit-order: 3; order: 3; }}/*800px&lt;=浏览器宽度*/@media (min-width: 800px) { .c2 { width: 20%; } .c3 { width: 20%; } /*没写出的如.c1 和 .container 将保持不变(也即保持上面的600~800时的值)*/} 浏览器宽度&lt;600px： 600px&lt;=浏览器宽度&lt;800px：注意浅蓝色c3那块 800px&lt;=浏览器宽度： 参考和练习，可以模式下面的网站自己做一次 Modernizr Wee Nudge 三、Layout Shifter该模式比较复杂，因为会涉及元素里的内容的更改，而不只是总体内容布局的更改。查看效果123456789101112131415&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\" role=\"main\"&gt; &lt;div class=\"c1\"&gt;&lt;/div&gt; &lt;!--注意，此时.c4为.container的子元素，同时又为.c2,.c3的父元素--&gt; &lt;div class=\"c4\"&gt; &lt;div class=\"c2\"&gt;&lt;/div&gt; &lt;div class=\"c3\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132.container { display: -webkit-flex; display: flex; -webkit-flex-flow: row wrap; flex-flow: row wrap;}.c1, .c2, .c3, .c4 { /*.c1 和 .c4的父元素都是.container ，而 .c2 和 .c3的父元素是.c4,祖父元素是 .container*/ /*均占各自父元素宽度的100%*/ width: 100%;}@media (min-width: 600px) { .c1 { width: 25%; } .c4 { width: 75%; }}@media (min-width: 800px) { .container { width: 800px; margin-left: auto; margin-right: auto; }} 浏览器宽度&lt;=600px时 600px&lt;=浏览器宽度&lt;800px 800px&lt;=浏览器宽度 参考和练习，可以模式下面的网站自己做一次 Food Sense Seminal 响应式设计示例 Andersson-Wise Architects 四、Tiny TweaksTiny tweaks 模式只对布局进行很小的更改，例如调整字号，调整图片大小或对内容进行极微的移动。在屏幕大小改变时，本模式的变化很小。当屏幕宽度增加时，字号和行距也变大。查看效果 1234567891011121314&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\" role=\"main\"&gt; &lt;div class=\"c1\"&gt; &lt;p&gt;paragraph1&lt;/p&gt; &lt;p&gt;paragraph2&lt;/p&gt; &lt;p&gt;paragraph3&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021.c1 { padding: 10px; width: 100%;}@media (min-width: 500px) { .c1 { padding: 20px; /*em，相对大小倍数，这里的相对的对象是父元素的font-size。注意默认情况下字体大小是16px（由浏览器默认值设定）*/ /*这里是1.5倍字体大小，使用em，可以弹性改变字体或者行距的大小*/ font-size: 1.5em; }}@media (min-width: 800px) { .c1 { padding: 40px; font-size: 2em; }} 参考和练习，可以模式下面的网站自己做一次 Opera 的闪亮演示 Ginger Whale Future Friendly 五、Off Canvas该模式需要知道并且掌握transform属性、position定位属性怎么使用off canvas 模式不是垂直排列内容，而是将不 常用的内容（可能是导航或应用的菜单）放在屏幕之外，只在屏幕足够大时才显示。在较小屏幕上，只需点击 就能显示内容。此示例不是垂直排列内容，而是使用transform: translate(-250px, 0) 将两个内容 div隐藏在屏幕之外。 然后通过给元素添加 .open 类来使其可见，使用 JavaScript 来显示这些 div。 当屏幕变宽时，从元素中去掉屏幕外的绝对定位，并且让它显示在可见视口内。注意，在本例中，Safari for iOS 6 和安卓浏览器不支持 flexbox 的flex-flow: row nowrap 功能，因此我们必须使用绝对定位来实现。 查看效果 123456789&lt;body&gt; &lt;div class=\"container\" role=\"main\"&gt; &lt;div class=\"c1 open\" id=\"leftDrawer\"&gt;&lt;/div&gt; &lt;div class=\"c2\" id=\"mainPanel\"&gt; hello &lt;/div&gt; &lt;div class=\"c3\" id=\"rightDrawer\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182body { overflow-x: hidden;}.container { display: block;}.c1, .c3 { /*定位：绝对定位*/ position: absolute; width: 250px; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; z-index: 1;}.c1 { -webkit-transform: translate(-250px,0); transform: translate(-250px,0);}.c2 { width: 100%; position: absolute;}.c3 { left: 100%;}.c1.open { -webkit-transform: translate(0,0); transform: translate(0,0);}.c3.open { -webkit-transform: translate(-250px,0); transform: translate(-250px,0);}@media (min-width: 500px) { /* 如果浏览器宽度&gt;=500px，就使用弹性盒子模型 */ .container { display: -webkit-flex; display: flex; -webkit-flex-flow: row nowrap; flex-flow: row nowrap; } .c1 { position: relative; -webkit-transition: none 0s ease-out; transition: none 0s ease-out; -webkit-transform: translate(0,0); transform: translate(0,0); } .c2 { position: static; }}@media (min-width: 800px) { body { overflow-x: auto; } .c3 { position: relative; left: auto; -webkit-transition: none 0s ease-out; transition: none 0s ease-out; -webkit-transform: translate(0,0); transform: translate(0,0); }} 参考和练习，可以模式下面的网站自己做一次 HTML5Rocks 文章 Google Nexus Facebook 移动网站 本文参考：https://developers.google.com/web/fundamentals/design-and-ui/responsive/patterns/?hl=zh-cn","link":"/2016/05/05/css-responsive-layout/"},{"title":"em&#x2F;百分比&#x2F;px&#x2F;pt 的区别","text":"css中的4种单位的对比 ：当然不只这4种单位，我们这里只是讨论最常用的这4种单位 各单位的说明em一个em等于其父元素的字体大小，如body为16px时，1em=16px。body下的元素的大小为2em时，等于2*16=32px。它是一个对移动设备很有用的单位。 percent %跟em差不多，也是个相对值单位。但是还是有点区别，稍后我们再讲解 px屏幕上的像素点，一个像素点=1px，一样用于需要在荧幕媒体上显示大小时使用它 pt磅，1磅=1/72英寸。与px类似，也是一种固定的单位，不过一般使用于需要打印出来的内容上面。 它们的关系:默认下（浏览器的字体大小默认为16px）,16px=12pt=1em=100% 各单位的比较4种单位比较下面放张图片直观点比较可见，em和percent会因为用户使用了网页放大/缩小 而该变内容的大小这里px和pt都差不多，都是一种固定不变的单位 em与百分比的比较下面来看看em和percent有什么不同在浏览器的默认大小值16px也即“medium”情况下，它们是没什么区别的，但是当设置为“Smallest”和“Largest”，情况就不一样了可见，使用em，内容大小的变化太唐突，要不就太大直到显示不到，要不就太小连看都看不到。 所以，推荐使用percent（当然，使用em也许更方便，不过这两者都差不多，这里的推荐结果只是就本文讨论而言的最佳结果） 虽然现在大部分网站内容的大小如字体大小，都使用px作为其单位，但是会导致一些问题比如在一些高分辨率的屏幕下，12px在屏幕上显示出来是非常小到，几乎很难看清（就如原先1英寸显示100px，现在可以显示300px，那么相对来说，显示出来的字体大小就小了很多），因为，现在使用percent作为字体的大小单位还是很推荐的 结论如果想页面元素的大小更加灵活的变化，那么推荐使用%百分比，当然实际上使用em可能比使用百分比的多。","link":"/2016/05/19/em-percent-and-px-pt/"},{"title":"Git常用基本命令","text":"Git常用命令 ：本文讲解并且亲测了常用的Git命令 Git命令 选项 参数 说明 git init 初始化/新建 当前目录为本地git仓库 git add -A或-add 添加当前目录下所有未被tracking以及被修改的文件到index中 git add file 添加 file文件/指定文件 到index中 git add . 递归添加当前目录下的所有文件(包含目录)到index中 git rm –cached file 只删除index中指定的文件，而处于工作目录（也即文件目录）中的文件不会受到影响（不会被删除） git rm -f或–force file 同时删除index和工作目录中指定的文件 git rm -r * 删除index暂存区里的全部文件 git status 查看整个项目已经初始化的目录下所有文件的状态(处于 .gitignore 文件里的文件会被) git status . 查看当前目录下所有文件和目录的状态(非递归,也即当前目录内的子目录内的文件无法查看) git commit -m ‘message’ 提交当前index中的文件到仓库repo中，并且附上提交说明/信息 git commit -am ‘message’ git add 和 git commit 的组合 git commit –amend -m ‘this is amend command’ 当index没有新文件/修改的文件的前提下，该参数可以用来修改上一次commit的说明。当index中有新的文件或者修改的文件，该参数就会把这次index里的文件追加到上一次的commit中，而不会产生一次新的commit git log 显示所有的commit记录 git log -1 显示1行日志 -n为n行 git log –stat 显示每个文件的变动信息 git log -p -m git log v1.0 显示v1.0的日志 git log branch-1 ^branch-2 查看 branch-1 有，而 branch-2 中没有的 commit git log branch-2 ^branch-1 同理 查看 branch-2 有，而 branch-1 中没有的 commit git log branch-1..branch-2 查看 branch-2 中比 branch-1 中多提交了哪些commit，注意，列出来的是两个点后边（此处即branch-2）比前边（此处即branch-1）多提交的内容。 git log branch-2..branch-1 同理 查看 branch-1 中比 branch-2 中多提交了哪些commit git log branch-1…branch-2 不知道谁提交的多谁提交的少，单纯想知道有什么不一样，注意三个点 git log –left-right branch-1…branch-2 在上述情况下，再显示出每个提交是在哪个分支上，注意 commit 后面的箭头，根据我们在 –left-right branch-1…branch-2 的顺序，左箭头 &lt; 表示是 branch-1 的，右箭头 &gt; 表示是 branch-2的。 git show fjf01 显示某个commit的详细内容 git show HEAD 显示HEAD指向的commit的提交日志 git show HEAD^ 显示HEAD的父(上一个版本)的commit的提交日志 git show HEAD^^ 显示HEAD的上两个版本的commit的提交日志 git show HEAD^5 显示HEAD的上5个版本的commit的提交日志 git show v1.0 显示v1.0标签的版本信息 git tag 显示已存在的tag git tag -l 显示已存在的tag git tag -a v3.0 -m ‘new version’ 给当前HEAD指向的commit打上标签(tag)，每次打tag都需要加上说明-m git tag -a v3.1 eci3t8 -m ‘new version’ 给以前的某个历史提交打上标签(tag)，并附加上说明-m git push –tags 把本地全部标签推送到远程仓库，不加–tags参数默认是不会把标签推送到远程的 git push remote_host v1.0.1 推送本地指定标签到远程 git push remote_host –delete tag v1.0.1 删除远程指定标签 git clone xxx.git 克隆远程仓库到本地 git clone xxx.git local_dir 克隆远程仓库到本地指定目录下 git clone -b new_branch_name https://xxxxx.git clone时创建新的分支替代默认Origin HEAD（master） 配置 Git命令 选项 参数 说明 git config –system user.name “your name” 该系统下，所有用户使用的配置 git config –global user.name “your name” 该用户下的配置 git config –local user.name “your name” 该 项目project/仓库repository 下的配置 git config –system user.email myemail@gmail.com git config –global user.email myemail@gmail.com git config –local user.email myemail@gmail.com git config –list 查看配置，注意，所处的目录不同，显示的配置信息也不同哦 分支命令 Git命令 选项 参数 说明 git checkout dev 切换到dev分支上，也是把dev分支的代码检出到工作区（working tree） git checkout sha1-value 把指定历史版本的代码完整检出到工作区 git checkout sha1-value /path/to/file 将指定文件的某个历史版本检出到工作区 git checkout sha1-value:/path/to/file new-name 将指定文件的某个历史版本检出到工作区并且修改该文件名 git checkout -t origin/dev 创建本地dev分支(与远程对应分支同名)并换到该分支上，并且设置新分支dev的upstream信息 git checkout -b dev origin/dev 等同于上面命令。从当前分支创建并检出（切换到）新分支的命令。实际上是git checkout -b new-branch-name current-branch 的简写形式，即默认从当前HEAD分支创建新新分支 git checkout -b new-branch-name 172je2 从历史版本为 172je2 上创建新分支并且切换到该分之上 git checkout – 取消对文件的修改,还原到最近的版本,废弃本地做的修改 git branch new-branch-name 172je2 从历史版本为 172je2 上创建新分支，但不会切换到该分之上 git branch -a 查看所有分支 git branch -d branch_name 删除branch_name分支 git merge branch_name 把branch_name分支合并到本分支中（fast-forward模式） git merge –no-ff branch_name 把branch_name分支合并到本分支中，非fast-forward模式，即会创建一个合并的提交 分支对比 Git命令 选项 参数 说明 git diff branch1 branch2 –stat 显示出所有有差异的文件列表 git diff branch1 branch2 文件名(带路径) 显示指定文件的详细差异 git diff branch1 branch2 显示出所有有差异的文件的详细差异 git log branch-1 ^branch-2 查看 branch-1 有，而 branch-2 中没有的 commit git log branch-2 ^branch-1 同理 查看 branch-2 有，而 branch-1 中没有的 commit git log branch-1..branch-2 查看 branch-2 中比 branch-1 中多提交了哪些commit，注意，列出来的是两个点后边（此处即branch-2）比前边（此处即branch-1）多提交的内容。 git log branch-2..branch-1 同理 查看 branch-1 中比 branch-2 中多提交了哪些commit git log branch-1…branch-2 不知道谁提交的多谁提交的少，单纯想知道有什么不一样，注意三个点 git log –left-right branch-1…branch-2 在上述情况下，再显示出每个提交是在哪个分支上，注意 commit 后面的箭头，根据我们在 –left-right branch-1…branch-2 的顺序，左箭头 &lt; 表示是 branch-1 的，右箭头 &gt; 表示是 branch-2的。 修改commit Git命令 选项 参数 说明 git rebase -i 到哪个旧commit的hash值 注意，该commit是不会被合并的。接着进入交互模式，排第一行的是最旧的commit，除了这一个外，把每个commit前的pick改成squash，就相当于合并到第一行的commit上，接着修改commit信息。 按功能排序取消修改,恢复版本取消对文件的修改。还原到最近的版本，废弃本地做的修改。git checkout -- &lt;file&gt; 取消已经暂存的文件。即，撤销先前”git add”的操作git reset HEAD &lt;file&gt;... 修改最后一次提交。用于修改上一次的提交信息，或漏提交文件等情况。git commit --amend 回退所有内容到上一个版本git reset HEAD^ 回退a.py这个文件的版本到上一个版本git reset HEAD^ a.py 向前回退到第3个版本git reset –soft HEAD~3 将本地的状态回退到和远程的一样git reset –hard origin/master 回退到某个版本git reset 057d 回退到上一次提交的状态，按照某一次的commit完全反向的进行一次commit.(代码回滚到上个版本，并提交git)git revert HEAD 回滚单个文件git reset sha-1 path/to/filegit commit path/to/file -m 'message'git checkout path/to/file 几点说明： 一次commit是指当你输入git log是，看到的一串码，如commit e7d1b777de790970af704dbeac8c0ef3d21335b4，这算一次commit [https://www.pureweber.com/article/git-pretty-output/]","link":"/2016/05/24/git-command/"},{"title":"push.default的matching和simple","text":"push.default的设置 ：本文介绍push.default的两种设置，因为有两种不同设置是因为Git版本升级，导致默认设置不一样。 因为git的版本升级，导致了push.default的值改变了，因此会询问你，使用matching还是simple，下面讲讲这两者的区别 Matching该参数是 Git 1.*的默认值，意思是如果在执行git push时没有指定分支，那么它将把所有本地的分支push到远程仓库中对应的分支 Simple该参数是 Git 2.*的默认值，意思是如果在执行git push时没有指定分支，那么它只会把当前分支push到你用git pull时指定的那个分支。 修改默认设置通过修改全局配置来隐藏git push时的提示，如果要设置matching模式则：1git config --global push.default matching 设置simple模式：1git config --global push.default simple","link":"/2016/05/22/git-push-default/"},{"title":"如何选择AES加密模式(CBC ECB CTR OCB CFB)","text":"AES加密模式的选择 ： 如果加密的数据块超过 1 block则不要选择ECB模式 CBC, OFB 和 CFB 模式很相似,然而如果你只是要加密而不需要解密,则选择OFB或CFB更合适,因为这两种模式可以节约空间 如果需要更快的加密速度(并行加密),选择CTR 而不是 CBC/OFB/CFB. 如果需要 对随机访问介质内的数据(如磁盘或内存中的数据)进行加密,选择XTS模式更合适 OCB是目前为止最好的模式,因为它可以一次性对数据进行加密和验证,然后在美国该模式是需要专利授权的 ECB 很少使用到除非只是加密1个数据块.如果是加密磁盘或内存的数据而不是stream(stream是一段一段的),XTS应该更适合你 每次加密时都要使用唯一且随机的IV(init vector,初始化向量),如果你无法保证随机性,则使用OCB模式,因为它只需要传入nonce而无需传入IV,IV和nonce这两个有点不同,如果被人猜到下一个nonce是不会导致安全问题,而被人猜到下一个IV则会导致安全问题(因为需要保证IV每次是随机的)","link":"/2018/08/12/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb/"},{"title":"如何在mac上解压分离的压缩文件","text":"解压分离压缩文件：本篇文章向各位展示如何解压分离的压缩文件 首先，目前据我所知，有两种不同类型的分离压缩文件 一、xxx.zip.001、xxx.zip.002、xxx.zip003类型解决方案：在终端中输入： for i inseq 1 5; do cat xxx.zip.00$i &gt;&gt; single.zip; done #实则为一个循环语句 unzip single.zip 解压成功。 其实上面那句循环相当于： cat xxx.zip.001 &gt; single.zip #把数据重定向到single.zip cat xxx.zip.002 &gt;&gt; single.zip #把数据以追加方式重定向到single.zip cat xxx.zip.003 &gt;&gt; single.zip cat xxx.zip.004 &gt;&gt; single.zip cat xxx.zip.005 &gt;&gt; single.zip 或者可以：cat xxx.zip.00* &gt;&gt; already_exist_single.zip 二、xxx.z01、xxx.z02、xxx.z03、xxx.zip类型解决方案zip -s 0 xxx.zip —out unsplit.zip #把分开的文件合并成一个文件 -s 代表把压缩的文件分为几部分压缩，0 代表不分割，具体数字如 100m 则代表分为每份大小100m。 以上，如有错误，请指正，谢谢。","link":"/2017/02/12/how-to-unzip-a-split-archive-on-mac-osx/"},{"title":"Javascript的单线程和异步之间的关系","text":"js的异步、线程、队列 ：本文介绍javascript的异步和单线程的关系，以及简单解释了单线程的js怎么异步处理。 异步计时函数setTimeout()123456var begin = new Date();//代码开始setTimeout(function(){ var end = new Date(); alert('你好，这个程序已经运行了' + (end - begin) + '毫秒');},3000);//1秒后弹出对话框while ((new Date() - begin) &lt; 6000) {}//循环代码持续3秒，3秒后，整个js调用栈的程序才执行完毕（在控制台中可以看到3秒后才出现一个响应undefined） 上面的代码跟下面的对比一下：123456var begin = new Date();//代码开始setTimeout(function(){ var end = new Date(); alert('你好，这个程序已经运行了' + (end - begin) + '毫秒');},6000);//6秒后弹出对话框while ((new Date() - begin) &lt; 3000) {}//循环代码持续3秒，3秒后，js调用栈执行完毕，控制台出现undefined，然后再过6-3=3秒后，出现弹框 解析：当js解析器解析到setTimeout时，就调用了浏览器的api——异步函数setTimeout，此时js继续往下解析执行，而浏览器就另有一个线程来处理异步函数setTimeout，也就是1秒后把回调函数放入js执行队列中。而此时，js调用栈中继续执行剩下的代码，直至完成了后面的循环后（调用栈中所有代码已经执行完毕）才解析队列中的回调函数来执行。 异步IO函数这里我们介绍下ajax，为了方便起见，直接使用jquery来说明1234$.get('http://blog.zjien.com', function(resData){alert(resData);} );while(true){} js在解析并执行到$.get()时，发起http请求，我看打开F12可以看到请求是处于Pending状态，通过WireShark或Fiddler2可以查看到HTTP请求状态，可知请求是成功发送并且有响应，但是因为下面的while是死循环，因此$.get()里的回调函数一直在队列中排队，得不到js的解析和执行，呈现出假死的状态。换一种形式来展示1234$.get('http://blog.zjien.com',function(resData){alert(resData);});alert('go on?'); js解析并执行到go on时，浏览器弹出窗口，暂时不要关闭窗口，通过F12可以看到，请求是Pending状态，但通过Wireshark等工具看到请求是完成并得到响应的，只是因为go on阻塞/阻止了时间循环，导致$.get的回调无法执行，只有按下确定关闭了go on框，回调才得以执行。这是在chrome的情况如此。在Firefox下却不会出现此情况，go on并不能阻止事件循环，所以上面两个代码段的ajax（$.get）的回调都可以执行，于是界面出现3个alert弹框。 注意，每个窗口有一个js线程(单线程)，若一个窗口中有多个tag，那么这多个tag都是用同一个js线程。","link":"/2016/06/01/js-async-singleThread-queue/"},{"title":"查看一次SQL的执行时间与相关参数","text":"mysql之sql执行过程窥探 ：本文讲解如何窥探sql执行过程的相关参数 1.首先查看当前session（会话）的profiling是否打开select @@profiling若为0，则未打开， 2.打开profilingset profiling=1 3.执行一些sql 4.查看所有已执行的sql的profileshow profiles 5.看看刚才某条sql执行的具体时间拆分，2是个某次查询的idshow profile for query id 6.看看刚才某条sql执行的具体时间拆分，并加上相应的cpu信息 (cpu也可以换成all，以查看更多系统指标)show profile cpu for query id 整理自：http://itindex.net/detail/51526-mysql-sql-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4","link":"/2016/07/03/mysql-sql-execution-check-out/"},{"title":"Laravel-自动发现扩展包","text":"Laravel-自动发现扩展包 ：本文主要讲解Laravel如果基于Composer实现自动发现扩展包 Laravel附带了一个composer.json文件,当一些Laravel包被拉取到本地后,还需要几步手动配置使之能在Laravel项目中使用 注册 Service Provider 注册 Alias或Facade 发布 asset第一、二步已被 Taylor Otwell 确认有点繁琐,因此联合 Dries Vints 开发并推出了「自动注册 Service Provider 和 Facade」功能 在搜索并安装/更新不同的扩展包时,Composer会触发多个事件,这些事件可供订阅,一旦订阅的事件被触发,可调起一段自定义的代码或一条可执行的命令行.当Composer生成最终的类加载文件.其中一个名为 post-autoload-dump 的事件将会被触发.而后,Laravel已可访问所有类并且项目可使用这些类了 之所以会这样,是因为Laravel在composer.json文件里订阅了 post-autoload-dump 事件 123456\"scripts\": { \"post-autoload-dump\": [ \"Illuminate\\\\Foundation\\\\ComposerScripts::postAutoloadDump\", \"@php artisan package:discover\" ]} 首先,调起postAutoloadDump方法,该方法负责清除之前缓存的services和包.然后运行 package:discover 命令,这是关键所在 找寻扩展包Illuminate\\Foundation\\Console\\PackageDiscoverCommand 调用 Illuminate\\Foundation\\PackageManifest 类的 build() 方法. PackageManifest 类里包含 Laravel自动找寻已安装包 的实现PackageManifest 类在应用启动时就被注册入容器里了(是在 Illuminate\\Foundation\\Application::registerBaseServiceProviders() 里注册) 在 build() 方法内,Laravel会去寻找 vendor/composer/installed.json 文件(该文件由composer生成),Laravel会映射这个文件的内容并且递归搜索含有 extra.laravel 的包12345678910\"extra\": { \"laravel\": { \"providers\": [ \"Barryvdh\\\\Debugbar\\\\ServiceProvider\" ], \"aliases\": { \"Debugbar\": \"Barryvdh\\\\Debugbar\\\\Facade\" } }} 然后搜索 composer.json 文件的 extra.laravel.dont-discover 区段来判断是否有指定无需自动发现的包1234567\"extra\": { \"laravel\": { \"dont-discover\": [ \"barryvdh/laravel-debugbar\" ] }} 你可以添加 * 到数组区段里来告诉laravel不执行自动发现 至此,laravel已经收集好了有关扩展包的信息.接下来是把这些信息写入到 bootstrap/cache/packages.php 文件12345678910111213&lt;?php return array ( 'barryvdh/laravel-debugbar' =&gt; array ( 'providers' =&gt; array ( 0 =&gt; 'Barryvdh\\\\Debugbar\\\\ServiceProvider', ), 'aliases' =&gt; array ( 'Debugbar' =&gt; 'Barryvdh\\\\Debugbar\\\\Facade', ), ),); 注册扩展包当Laravel Kernel启动时,会有两个 bootstrapper启动器 会被调用到 \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders 第一个使用 Illuminate\\Foundation\\AliasLoader 将所有 Facade 加载到容器里,现在唯一不同的是laravel会把 packages.php 里需要加载的 aliases 都一并加载到容器.(使用 PackageManifest::aliases() 方法来收集这些信息)12345// in RegisterFacades::bootstrap()AliasLoader::getInstance(array_merge( $app-&gt;make('config')-&gt;get('app.aliases', []), $app-&gt;make(PackageManifest::class)-&gt;aliases()))-&gt;register(); 如上所示,config/app.php 里配置的 aliases 和 PackageManifest类 的 aliases 合并到一起. 相似地,Service Provider 也是这样注册. RegisterProviders 启动器调用 Foundation\\Application::registerConfiguredProviders() 把Laravel从所有扩展包中收集的 Service Provider 注册入容器123456$providers = Collection::make($this-&gt;config['app.providers']) -&gt;partition(function ($provider) { return Str::startsWith($provider, 'Illuminate\\\\'); });$providers-&gt;splice(1, 0, [$this-&gt;make(PackageManifest::class)-&gt;providers()]); 欢迎转载但请附上链接，谢谢。 原文：laravels-package-auto-discovery 如有什么错误，欢迎提出、讨论，大家共同进步 ^_^","link":"/2019/09/24/laravels-package-auto-discovery/"},{"title":"负值margin","text":"margin ：当margin取负值时，会发生什么有趣的事情呢？ 我们来谈谈使用负margin的好处以及用法：margin: -100px; 使用负margin时，需要注意的地方 负margin是标准的CSS 负margin不是一种hack方法 负margin不脱离文档流，不使用float的前提下，有负margin的元素是不会破坏页面的文档流。所以如果你使用 负margin来向上移一个元素，所有跟随的元素都会被向上移动。 完全兼容任何浏览器 float会影响负值margin的使用，因此在使用时要注意 负值margin也是一种布局方式。 上代码：注意margin-top和margin-bottom、margin-left和margin-right的区别，以及块级元素和行内元素(也即内联元素)使用负值margin时的区别。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;负margin的使用&lt;/title&gt; &lt;style type=\"text/css\"&gt; /*把浏览器默认的样式去掉*/ body { margin: 0; padding: 0; } .kuaiji { background-color: blue; /*元素将被向上拉10px*/ /*margin-top: -10px;*/ /*元素将被向左拉10px*/ margin-left: -10px; /*test元素下面的跟随元素将被向左拉进test元素10px,向左拉进是对于跟随元素是行内元素而言*/ margin-bottom: -5px; /*test元素右面的跟随元素将被向左拉进test元素10px，向上拉进是对于跟随元素是块级元素而言*/ margin-right: -10px; } .toppull { background-color: rgba(45, 236, 53, .7); color: #000; /*如果没有设置width，那么margin-left和right为负值时，元素会向左/右拖动并且被拉大宽度，此时margin作用效果与padding一样。如果设置了width，元素就只移动，不会被拉大*/ /*width: 1366px;*/ /*margin-left: -10px;*/ } .hangnei { display: inline; background-color: red; margin-left: -10px; /*把跟随的内联元素向左拉进来*/ margin-right: -10px; } .leftpull { display: inline; /*效果同上面margin-right: -10px;一样*/ /*margin-left: -10px;*/ background-color: rgba(236, 207, 35, .7); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"kuaiji\"&gt; 块级元素测试&lt;/div&gt;&lt;div class=\"toppull\"&gt; 块级元素测试——这是第二个元素，会被上一个元素（即蓝色）向上拉进去&lt;/div&gt;&lt;h2&gt;块级元素测试&lt;/h2&gt;&lt;br/&gt;&lt;hr/&gt;&lt;h2&gt;行内元素测试&lt;/h2&gt;&lt;div class=\"hangnei\"&gt; 行内元素测试&lt;/div&gt;&lt;div class=\"leftpull\"&gt; 行内元素测试——这是第二个元素，会被上一个元素（即红色）向左拉进去&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2016/05/18/negative-margin/"},{"title":"PHP异常处理","text":"PHP异常处理：异常与错误，以及对应的回调函数 error_reporting()；//填写遇到哪些错误/异常 系统才会抛出来，例如 E_CORE_WARNING、E_NOTICE、E_DEPRECATED 是可以忽略的，当设置后，发生这些异常，系统将不会抛出 先分清error错误与Exception异常的区别 一、error_reportingerror_reporting()函数可以获取/设置脚本处理哪些异常，该函数将覆盖php.ini中的error_reporting设置error_reporting(E_ALL&amp;~E_NOTICE);//除了E_NOTICE其他异常都会被触发 （E_ALL&amp;~E_NOTICE 的二进制运算结果是：E_NOTICE对应位的值被设置为0,应注意到，错误和日志记录值都是一个二进制数,某一位设置为1） 二、try-catch、thrown注意：try-catch在 自动加载函数__autoload内无效。try-catch 用于捕获异常，无法捕获错误，例如 trigger_error() 触发的错误，异常和错误是不一样的。然后一个try下可以跟多个catch，用以捕捉不同的异常类型。若在catch中无法完全处理捕获的异常，可以再次抛出。thrown 抛出异常：thrown new Exception('base Exception'); 三、Exception及其子类Exception是所有异常类的基类，当然我们可以扩展它在多个catch匹配中，Exception基类应该是放在最后一个的，因为它是基类，如果其他异常类都不匹配，那么将会被最后一个catch的Exception捕获 四、Exception 异常的回调函数在php中，有很多类似的回调函数，如脚本结束回调函数、错误回调函数、异常回调函数等。这里我们先介绍异常回调函数:set_exception_handler($function_name);如:1234set_exception_handler('myExceptionHanlderFunc');//发生 Exception 或其 子类的 异常是会调用此函数function myExceptionHanlderFunc($errorObj) {//Exception 异常的回调函数 只有一个参数，就是抛出的异常对象//code goes here} Exception 异常的回调函数并不能像 set_error_handler 的回调函数那样通过返回 true 来使异常被消除，即使回调函数处理了异常，后继代码也不会被继续执行（注意：抛出的异常即使没有被处理，脚本结束回调函数register_shutdown_function();还是可以被执行。），因此想继续执行后续代码必须使用 try-catch，在 try-catch 内被捕获的异常不会触发 exception_handler。 脚本结束回调函数：12345register_shutdown_function('myShutdownFunc');function myShutdownFunc() {//code goes hereecho 'script is end';} 因为 myShutdownFunc() 在脚本结束时被执行，所以 这个回调函数之内可以调用脚本中任意位置的函数，即使该函数定义在 错误抛出位置之后(函数定义是在 脚本编译期完成的)。 五、手动触发错误trigger_error(string errorMsg, [int user_error_type])该函数用于主动手动触发一个错误： user_error_type 只能是 E_ALL、E_USER_ERROR、 E_USER_WARNING、 E_USER_NOTICE 或其组合的值。好了，下面介绍下错误处理函数，该函数处理包括系统和用户抛出的Error，并且可以通过 返回true或者无返回值 来消除错误注册错误处理函数：1234567//设置一个回调函数来处理错误，包括系统抛出的错误和用户使用 trigger_error() 函数触发的错误。set_error_handler('myErrorHanlderFunc'[,user_error_type]);//可选参数 user_error_type.如果设定此参数，则 trigger_error 抛出的错误类型符合 在user_error_type 的定义范围才能触发回调函数。这个值的设置类似于error_reporting() 函数 。function myErrorHanlderFunc($errType,$errMsg[,$errFile,$errLine,$errContext]) {//error hanlderreturn true;//或者不返回值，则消除错误//return false;//返回false，则系统错误处理机制仍然继续抛出该错误，如果不处理，则报错并且终止脚本的运行} set_error_handler里的第一个参数是一个函数名，该函数名将有5个参数，前两个是必须的，其他选填，分别为：trigger_error 抛出的 user_error_type、trigger_error 抛出的 errorMsg、抛出错误的文件的绝对路劲、抛出错误的行号、抛出错误时的上下文环境 (一个数组，包含了trigger_error() 所在作用域内的所有变量、函数、类等数据 ) 你可以使用 set_error_handler() 来将 PHP 程序 抛出的错误代理给 ErrorException使错误可以类似异常那样显示：12345678910111213141516function error_handler($errorType, $errorMsg, $errorFile, $errorLine ) { echo '&lt;div style=\"color:red;\"&gt;error_handler is called!&lt;/div&gt;'; throw new ErrorException($errorMsg, 0, $errorType, $errorFile, $errorLine);//继续抛出ErrorException异常，catch可以获取到}set_error_handler('error_handler');count(); 用户使用 trigger_error() 触发的错误不会被 try-catch 异常捕获语句捕获。//设置一个回调函数来处理错误，包括系统抛出的错误和用户使用 trigger_error() 函数触发的错误。set_error_handler('myErrorHanlderFunc'[,user_error_type]);//可选参数 user_error_type.如果设定此参数，则 trigger_error 抛出的错误类型符合 在user_error_type 的定义范围才能触发回调函数。这个值的设置类似于error_reporting() 函数 。function myErrorHanlderFunc($errType,$errMsg[,$errFile,$errLine,$errContext]) {//error hanlderreturn true;//或者不返回值，则消除错误//return false;//返回false，则系统错误处理机制仍然继续抛出该错误，如果不处理，则报错并且终止脚本的运行}","link":"/2016/05/15/php-exception/"},{"title":"PHP生成器函数及yield关键字","text":"生成器函数：本文介绍了PHP的生成器函数和yield关键字的作用以及用法 生成器函数generator function它很适合用来写迭代器iterator，可以在循环中定义一个可以计算并且返回值的函数 12345678910111213141516//生成器函数function xrange($min, $max) { for($i = $min; $i &lt;= $max; $i++) { yield $i; }}foreach(xrange(1, 10) as $key =&gt; $value) { echo $key,'=&gt;',$value,PHP_EOL;}//会输出0=&gt;11=&gt;2...9=&gt;10 生成器函数和普通函数有什么不同呢？就拿上面的例子来说，如果我们是使用了普通的range函数，那么该函数将会在内存生成整个数字数组并且返回整个数组到foreach中，然后foreach再遍历整个数组，range函数和foreach只交互一次，就如同一个快递员把一整个装有东西包裹给你，然后你自己拆开包裹并且从里面一个一个的拿出东西来，这样快递员和你只进行了一次交互/交流。当我们使用了生成器函数时，php会跟踪该函数并且一直执行该函数直到遇到yield关键字或者到函数末尾。当遇到yield关键字时，它会马上返回当前值给foreach处理，然后马上又回到生成器函数里从遇到yield的地方开始再次继续执行，因此本例子在生成器函数里有for循环，因此生成器函数会再次执行下一次for循环并且会再次yield，直到循环条件不满足时结束循环。这就像foreach和生成器函数在大乒乓球一样，一人一次，接着有下一次。 那么我们为什么需要生成器函数呢？生成器函数可以用在内存有限的环境中，如执行一个range(1,1000000)会导致一个Fatal错误，而同样的用生成器函数去做却可以正常工作，因为生成器函数每次执行只占很少的内存。不像是普通函数那样占据一整个很大的内存块。 生成器函数的其他用处生成器函数的其他用处还有：用于 异步协同，关于这方面的使用，可以查阅一下两篇博文：Co-operative PHP MultitaskingCooperative multitasking using coroutines (in PHP!) yield关键字在php5.5才引入 深入阅读：http://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.htmlhttp://stackoverflow.com/questions/17223802/what-is-the-difference-between-a-generator-and-an-arrayhttps://en.wikipedia.org/wiki/Generator_%28computer_programming%29 本文参考：http://stackoverflow.com/questions/17483806/what-does-yield-mean-in-php","link":"/2016/05/16/php-generator-function-and-yield/"},{"title":"PHP的静&#x2F;动态——全&#x2F;局变量","text":"PHP变量：本文介绍PHP的各种变量，全局静态变量、全局变量、局部静态变量、局部变量 全局变量/局部变量也即是全局动态变量/局部动态变量=全局普通变量/局部普通变量=外部变量/内部变量 实际上，全局变量(也即全局动态变量/全局普通变量)本身就是静态存储方式，所以全局静态变量也是静态存储方式。全局变量和静态变量都是存储在同一个地方。于是所有全局变量也是静态变量。 静态变量不可以赋表达式，只可以赋常量或者常量表达式，如果定义时没有初始化，系统会自动初始化为0(int)或者’’(空string)。也即可以定义时不进行初始化。普通变量一定要初始化，如果不进行初始化，那么在定义时它的值是不确定的 全局变量/全局动态变量非全局静态变量（全局动态变量）的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 全局静态变量全局静态变量则限制了其作用域，只在定义该变量的源文件内有效，在同一源程序(一个源程序由多个源文件组成)的其它源文件中不能使用它。要定义/声明全局静态变量(外部静态变量)可以在前面加上static关键字 局部变量/局部动态变量凡是局部变量（无论是普通变量还是静态变量）的作用域都是局限与某个小区域内（如函数），普通变量在每次函数调用完后，存储的内容都会消失（实际上不一定，这涉及到php的底层内核原理） 局部静态变量局部静态变量的作用域也是局限与某个小区域（如函数），不同的只是函数每次调用结束后，变量的值不会丢失而是依然存在，在下次函数被调用时，该可以从该静态变量获取之前的值。 总结把局部变量改变为局部静态变量后是改变了它的存储方式，即改变了它的生存期。把全局变量改变为全局静态变量后是改变了它的作用域，限制了它的使用范围。static静态变量会被放在程序的全局存储区中（即在程序的全局数据区，而不是在栈中分配，所以不会导致栈溢出），这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与栈变量和堆变量的区别。 代码演示12345678910111213141516171819202122232425262728293031323334353637&lt;?php//--------------如何理解static静态变量-----------/* 普通局部变量 */function local() { $loc = 0; //这样，如果直接不给初值0是错误的。 ++$loc; echo $loc . '&lt;br&gt;';}local(); //1local(); //1local(); //1echo '===================================&lt;br/&gt;';/* static静态局部变量 */function static_local() { static $local = 0 ; //此处可以不赋0值 $local++; echo $local , '&lt;br&gt;';}static_local(); //1static_local(); //2static_local(); //3//echo $local; 注意虽然静态变量，但是它仍然是局部的，在外不能直接访问的。echo '=======================================&lt;br/&gt;';/* static全局静态变量(实际上:全局变量本身就是静态存储方式,所以所有的全局变量都是静态变量) */function static_global() { //global 就是引用外部的全局变量 global $glo; //此处，可以不赋值0，当然赋值0，后每次调用时其值都为0，每次调用函数得到的值都会是1，但是不能想当然的写上\"static\"加以修饰，那样是错误的. $glo++; echo $glo . '&lt;br&gt;';}static_global(); //1static_global(); //2static_global(); //3?&gt; 本文参考：http://hao.jser.com/archive/7370/【php官方手册】","link":"/2016/05/15/php-variables/"},{"title":"require&#x2F;include的区别","text":"引入文件：引入文件有4种方式，require、include、require_once/include_once require_once/include_once与require/includeInclude_once：只引入一次文件，这个方法它在引入前会进行查询已加载文件列表的动作，因此会耗一定的性能，虽然在APC中部分问题已经被解决，但是还有一些小问题依然没有被完美解决，因此，不建议使用_once，（包括require_once，更详细的原因请自行google） inculde与require区别require：1.在引入一个不存在的文件时，会报fatal错误并且终止继续执行。2.它会把自己本身代换成引入的文件内容。3.它是一个语言结构。 include：1.在引入一个不存在的文件时，会报警告并且继续执行。2.它会引入文件并且执行文件里的内容。3.它是一个常规的php函数。 123456789101112if($condition){//根据$condition的真假来判断是否引入文件include './somefile';}if($condition){//根据$condition的真假来判断是否引入文件require './somefile';}for($i=1; $i&lt;=3; $i++) require $i.'.php';//两者一样效果for($i=1; $i&lt;=3; $i++) include $i.'.php'; 两者的使用场景： require通常使用方法，这个函数通常放在 PHP 程序的最前面，PHP 程序在启动执行前，就会先读入 require 所指定引入的文件，使它变成 PHP 程序的一部份。也可以用这个方法将 常用的函数文件 引入到程序中。 include通常使用方法，这个函数一般是放在流程控制(如if else)的处理部分中。PHP 程序在读到 include 的文件时，才将它读进来。这种方式，可以把程序执行时的流程简单化。 注意，使用include/require不建议加括号，这样会拉低一点效率 共同点： 解析程序都将退出php模式并在目标文件的开头进入HTML模 式。这意味着目标文件中的所1.有应该作为php脚本执行的代码都必须被包含在有效的php起始标记和终止标记中。 引入文件时，使用绝对路径是最快的，而’./currentDir.php’又比’currentDir.php’快 都可以用于控制结构中如for、if等。(亲测)","link":"/2016/05/12/require-and-include/"},{"title":"REST API 响应状态码","text":"响应状态码 ：本文简单介绍了设计REST API时，返回的响应应该设置什么样的状态码 响应状态码在涉及REST风格的API时，使用适当和Http响应状态码是很重要的，这样可以提高API消费者（客户端）对API响应信息的理解 状态码分为5大类 1xx：临时响应 2xx：成功 3xx：重定向 4xx：请求错误 5xx：服务器错误 每类的详细 状态码 HTTP方法 响应体内容 含义 Status text 1xx 2xx 200 GET,PUT 资源 操作成功 OK 201 POST 资源,元数据 资源创建成功 Created 202 POST,PUT,DELETE,PATCH N/A 请求已被接受 Accepted 204 DELETE,PUT,PATCH N/A 操作已经执行成功，但是响应体没有数据返回。多用于多次修改同一个资源时填写表单的情况下 No Content 205 POST N/A 操作已经执行成功，但是响应体没有数据返回。多用于创建资源时填写表单的情况下。请看下面解释与204的区别 3xx 301 GET uri链接 资源已被移除（永久重定向） Moved permamently 302 GET uri链接 重定向（临时重定向），http/1.0 的产物 Found 303 GET uri链接 重定向（临时重定向），同302，http/1.1的产物，浏览器会根据返回的uri，自动请求该uri See Other 304 GET N/A 资源没有被修改，使用时header必须带上If-Modified_Since或者If-None-Match Not Modified 307 GET uri链接 重定向（临时重定向），同302，http/1.1的产物，浏览器会根据返回的uri，自动请求该uri Temporary Redirect 4xx 400 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 参数列表错误(缺少，格式不匹配) 401 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 未授权 403 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 访问受限，授权过期 404 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 资源，服务未找到 405 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 不允许的http方法 409 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 资源冲突，或者资源被锁定 415 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 不支持的数据(媒体)类型 429 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 请求过多被限制 5xx 500 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 服务器内部错误/应用系统内部错误 501 GET,POST,PUT,DELETE,PATCH 错误提示(消息) 接口未实现 附加说明：N/A 代表不适用 接口文档 简单说明 访问地址 请求方式 返回结果 返回结果的字段说明 错误代码 更新记录 状态码的详解HTTP响应状态码主要分为这几种大类： 1xx：临时响应 2xx：成功 3xx：重定向 4xx：请求错误 5xx：服务器错误 204请求执行成功，但是响应体没有数据返回，浏览器不用刷新页面也不用跳转页面，所以如果是表单页面，那么表单里填写的数据将不会被清除。另外一点，即使是标签，如果a标签里的链接返回的是204，那么页面也是不会发生跳转。同时返回204也是代表客户端和服务器端的状态（指该资源状态）已经同步 205 （204与205区别）请求执行成功，但是响应体没有数据返回，浏览器清空表单数据，方便用户再次填写新数据。 304（304与204区别）注意与204的区别，204情况下是返回空文档，并且该文档会替换上次缓存的文件，因此会有文档/文件没有加载的情况（如没有加载jQuery文件因此提示无$函数等）。而304是使用上次缓存 其他需要注意的地方这里谈谈REST其他需要注意的地方，注意，以下内容不是标准。 PUT与PATCH区别我们都知道，更新操作可以通过PUT与PATCH方式提交请求，但是问题来了，PUT和PATCH有什么区别呢？PUT，正如其词，就是把一大堆数据PUT到服务端，使用PUT更新资源时，需要把资源的所有属性都要提交到服务端。PATCH，补丁，碎片，可以知道，使用PATCH更新资源时，只需要把资源的部分属性/信息提交到服务端即可。 关于URI设计 从属关系使用嵌套形式，即articles/1/comments，articles/1/comments/2 筛选使用查询键值对的形式，即?key=value，articles?title=first_api 关于各种框架对REST的支持与实现本节内容打算放到另一篇文章讲未完待续… 整理自整理自整理自整理自","link":"/2016/06/21/rest-status-code-setting/"},{"title":"超时调用和循环调用","text":"setTimeout和setInterval ：本文介绍这两个浏览器提供的api及其底层的原理 超时调用就是setTimeout(function(){}, delay);第一参数：要执行的回调函数第二参数：延迟多少毫秒，表示在指定时间之后添加回调函数到执行队列中，如果指定时间之后队列中没有其他要执行的代码，那么被添加的代码（即回调函数）会被立即执行。如果队列中有其他代码，那么回调函数会在队列里的代码执行完毕之后才执行。 可以使用clearTimeout()；来清楚 未执行 的任务12var a = setTimeout(function(){}, 1000);clearTimeout(a); 循环调用就是setInterval();第一参数：要执行的回调函数第二参数：延迟多少毫秒，表示定期添加回调函数到执行队列中，如果指定时间之后队列中没有其他要执行的代码，那么被添加的代码（即回调函数）会被立即执行。如果队列中有其他代码，那么回调函数会在队列里的代码执行完毕之后才执行。注意，这个函数会定期不停的添加回调函数到执行队列的。 清除同上，使用clearInterval(a);12var a = setInterval(function(){}, 1000);clearInterval(a); 以上两个函数都不一定会严格按照指定的时间间隔执行，这主要看执行队列中是否还有其他待执行的代码（也因为JS是单线程的） 注意,setTimeout和setInterval都是浏览器的api（由浏览器提供的内置函数），是一种异步函数。上面所说的队列是准确来说是指 异步任务队列 ，而js在执行着的代码是处于js调用栈里的代码","link":"/2016/05/25/settimeout-and-setintervel/"},{"title":"同步编程与异步编程的转换和对比","text":"同步转换异步 ： 本文介绍了nodejs下的同步模型转换成异步模型（异步代码的设计） 开始转变思路这里转变思路是指由同步模型代码转换成异步模型代码要使用Node.js，就有必要了解异步编程的工作原理。异步代码设计并非简单的设计，需要一番学习。本文在同步代码示例旁边给出了异步代码示例，表明如何更改同步代码，才能变成异步代码。这些示例都围绕Node.js的文件系统(fs)模块，因为它是唯一含有同步I/O操作及异步I/O操作的模块。有了这两种示例，你可以开始转变思路了。 相关代码和独立代码回调函数(callback function)是Node.js中异步事件驱动型编程的基本构建模块。它们是作为变量，传递给异步I/O操作的函数。一旦操作完成，回调函数就被调用。回调函数是Node.js中实现事件的机制。下面显示的示例表明了如何将同步I/O操作转换成异步I/O操作，并显示了回调函数的使用。示例使用异步fs.readdirSync()调用，读取当前目录的文件名称，然后把文件名称记录到控制台，最后读取当前进程的进程编号(process id)。1234567891011121314151617181920212223242526/*相关代码和独立代码*/ //任务：读取当前目录下的所有文件名称。并获取当前进程的编号pid //对任务的分析：因为读取文件名称 和 获取当前进程pid 是两件无关联的独立事情，所以如果要在一份代码中完成这两任务，可以考虑对它们进行异步处理//同步版本var fs = require('fs'),filenames,i,processId;//1、读取当前目录下的文件名称filenames = fs.readdirSync('.');//处理器等待该处的IO操作，所以此处需要改成异步fs.readdir()for(i = 0; i&lt; filenames.length; i++) { console.log(filenames[i]);}//到此，都是做了同一件事，就是读取文件名称并且显示在控制台上。console.log(\"ready\");//2、获取当前进程的pidprocessId = process.getuid();//因为是同步模式，所以要在上面readdirSync执行完后才会执行此行代码。//异步版本var fs = require('fs'), filenames, i, processId;//1、读取当前目录下的文件名称fs.readdir('.', function(err, filenames) {//第二个参数为回调，因为这里是异步模式，而跟任务1有关的一系列操作都放到回调里面，因为当读取完成后，相关联的一系列操作将会被回调，执行。 var i; for(i=0;i&lt;filenames.length; i++) { console.log(filenames[i]); } console.log('ready');});//2、获取当前进程的pidprocessId = process.getuid();//因为是异步模式，所以当上面readdir被调用后，不用等待它执行完毕，就马上执行此行代码。这就是异步模式 在同步示例中，处理器等待fs.readdirSync() I/O操作，所以这是需要更改的操作。Node.js中该函数的异步版本是fs.readdir()。它与fs.readdirSync()一样，但是回调函数作为第二个参数。使用回调函数模式的规则如下：把同步函数换成对应的异步函数，然后把原先在同步调用后执行的代码放在回调函数里面。回调函数中的代码与同步示例中的代码执行一模一样的操作。它把文件名称记录到控制台。它在异步I/O操作返回之后执行。就像文件名称的记录依赖fs.readdirSync() I/O操作的结果，所列文件数量的记录也依赖其结果。进程编号的存储独立于I/O操作的结果。因而，必须把它们移到异步代码中的不同位置。规则就是将相关代码移到回调函数中，而独立代码的位置不用管。一旦I/O操作完成，相关代码就被执行，而独立代码在I/O操作被调用之后立即执行。 对顺序要求严格的任务同步代码中的标准模式是线性顺序：几行代码都必须下一行接上一行来执行，因为每一行代码依赖上一行代码的结果。在下面示例中，代码首先变更了文件的访问模式(比如Unix chmod命令)，对文件更名，然后检查更名后文件是不是符号链接。很显然，该代码无法乱序运行，不然文件在模式变更前就被更名了，或者符号链接检查在文件被更名前就执行了。这两种情况都会导致出错。因而，顺序必须予以保留。123456789101112131415161718192021/*顺序严格的任务*///任务：1、修改文件的访问权限。2、然后对文件改名。3、然后检查更名后的文件是不是符号链接(symlink也即Linux里的软连接)。//对任务的分析：很显然，该任务无法乱序运行，不然文件在访问权限变更前就被改名了，或者对符号链接的检查在文件被更名前就执行了。这两种情况都会导致出错。因而，顺序完成这两任务是必须予以保留的。//同步版本var fs = require('fs'), oldFilename, newFilename, isSymLink;oldFilename = './processId.txt';newFilename = './processIdOld.txt';fs.chmodSync(oldFilename, 777);fs.renameSync(oldFilename, newFilename);isSymLink = fs.lstatSync(newFilename).isSymbolicLink();//异步版本var fs = require('fs'), oldFilename, newFilename, isSymLink;oldFilename = './processId.txt';newFilename = './processIdOld.txt';fs.chmod(oldFilename, 777, function(err) {//虽然这里是采用了异步处理，但是因为这些任务都是需要顺序处理才不会出错，因为在回调里嵌套回调，这里才能保证异步模式下顺序处理这种顺序任务 fs.rename(oldFilename, newFilename, function(err) { fs.lstat(newFilename, function(err, stats) { var isSymLink = stats.isSymbolicLink(); }); });}); 在异步代码中，这些顺序变成了嵌套回调。该示例显示了fs.lstat()回调嵌套在fs.rename()回调里面，而fs.rename()回调嵌套在fs.chmod()回调里面。 并行处理异步代码特别适合操作I/O操作的并行处理：代码的执行并不因I/O调用的返回而受阻。多个I/O操作可以并行开始。在下面示例中，某个目录中所有文件的大小都在循环中累加，以获得那些文件占用的总字节数。使用异步代码，循环的每次迭代都必须等到获取单个文件大小的I/O调用返回为止。异步代码允许快速连续地在循环中开始所有I/O调用，不用等结果返回。只要其中一个I/O操作完成，回调函数就被调用，而该文件的大小就可以添加到总字节数中。唯一必不可少的有一个恰当的停止标准，它决定着我们完成处理后，就计算所有文件的总字节数。1234567891011121314151617181920212223242526272829303132333435/*并行处理*///任务：1、获取当前目录下所用文件的大小。2、然后统计所有文件的总大小//分析：因为需要首先知道每个文件的大小，而对每个文件的大小的获取是独立的，因此可以使用异步模式来同时读取多个文件的大小，最后需要设置一个标志用以告诉所有文件(最后一个文件)的大小都已经获取到并且总大小已经统计完成了，可以输出到控制台。//同步版本var fs = require('fs');function calculateByteSize() { var totalBytes = 0, i, filenames, stats; filenames = fs.readdirSync('.'); for(i=0;i&lt;filenames.length;i++) { stat = fs.statSync('./' + filenames[i]);//同步，这样下一个文件大小的获取需要等到本轮读取该文件大小完成才能进行。 totalBytes += stats.size; } console.log(totalBytes);}calculateByteSize();//等到里面全部操作(都是同步操作)都执行完毕，函数才返回（结束）【同步】//异步版本var fs = require('fs');var count = 0;totalBytes = 0;function calculateByteSize() { fs.readdir('.', function(err, filenames) {//引申出的一个问题，在一个函数内调用一个异步操作，那么是异步操作全部完成后该函数才结束，还是函数先结束，但是异步操作依然还在运行？ var i; count = filenames.length; for(i=0;i&lt;filenames.length;i++) { fs.stat('./'+filenames[i], function (err, stats) {//调用fs.stat()了就马上继续下一轮循环，不等待该轮执行完成。这样就可以多个文件同时进行大小的获取。 totalBytes += stats.size; count--; if(count === 0) { console.log(totalBytes); } }); } });}calculateByteSize();//就此例而言，该函数被调用后就马上结束了。而里面的操作(都是异步操作)还在运行中【异步】。至于为什么函数结束后，里面的变量还能用，这就涉及到了闭包的知识点了 同步示例简单又直观。在异步版本中，第一个fs.readdir()被调用，以读取目录中的文件名称。在回调函数中，针对每个文件调用fs.stat()，返回该文件的统计信息。这部分不出所料。 值得关注的方面出现在计算总字节数的fs.stat()回调函数中。所用的停止标准是目录的文件数量。变量count以文件数量来初始化，倒计数回调函数执行的次数。一旦数量为0，所有I/O操作都被回调，所有文件的总字节数被计算出来。计算完毕后，字节数可以记录到控制台。 异步示例有另一个值得关注的特性：它使用闭包(closure)。闭包是函数里面的函数，内层函数访问外层函数中声明的变量，即便在外层函数已完成之后。fs.stat()回调函数是闭包，因为它早在fs.readdir()回调函数完成后，访问在该函数中声明的count和totalBytes这两个变量。闭包有关于它自己的上下文。在该上下文中，可以放置在函数中访问的变量。 要是没有闭包，count和totalBytes这两个变量都必须是全局变量。这是由于fs.stat()回调函数没有放置变量的任何上下文。calculateBiteSize()函数早已结束，只有全局上下文仍在那里。这时候闭包就能派得上用场。变量可以放在该上下文中，那样可以从函数里面访问它们。 代码复用代码片段可以在JavaScript中复用，只要把代码片段包在函数里面。然后，可以从程序中的不同位置调用这些函数。如果函数中使用了I/O操作，那么改成异步代码时，就需要某种重构。 下面的异步示例显示了返回某个目录中文件数量的函数countFiles()。countFiles()使用I/O操作fs.readdirSync() 来确定文件数量。span&gt;countFiles()本身被调用，使用两个不同的输入参数：123456789101112131415161718192021222324/*代码复用*///任务：1、返回某个目录中文件数量//同步版本var fs = require('fs');var path1 = './', path2 = '.././';function countFiles(path) { var filenames = fs.readdirSync(path);//同步方式获取目录下所有文件 return filenames.length;}console.log(countFiles(path1)+'files in ' + path1);console.log(countFiles(path2)+'files in ' + path2);//异步var fs = require('fs');var path1 = './', path2 = '.././', logCount;function countFiles(path, callback) { fs.readdir(path, function (err, filenames) { callback(err, path, filenames.length); });}logCount = function(err, path, count) { console.log(count + 'files in '+ path);};countFiles(path1, logCount);//若这里依然是使用console.log去调用countFiles，因为countFiles是异步的，等到countFiles处理完毕返回值的时候，console.log已经结束运行了(因为countFile是异步的，所以console.log调用了countFiles之后就马上结束而不等待countFiles返回结果了)。所以是由conutFiles去调用console.log。于是把log放进异步的回调函数里才可以countFiles(path2, logCount); 把fs.readdirSync()换成异步fs.readdir()迫使闭包函数countFiles()也变成异步，因为调用countFiles()的代码依赖该函数的结果。毕竟，只有fs.readdir()返回后，结果才会出现。这导致了countFiles()重构，以便还能接受回调函数。整个控制流程突然倒过来了：不是console.log()调用countiles()，countFiles()再调用fs.readdirSync()，在异步示例中，而是countFiles()调用fs.readdir()，然后countFiles()再调用console.log()。 结束语本文着重介绍了异步编程的一些基本模式。将思路转变到异步编程绝非易事，需要一段时间来适应。虽然难度增加了，但是获得的回报是显著提高了并发性。","link":"/2016/05/24/sync-vs-async-and-they-transfers/"},{"title":"标题和段落文字大小以及排版设计","text":"标题和段落字体大小 ：本文我们讨论使用em来设置标题和段落字体大小，并且相关排版的设计 这一类的排版建议把标题设置为默认字体大小的1.125em，也即1.125倍，而正文字体为0.75em，line-height为相对正文字体大小的1.5em（注意不是相对默认字体16px设定，是相对正文字体大小设定），建议再设置标题块（如h1）和段落块（如p）的margin同为相对正文字体大小的1.5em。下面我们写出具体代码以及解释 假设默认字体大小为16px（事实也确实如此）1234&lt;div class=\"container\"&gt; &lt;h1&gt;...&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt;&lt;/div&gt; 12345678910111213/*基本css样式设置*/html { font-size: 100%;/*为了兼容IE*/}body { font-size: 1em;}.container { width: 46.25em; /*740px/16px=46.25em*/ margin: 1.5em auto border : 0.0625em solid #ccc /*1px/16px=0.0625em*/} 给标题设置样式：“18px”的字体，“18px”的行高以及margin值123456h1 { font-size: 1.125em /*先继承它的父元素的默认大小16px，然后换成：18px/16px=1.125em*/ /*为了美观，建议加上行高和margin*/ line-height: 1em;/*也是18px，但是它这里是相对于上面的font-size来说，因此是18px(line-height)÷18px(font-size)=1em*/ margin: 1em; /*18px(margin) ÷ 18px(font-size) = 1em */} 给标题设置样式：“12px”的字体，“18px”的行高以及margin值123456p { font-size: 0.75em /*先继承它的父元素的默认大小16px，然后换成：12px/16px=0.75em*/ /*为了美观，建议加上行高和margin*/ line-height: 1.5em;/*也是18px，但是它这里是相对于上面的font-size来说，因此是18px(line-height) ÷ 12(font-size) = 1.5em */ margin: 1.5em;/*18px(margin) ÷ 12(font-size) = 1.5em */ }","link":"/2016/05/20/title-paragraph-font-size/"},{"title":"Yii的redirect()方法无法终止执行代码","text":"坑爹的redirect() ：在controller里的redirect方法在跳转后，无法终止后续代码的执行。特别在init方法中更棘手。 遇到的情况/问题在写权限控制的时候，在BaseController里的init方法设置了权限检测，如果权限不足则跳转并且终止执行后续代码，可是问题来了，使用了redirect()方法后，确实是跳转了，但是后续操作依然可以执行，显然没有做到控制权限的效果。 问题分析查看redirect源码后，发现redirect()方法只是做了一些头的设置和跳转，并不会终止后续代码的执行，通过在init方法里加return 、return false、 return true等方法后，依然无效。难道要用header('Location: ' . $redirect_url);exit;来解决问题？测试后，使用该方法确实可以解决问题，但是这样写会不会有点恶心啊，于是乎发现Yii有提供Yii:$app-&gt;response-&gt;send();和Yii:$app-&gt;end();可以做到同样效果，最后就在init里使用了Yii::$app-&gt;end();来解决了这个问题。 再次遇到问题经过检验，在普通的actionName()方法里，可以使用return 来终止后续代码的执行，但是在init里却不管用，什么情况？有待研究(因为init()只是执行了并没有return？) 解决方案 在普通的actionName方法里，可以使用return、Yii:$app-&gt;response-&gt;send();、Yii:$app-&gt;end();来解决问题，建议使用return更简洁 在init方法里，只能使用Yii:$app-&gt;response-&gt;send();和Yii:$app-&gt;end();来解决问题了。 如有什么错误，欢迎指定和讨论","link":"/2016/06/16/yii-redirect-cannot-stop-execution/"},{"title":"Yii框架的服务定位器","text":"Yii——组件注册 ：Yii的组件相当于Laravel的服务，同样需要注册到一个IOC容器中，以便在应用其他地方使用这些组件/服务 这相当与在laravel中，使用$app应用的register或者singleton方法注册服务，而在Yii中则称为服务定位器Service Locator。 注册组件在Yii中，要注册组件(laravel中称之为服务)可以使用如下方式： 方法一：set方法1234567891011121314use yii\\di\\ServiceLocator;use yii\\caching\\FileCache;$locator = new ServiceLocator;$locator-&gt;set('cache', 'yii\\caching\\ApcCache');//使用类名直接创建$locator-&gt;set('db', [//通过配置数组来注册'class' =&gt; 'yii\\db\\Connection','dsn' =&gt; 'mysql:host=localhost;dbname=demo','username' =&gt; 'root','password' =&gt; '',]);$locator-&gt;set('search', function(){//通过一个匿名函数返回实例来注册return new app\\components\\SolrService;});$locator-&gt;set('pageCache', new FileCache);//直接使用new实例化来注册 方法二：在配置文件中配置返回配置数组的方式，即在应用的配置文件中配置components项1234567891011121314return [ 'components' =&gt; [ 'db' =&gt; [ 'class' =&gt; 'yii\\db\\Connection', 'dsn' =&gt; 'mysql:host=localhost;dbname=demo', 'username' =&gt; 'root', 'password' =&gt; '', ], 'cache' =&gt; 'yii\\caching\\ApcCache', 'search' =&gt; function() { return new app\\components\\SolrService; }， ]，]; 请谨慎注册太多应用组件，应用组件就像全局变量，使用太多可能加大测试和维护的难度。 一般情况下可以在需要时再创建本地组件。 使用/访问 组件通过访问上面注册时的名字/ID 来访问，两种方式，get(‘name/id’)和属性$cache = $locator-&gt;get(‘cache’);$cache = $locator-&gt;cache;//通过属性 检查是否注册某个组件$locator-&gt;has(‘name’);","link":"/2016/06/02/yii-service-locator/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Linux命令","slug":"Linux命令","link":"/tags/Linux%E5%91%BD%E4%BB%A4/"},{"name":"耗时任务","slug":"耗时任务","link":"/tags/%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"OOP基础","slug":"OOP基础","link":"/tags/OOP%E5%9F%BA%E7%A1%80/"},{"name":"魔术方法","slug":"魔术方法","link":"/tags/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"name":"访问控制","slug":"访问控制","link":"/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"级联","slug":"级联","link":"/tags/%E7%BA%A7%E8%81%94/"},{"name":"数据库操作","slug":"数据库操作","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"name":"beyond the language","slug":"beyond-the-language","link":"/tags/beyond-the-language/"},{"name":"Composer","slug":"Composer","link":"/tags/Composer/"},{"name":"依赖管理","slug":"依赖管理","link":"/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"composer基本使用","slug":"composer基本使用","link":"/tags/composer%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","link":"/tags/CSS3/"},{"name":"CSS布局","slug":"CSS布局","link":"/tags/CSS%E5%B8%83%E5%B1%80/"},{"name":"布局","slug":"布局","link":"/tags/%E5%B8%83%E5%B1%80/"},{"name":"前段","slug":"前段","link":"/tags/%E5%89%8D%E6%AE%B5/"},{"name":"单位","slug":"单位","link":"/tags/%E5%8D%95%E4%BD%8D/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"版本管理","slug":"版本管理","link":"/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"Git基础","slug":"Git基础","link":"/tags/Git%E5%9F%BA%E7%A1%80/"},{"name":"加密","slug":"加密","link":"/tags/%E5%8A%A0%E5%AF%86/"},{"name":"AES","slug":"AES","link":"/tags/AES/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"单线程","slug":"单线程","link":"/tags/%E5%8D%95%E7%BA%BF%E7%A8%8B/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"数据库优化","slug":"数据库优化","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"},{"name":"查询优化","slug":"查询优化","link":"/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"SQL执行","slug":"SQL执行","link":"/tags/SQL%E6%89%A7%E8%A1%8C/"},{"name":"Frontend","slug":"Frontend","link":"/tags/Frontend/"},{"name":"布局&#x2F;排版","slug":"布局-排版","link":"/tags/%E5%B8%83%E5%B1%80-%E6%8E%92%E7%89%88/"},{"name":"异常处理","slug":"异常处理","link":"/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"yield","slug":"yield","link":"/tags/yield/"},{"name":"迭代器","slug":"迭代器","link":"/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"生成器函数","slug":"生成器函数","link":"/tags/%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0/"},{"name":"变量","slug":"变量","link":"/tags/%E5%8F%98%E9%87%8F/"},{"name":"静&#x2F;动态—全&#x2F;局变量","slug":"静-动态—全-局变量","link":"/tags/%E9%9D%99-%E5%8A%A8%E6%80%81%E2%80%94%E5%85%A8-%E5%B1%80%E5%8F%98%E9%87%8F/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"PHP基础","slug":"PHP基础","link":"/tags/PHP%E5%9F%BA%E7%A1%80/"},{"name":"架构","slug":"架构","link":"/tags/%E6%9E%B6%E6%9E%84/"},{"name":"API设计","slug":"API设计","link":"/tags/API%E8%AE%BE%E8%AE%A1/"},{"name":"接口设计","slug":"接口设计","link":"/tags/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"回调","slug":"回调","link":"/tags/%E5%9B%9E%E8%B0%83/"},{"name":"Nodejs","slug":"Nodejs","link":"/tags/Nodejs/"},{"name":"异步编程","slug":"异步编程","link":"/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"name":"代码设计","slug":"代码设计","link":"/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"文字布局","slug":"文字布局","link":"/tags/%E6%96%87%E5%AD%97%E5%B8%83%E5%B1%80/"},{"name":"字体大小","slug":"字体大小","link":"/tags/%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"framework","slug":"framework","link":"/tags/framework/"}],"categories":[{"name":"Linux命令","slug":"Linux命令","link":"/categories/Linux%E5%91%BD%E4%BB%A4/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"原则","slug":"原则","link":"/categories/%E5%8E%9F%E5%88%99/"},{"name":"Composer","slug":"Composer","link":"/categories/Composer/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"前段","slug":"前段","link":"/categories/%E5%89%8D%E6%AE%B5/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"AES","slug":"AES","link":"/categories/AES/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"REST","slug":"REST","link":"/categories/REST/"},{"name":"代码之上","slug":"PHP/代码之上","link":"/categories/PHP/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"},{"name":"Yii","slug":"PHP/Yii","link":"/categories/PHP/Yii/"},{"name":"Composer命令","slug":"Composer/Composer命令","link":"/categories/Composer/Composer%E5%91%BD%E4%BB%A4/"},{"name":"PHP","slug":"Composer/PHP","link":"/categories/Composer/PHP/"},{"name":"前端","slug":"CSS/前端","link":"/categories/CSS/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前段/CSS","link":"/categories/%E5%89%8D%E6%AE%B5/CSS/"},{"name":"Git命令","slug":"Git/Git命令","link":"/categories/Git/Git%E5%91%BD%E4%BB%A4/"},{"name":"版本管理","slug":"Git/版本管理","link":"/categories/Git/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"加密算法","slug":"AES/加密算法","link":"/categories/AES/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"name":"OS X","slug":"Mac/OS-X","link":"/categories/Mac/OS-X/"},{"name":"基础","slug":"Javascript/基础","link":"/categories/Javascript/%E5%9F%BA%E7%A1%80/"},{"name":"Database","slug":"数据库/Database","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Database/"},{"name":"Laravel","slug":"PHP/Laravel","link":"/categories/PHP/Laravel/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"基础","slug":"PHP/基础","link":"/categories/PHP/%E5%9F%BA%E7%A1%80/"},{"name":"设计","slug":"REST/设计","link":"/categories/REST/%E8%AE%BE%E8%AE%A1/"},{"name":"前端","slug":"Javascript/前端","link":"/categories/Javascript/%E5%89%8D%E7%AB%AF/"},{"name":"Nodejs","slug":"Javascript/Nodejs","link":"/categories/Javascript/Nodejs/"},{"name":"OOP","slug":"PHP/代码之上/OOP","link":"/categories/PHP/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/OOP/"},{"name":"依赖管理","slug":"Composer/PHP/依赖管理","link":"/categories/Composer/PHP/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"基础","slug":"前段/CSS/基础","link":"/categories/%E5%89%8D%E6%AE%B5/CSS/%E5%9F%BA%E7%A1%80/"},{"name":"基础","slug":"Git/版本管理/基础","link":"/categories/Git/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/%E5%9F%BA%E7%A1%80/"},{"name":"Commonly Command","slug":"Mac/OS-X/Commonly-Command","link":"/categories/Mac/OS-X/Commonly-Command/"},{"name":"Mysql","slug":"数据库/Database/Mysql","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Database/Mysql/"},{"name":"Framework","slug":"PHP/Laravel/Framework","link":"/categories/PHP/Laravel/Framework/"},{"name":"基础","slug":"Javascript/前端/基础","link":"/categories/Javascript/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"},{"name":"基础","slug":"Javascript/Nodejs/基础","link":"/categories/Javascript/Nodejs/%E5%9F%BA%E7%A1%80/"},{"name":"framework","slug":"PHP/Yii/framework","link":"/categories/PHP/Yii/framework/"},{"name":"代码设计","slug":"Javascript/Nodejs/基础/代码设计","link":"/categories/Javascript/Nodejs/%E5%9F%BA%E7%A1%80/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"}]}