<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GingJan&#39;s Blog</title>
  <subtitle>Life Feeds On Negentropy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gingjan.com/"/>
  <updated>2023-06-24T11:21:00.167Z</updated>
  <id>https://gingjan.com/</id>
  
  <author>
    <name>GingJan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenResty性能的保证 —— 非阻塞IO</title>
    <link href="https://gingjan.com/2023/03/24/non-blocking-io-of-openresty-performance/"/>
    <id>https://gingjan.com/2023/03/24/non-blocking-io-of-openresty-performance/</id>
    <published>2023-03-24T10:04:55.000Z</published>
    <updated>2023-06-24T11:21:00.167Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>在文件开始时，首先要说的是，在OpenResty编程里的原则是非阻塞IO优先。 OpenResty能有如此高性能的表现是因为基于Nginx的事件响应机制和Lua的协程机制。在请求的处理流里，若使用了阻塞式IO<br>
而不使用如<code>cosocket</code>的非阻塞式方法来处理IO，那LuaJIT是不会把控制权交回给Nginx的事件循环（Event Loop），这就导致了<br>
Nginx里的其他请求只能排队干等着前一个请求的IO处理完毕后才能被处理。以下介绍一些会导致性能下降的写法。</p>
<h2 id="执行外部命令"><a class="header-anchor" href="#执行外部命令"></a>执行外部命令</h2>
<h3 id="关闭进程"><a class="header-anchor" href="#关闭进程"></a>关闭进程</h3>
<p>如使用 <code>os.execute(&quot; cp test.exe /tmp &quot;)</code>，该方法会阻塞当前请求的处理，该如何避免？有两种方式：</p>
<h4 id="1-使用FFI库里的方法代替"><a class="header-anchor" href="#1-使用FFI库里的方法代替"></a>1.使用FFI库里的方法代替</h4>
<p>比如当要kill一个进程时，可以使用：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span> resty_signal = <span class="built_in">require</span> <span class="string">"resty.signal"</span></span><br><span class="line"><span class="built_in">local</span> pid = <span class="number">12345</span></span><br><span class="line"><span class="built_in">local</span> ok, err = resty_signal.<span class="built_in">kill</span>(pid, <span class="string">"KILL"</span>)</span><br></pre></td></tr></table></figure>
<p>在涉及到对图片，加解密等CPU密集型的操作时，可以先查阅下FFI库里有无封装了对应方法。</p>
<h4 id="2-使用基于nginx-pipe-的-lua-resty-shell库"><a class="header-anchor" href="#2-使用基于nginx-pipe-的-lua-resty-shell库"></a>2.使用基于<code>nginx.pipe</code> 的 <code>lua-resty-shell</code>库</h4>
<p>你也可以在非阻塞操作<code>shell.run</code>里运行命令：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ resty -<span class="keyword">e</span> '<span class="keyword">local</span> <span class="keyword">shell</span> = require <span class="string">"resty.shell"</span></span><br><span class="line"><span class="keyword">local</span> ok, stdout, stderr, reason, status =</span><br><span class="line">    <span class="keyword">shell</span>.<span class="keyword">run</span>([[echo <span class="string">"hello, world"</span>]])</span><br><span class="line">    ngx.say(stdout) '</span><br></pre></td></tr></table></figure>
<h2 id="磁盘IO"><a class="header-anchor" href="#磁盘IO"></a>磁盘IO</h2>
<p>下面看下处理磁盘IO的场景，读取配置文件是服务端很常见的操作：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span> path = <span class="string">"/conf/apisix.conf"</span></span><br><span class="line"><span class="built_in">local</span> <span class="built_in">file</span> = io.<span class="built_in">open</span>(path, <span class="string">"rb"</span>)</span><br><span class="line"><span class="built_in">local</span> content = <span class="built_in">file</span>:<span class="built_in">read</span>(<span class="string">"*a"</span>)</span><br><span class="line"><span class="built_in">file</span>:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<p>当然，配置读取只在<code>init</code>初始化时进行一次，而不会在每个请求进来时都进行。但是如果需要在请求里操作磁盘IO，<br>
则需认真考虑如何解决了。<br>
首先可以使用第三方的C模块<code>lua-io-nginx-module</code>，该模块为OpenResty提供了非阻塞IO的Lua API，但是你<br>
不能像使用<code>cosocket</code>那样使用它，因为磁盘IO的耗时操作并没有消失，只是换一种方式进行而已。它利用Nginx的<br>
线程池机制的优势，把磁盘IO的操作从主线程移到其他线程进行，所以主线程不会被磁盘IO所阻塞。<br>
如果要使用该模块，因为它是C模块，所以需要重新编译Nginx，然后像使用普通Lua库那样使用即可。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ngx_io = require <span class="string">"ngx.io"</span></span><br><span class="line"><span class="keyword">local</span> path = <span class="string">"/conf/apisix.conf"</span></span><br><span class="line"><span class="keyword">local</span> <span class="keyword">file</span>, <span class="keyword">err</span> = ngx_io.<span class="keyword">open</span>(path, <span class="string">"rb"</span>)</span><br><span class="line"><span class="keyword">local</span> data, <span class="keyword">err</span> = <span class="keyword">file</span>: <span class="keyword">read</span>(<span class="string">"*a"</span>)</span><br><span class="line"><span class="keyword">file</span>:<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure>
<p>还有一种方式，就是不把数据读/写到磁盘，例如在写日志时：<br>
<code>ngx.log(ngx.WARN, &quot;info&quot;)</code><br>
这好像很正常，但是不能经常调用，因为首先它是较昂贵的函数调用，其次即便有了缓冲，大量且频繁的磁盘写入很影响性能。<br>
那如何处理需要这种写入日志的问题呢？</p>
<p>可以尝试把日志通过<code>cosocket</code>的非阻塞网络调用传输到远程日志服务上。使用<code>lua-resty-logger-socket</code>来实现：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">local logger = require <span class="string">"resty.logger.socket"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> logger.initted() then</span><br><span class="line">    local ok, err = logger.init&#123;</span><br><span class="line">        host = <span class="string">'xxx'</span>,</span><br><span class="line">       <span class="built_in"> port </span>= 1234,</span><br><span class="line">        flush_limit = 1234,</span><br><span class="line">        drop_limit = 5678,</span><br><span class="line">    &#125;</span><br><span class="line">local msg = <span class="string">"foo"</span></span><br><span class="line">local bytes, err = logger.log(msg)</span><br></pre></td></tr></table></figure>
<p>以上两种方式都是为了避免主线程阻塞，一种是放到其他线程处理，一种是通过网络交给远程服务处理。</p>
<h2 id="luasocket"><a class="header-anchor" href="#luasocket"></a>luasocket</h2>
<p><code>luasocket</code>经常与OpenResty提供的<code>cosocket</code>混淆，<code>luasocket</code>也能执行网络通讯的功能，但是它不能<br>
以非阻塞的方式进行，所以使用它会导致性能很差。<br>
当然<code>luasocket</code>也有它的应用场景，在一些无法使用<code>cosocket</code>的阶段，通过会使用ngx.timer来规避，当然<br>
也可以在<code>init_by_lua</code>、<code>init_worker_by_lua*</code>这种一次性阶段的地方使用<code>luasocket</code>来实现<code>cosocket</code><br>
的功能。另外<code>lua-resty-socket</code>是一个兼容<code>luasocket</code>和<code>cosocket</code>的二次封装开源库，它内容值得深入学习，<br>
如果有兴趣，可参考<a href="https://github.com/thibaultcha/lua-resty-socket/" target="_blank" rel="noopener">这里</a></p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>总的来说，在OpenResty里，意识到阻塞IO操作的类型和对应的非阻塞解决方案是写出高性能程序的基础。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在文件开始时，首先要说的是，在OpenResty编程里的原则是非阻塞IO优先。 OpenResty能有如此高性能的表现是因为基于Nginx的事件响应机制和Lua的协程机制。在请求的处理流里，若使用了阻塞式IO&lt;br&gt;
而不使用如&lt;code
    
    </summary>
    
      <category term="Lua" scheme="https://gingjan.com/categories/Lua/"/>
    
      <category term="OpenResty" scheme="https://gingjan.com/categories/Lua/OpenResty/"/>
    
      <category term="Nginx" scheme="https://gingjan.com/categories/Lua/OpenResty/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://gingjan.com/tags/Nginx/"/>
    
      <category term="OpenResty" scheme="https://gingjan.com/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>Go：使用 build tag 来自定义构建配置</title>
    <link href="https://gingjan.com/2023/01/13/go-building-customized-by-using-tag/"/>
    <id>https://gingjan.com/2023/01/13/go-building-customized-by-using-tag/</id>
    <published>2023-01-13T08:25:56.000Z</published>
    <updated>2023-03-21T15:44:30.344Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何通过build tag来根据需要自定义构建应用</p>
<a id="more"></a>
<h3 id="场景"><a class="header-anchor" href="#场景"></a>场景</h3>
<p>通常我们会给每个产品环境设置不同的配置，比如 redis 要在开发环境就连接 localhost:6379，测试环境可能连接某一个主机的 redis。<br>
配置文件通常会使用 env 或者 yml。这样每次构建包放在不同的环境就需要手写一套配置，开发也需要向运维提供配置文档。<br>
最近在一直在用 python，项目通常都是使用 .py 作为配置，直接进行加载，写几份配置，在运行的时候通过命令行参数或者环境变量制定配置加载文件。这样子很大程度减少了开发和运维的沟通成本。<br>
如果放在 go 里面是否可行？因为 go 是编译二进制包，也没有动态加载这么一说，那怎么实现？</p>
<h3 id="使用"><a class="header-anchor" href="#使用"></a>使用</h3>
<p>这个可以使用 build tags 来自定义配置。<br>
假设我们现在有两个环境，dev 和 prod，那么我们可以新建一个 config 文件夹，放入 dev.go 和 prod.go 两个文件，分别写入对应的配置，如下所示。同一个包，同样的变量名，但是不会因为重复声明和报错，因为这里加了 tag，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build dev #⚠️：这是1.17前语法，当在编译时，传入的-tags=dev，则采用本文件的源码进行构建 「go build -o=test -tags=dev .」</span></span><br><span class="line"><span class="comment">// go:build dev #⚠️：这是1.17+语法，当在编译时，传入的-tags=dev，则采用本文件的源码进行构建 「go build -o=test -tags=dev .」</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment">// config list</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Redis = <span class="string">"redis://127.0.0.1:6379/0"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build prod #⚠️：这是1.17前语法，当在编译时，传入的-tags=prod，则采用本文件的源码进行构建 「go build -o=test -tags=prod .」</span></span><br><span class="line"><span class="comment">// go:build prod #⚠️：这是1.17+语法，当在编译时，传入的-tags=prod，则采用本文件的源码进行构建 「go build -o=test -tags=prod .」</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Redis = <span class="string">"redis://192.168.0.1:6379"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>gin-gonic 也有一个编译指令，用于把 encoding/json 包替换为处理速度更快 jsoniter 包，也是使用的构建 tag：$ go build -tags=jsoniter .，实现也很简单，一个加上 // +build jsoniter 另一个默认使用 // +build !jsoniter 。</p>
<p>这里 tag 前加上 <code>!（非标签）</code> 就代表非构建指令下的配置。解释是，非tag1，该文件才会参入编译</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build !tag1  #1.17前</span></span><br><span class="line"><span class="comment">//go:build !tag1 #1.17+</span></span><br></pre></td></tr></table></figure>
<p>tag 常用于交叉编译的配置，例如有些文件针对 linux 而有些文件针对 windows，底层使用的系统调用是不同的，go 源码就包含了很多这样的构建指令：</p>
<p>一行中使用空格就代表“或”的关系，下面指的是在 linux 或者 darwin 环境中使用。（编译时，<code>-tags &quot;linux&quot;</code> 或 <code>-tags &quot;linux || drawin&quot;</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux darwin #1.17前</span></span><br><span class="line"><span class="comment">// go:bulid linux || darwin #1.17+</span></span><br></pre></td></tr></table></figure>
<p>如果要指定“与”的关系，那么可以使用,，下面就是指使用 “linux” 和 “cgo” 两个环境同时满足才使用。（编译时，<code>-tags &quot;linux &amp;&amp; cgo&quot;</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux,cgo #1.17前</span></span><br><span class="line"><span class="comment">// go:bulid linux &amp;&amp; cgo #1.17+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然可以分成多行，下面的指令表述和上面一致：</span></span><br><span class="line">#<span class="number">1.17</span>前</span><br><span class="line"><span class="comment">// +build linux</span></span><br><span class="line"><span class="comment">// +build cgo</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1.17</span>+</span><br><span class="line"><span class="comment">// go:build linux</span></span><br><span class="line"><span class="comment">// go:build cgo</span></span><br></pre></td></tr></table></figure>
<h3 id="为何1-17后使用新的语法？"><a class="header-anchor" href="#为何1-17后使用新的语法？"></a>为何1.17后使用新的语法？</h3>
<ul>
<li>可以发现相对<code> </code>表示<code>或</code>、<code>,</code>表示<code>与</code>，使用<code>||</code>、<code>&amp;&amp;</code>更符合程序员的开发习惯</li>
<li>//go:build 与 //go:embed 和 //go:generate 这些命令相比较，格式上进行了统一<br>
更多还有 ignore 指令来忽略使用这个文件，更多可以查看官方文档，这里不在继续展开。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍如何通过build tag来根据需要自定义构建应用&lt;/p&gt;
    
    </summary>
    
      <category term="Go语言" scheme="https://gingjan.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go" scheme="https://gingjan.com/tags/Go/"/>
    
      <category term="语言" scheme="https://gingjan.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go里的并发和调度器亲和性</title>
    <link href="https://gingjan.com/2022/11/21/concurrency-and-scheduler-affinity-in-go/"/>
    <id>https://gingjan.com/2022/11/21/concurrency-and-scheduler-affinity-in-go/</id>
    <published>2022-11-21T15:47:27.000Z</published>
    <updated>2023-03-25T14:52:53.787Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="亲和性的局限"><a class="header-anchor" href="#亲和性的局限"></a>亲和性的局限</h2>
<p>要理解亲和性的局限，就得先知道本地队列和全局队列发生了什么。<br>
本地队列会被用于除了系统调用外的如channel，select，timer等待等阻塞操作，<br>
然而，两种情况会限制goroutine和线程的亲和性：goroutine窃取和系统调用。<br>
但是，通过更好地管理本地队列的优先级，可以有效规避上述两种情况。<br>
G1.5旨在给予那些通过channel通讯的goroutine更高优先级，从而优化goroutine<br>
与所在线程的亲和性</p>
<h2 id="如何提高亲和性"><a class="header-anchor" href="#如何提高亲和性"></a>如何提高亲和性</h2>
<p>协程在channel上来回通讯会导致该协程被频繁地阻塞，例如前所述，频繁入队本地队列。<br>
然而，由于本地队列是FIFO，当某个协程独占线程时，那些非阻塞的协程没法保证能尽快运行，<br>
如下例子：</p>
<p><img src="/img/concurrency-and-scheduler-affinity-in-go/g9-example.png" alt="从channel阻塞释放的协程"></p>
<p>协程9在被channel阻塞完毕后恢复正常，然而它必须等待2号，5号和4号协程执行完毕，在本例中，<br>
5号协程会独占协程，导致9号协程被延迟执行并增加了9号协程被其他P偷走的风险。<br>
自从Go 1.5版本开始，从channel返回的协程会被传到P的runnext字段以最高优先级执行。</p>
<p><img src="/img/concurrency-and-scheduler-affinity-in-go/runnext-in-processor.png" alt="协程放入到P的runnext"></p>
<p>该方式在再次进入channel阻塞前尽快运行一次，然后其他协程才被陆续执行。<br>
这个方式的引入对Go的标准库的整体起到积极作用。<br>
因为本地队列是FIFO的结构，如果队列里有goroutine独占着OS线程，则刚从channel阻塞出来的<br>
goroutine无法保证尽早的执行。</p>
<p><a href="https://github.com/golang/go/commit/e870f06c3f49ed63960a2575e330c2c75fc54a34" target="_blank" rel="noopener">提高一些库的性能</a></p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<p><a href="https://medium.com/a-journey-with-go/go-concurrency-scheduler-affinity-3b678f490488" target="_blank" rel="noopener">Go: Concurrency &amp; Scheduler Affinity</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;亲和性的局限&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#亲和性的局限&quot;&gt;&lt;/a&gt;亲和性的局限&lt;/h2&gt;
&lt;p&gt;要理解亲和性的局限，就得先知道本地队列和全局队列发生了什么。&lt;br&gt;
本地队列会被用于除了系统
    
    </summary>
    
      <category term="go" scheme="https://gingjan.com/categories/go/"/>
    
      <category term="原理" scheme="https://gingjan.com/categories/go/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="go" scheme="https://gingjan.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>可拆箱即用的分布式追踪系统</title>
    <link href="https://gingjan.com/2022/07/05/towards-turnkey-distributed-tracing/"/>
    <id>https://gingjan.com/2022/07/05/towards-turnkey-distributed-tracing/</id>
    <published>2022-07-05T13:15:27.000Z</published>
    <updated>2023-03-21T15:44:30.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reactive-Streams"><a class="header-anchor" href="#Reactive-Streams"></a>Reactive Streams</h1>
<p>OpenTracing是一款为应用和开源软件包设计的，新的开源分布式追踪标准。具有构建大规模微服务经验的开发人员了解分布式追踪的作用和重要性。即便每个进程都有自己的日志系和指标监控，<br>
但在分布式系统中它们之间都无法联成一个整体。</p>
<p>第一篇关于分布式追凶系统的学术论文已有几十年了，从谷歌内部开始使用Dapper算也有12年了，Dapper论文发布也过去6年了，Zipkin也开源4年了。这个概念并不新颖。但你还在是为复杂的<br>
服务架构，花费大量人力开发追踪系统。</p>
<p>如果分布式追踪这么有价值，为什么大家还没运用呢？因为它在目前为止还是不够完善</p>
<p>因为需要在进程内和进程间传递上下文信息，所以分布式追踪是不容易实现的，若要实现，上下文需要在这些地方之间相互传递：<br>
1.开源服务（如Nginx、Cassandra、Redis等）<br>
2.被用于自定义服务的开源库（如grpc、ORMs等）<br>
3.业务逻辑</p>
<p>还有一个困难点：无法要求全部的开源服务和开源库或者自定义业务逻辑使用单一提供商的追踪库，这样也就无法把服务之间的调用链路组织起来。</p>
<p>因为我们需要一个标准机制来描述系统的行为</p>
<h2 id="了解OpenTracing"><a class="header-anchor" href="#了解OpenTracing"></a>了解OpenTracing</h2>
<p>OpenTracing就是那个「单一且标准的机制」。OpenTracing允许应用代码的开发者、开源库，开源服务不需要绑定特定提供商的追踪代码来实现链路追踪串连。<br>
以下是这套标准：<br>
1.标准化管理span：接口有开始和完成，以及描述定时任务的功能（span是Dapper和Zipkin里的术语）<br>
2.标准化进程间的传递：接口有辅助进程间的追踪上下文传递<br>
3.活跃span的标准化管理：接口可以在单个进程内，在不同包之间保存和获取活跃span<br>
4.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reactive-Streams&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Reactive-Streams&quot;&gt;&lt;/a&gt;Reactive Streams&lt;/h1&gt;
&lt;p&gt;OpenTracing是一款为应用和开源软件包设计的，新的开源分布式追
    
    </summary>
    
      <category term="代码之上" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="架构" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://gingjan.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>优雅重启go应用</title>
    <link href="https://gingjan.com/2021/06/27/graceful-restart-in-golang/"/>
    <id>https://gingjan.com/2021/06/27/graceful-restart-in-golang/</id>
    <published>2021-06-27T03:21:33.000Z</published>
    <updated>2021-06-27T08:41:22.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h1 id="前言"><a class="header-anchor" href="#前言"></a>前言</h1>
<p>需先了解系统信号和相应函数后，再阅读本文将会更丝滑顺畅</p>
<ul>
<li>信号是Linux或Unix类系统中，一种进程间通讯的方式</li>
<li>当信号发送到某个进程时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行</li>
<li>如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用</li>
</ul>
<p>如果有一个go实现的http服务，就会遇到因代码变更或配置修改需重新启动服务的情景，以前使用其他语言实现服务时，从未注意过<br>
无缝重启的问题，因为web服务器（如nginx等）实现无缝重启所以你无需关心，而现在使用Go写服务后，才发现无缝重启也需要自己<br>
动手解决</p>
<p>实际上，无缝重启需要解决的问题有两个</p>
<ol>
<li>无缝重启时，UNIX层面问题，如进程能不关闭正在监听的socket实现重启的机制</li>
<li>确保正在处理的请求可被正常处理完毕或超时退出</li>
</ol>
<h1 id="无需关闭socket的重启"><a class="header-anchor" href="#无需关闭socket的重启"></a>无需关闭socket的重启</h1>
<ul>
<li>生成一个子进程并继承旧进程正在监听的socket</li>
<li>子进程初始化后，开始接收socket的连接</li>
<li>一旦子进程发送信号给父进程时，父进程立刻停止接收新连接并终止运行</li>
</ul>
<h2 id="生成一个子进程"><a class="header-anchor" href="#生成一个子进程"></a>生成一个子进程</h2>
<p>在go库里，有很多种方式可生成子进程，但在解决本文的问题上，使用exec.Cammand是最适合的方式，因为返回的Cmd结构体有个ExtraFiles属性，<br>
该属性指向由父进程继承来的且已打开的文件（除了stdin/err/out，标准输入/输出/错误外）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">file := netListener.File() <span class="comment">//netListener[^1]是一个指针，指向正在监听http请求的net.Listener，File()返回一个fd的dup(2)[^2]，dup(2)返回的是fd的副本fd2，fd2不含`FD_CLOEXEC`标志，该标志会导致子进程的fd2关闭</span></span><br><span class="line">path := <span class="string">"/path/to/executable"</span><span class="comment">//你要启动的服务的路径</span></span><br><span class="line">args := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"-graceful"</span>&#125;</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(path, args...)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.ExtraFiles = []*os.File&#123;file&#125;</span><br><span class="line"></span><br><span class="line">err := cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"gracefulRestart: Failed to launch, error: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也许会在命令行里把需继承的fd号码通过参数传入子进程，但是有ExtraFiles字段，就无需这样做了，ExtraFiles文档说「如果该字段为非nil，则下标i代表的fd是3+i」，也即从fd下标从3开始（因为不包含stdin/out/err）<br>
所以子进程继承的fd永远都是3开始</p>
<p>最后 args切片包含 -graceful 选项，意味着你的程序需要有处理该选项的逻辑，用于分辨子进程需重用socket而不是创建新socket</p>
<h2 id="子进程初始化"><a class="header-anchor" href="#子进程初始化"></a>子进程初始化</h2>
<p>下面是程序启动的流程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server := &amp;http.Server&#123;Addr: <span class="string">"0.0.0.0:8888"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gracefulChild <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> l net.Listever</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">flag.BoolVar(&amp;gracefulChild, <span class="string">"graceful"</span>, <span class="literal">false</span>, <span class="string">"listen on fd open 3 (internal use only)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">    log.Print(<span class="string">"main: Listening to existing file descriptor 3."</span>)</span><br><span class="line">    f := os.NewFile(<span class="number">3</span>, <span class="string">""</span>)<span class="comment">//监听fd=3</span></span><br><span class="line">    l, err = net.FileListener(f)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Print(<span class="string">"main: Listening on a new file descriptor."</span>)</span><br><span class="line">    l, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送信号通知父进程终止运行"><a class="header-anchor" href="#发送信号通知父进程终止运行"></a>发送信号通知父进程终止运行</h2>
<p>在子进程准备接收请求前，需要通知父进程停止接收请求并退出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">    parent := syscall.Getppid()</span><br><span class="line">    log.Printf(<span class="string">"main: Killing parent pid: %v"</span>, parent)</span><br><span class="line">    syscall.Kill(parent, syscall.SIGTERM)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.Serve(l)</span><br></pre></td></tr></table></figure>
<h2 id="还在父进程里处理的请求"><a class="header-anchor" href="#还在父进程里处理的请求"></a>还在父进程里处理的请求</h2>
<p>使用<code>sync.WaitGroup</code>来追踪正在处理的请求，每接收新请求就需自增1，在完成一个请求时就自减1<br>
Go的http标准包里没有hook方式以供在<code>Accept()</code>和<code>Close()</code>时进行一些自定义处理，但这也正是接口发挥作用的地方（Accept和Close属于接口Listener）<br>
（可参考JefR.Allen的这篇<a href="http://blog.nella.org/zero-downtime-upgrades-of-tcp-servers-in-go/" target="_blank" rel="noopener">文章</a>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gracefulListener <span class="keyword">struct</span> &#123;</span><br><span class="line">    net.Listener</span><br><span class="line">    stop    <span class="keyword">chan</span> error</span><br><span class="line">    stopped <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后重写Accept方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gl *gracefulListener)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(c net.Conn, err error)</span></span> &#123;</span><br><span class="line">    c, err = gl.Listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c = gracefulConn&#123;Conn: c&#125;</span><br><span class="line"></span><br><span class="line">    httpWg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了自增，则还需要在连接处理完毕被关闭时的自减方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gracefulConn <span class="keyword">struct</span> &#123;</span><br><span class="line">    net.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w gracefulConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    httpWg.Done()</span><br><span class="line">    <span class="keyword">return</span> w.Conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写一个new方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGracefulListener</span><span class="params">(l net.Listener)</span> <span class="params">(gl *gracefulListener)</span></span> &#123;</span><br><span class="line">    gl = &amp;gracefulListener&#123;Listener: l, stop: <span class="built_in">make</span>(<span class="keyword">chan</span> error)&#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//这里需要一个goroutine是因为上面Accept()方法会在`c, err = gl.Listener.Accept()`地方阻塞住，没法进行关闭操作</span></span><br><span class="line">        _ = &lt;-gl.stop<span class="comment">//阻塞</span></span><br><span class="line">        gl.stopped = <span class="literal">true</span></span><br><span class="line">        gl.stop &lt;- gl.Listener.Close()<span class="comment">//通过Close解除`gl.Listener.Accept()`的阻塞</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写Close</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gl *gracefulListener)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> gl.stopped &#123;</span><br><span class="line">        <span class="keyword">return</span> syscall.EINVAL</span><br><span class="line">    &#125;</span><br><span class="line">    gl.stop &lt;- <span class="literal">nil</span><span class="comment">//发送停止信号到channel，上面的goroutine就会继续运行</span></span><br><span class="line">    <span class="keyword">return</span> &lt;-gl.stop<span class="comment">//等待goroutine处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个获取fd的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gl *gracefulListener)</span> <span class="title">File</span><span class="params">()</span> *<span class="title">os</span>.<span class="title">File</span></span> &#123;</span><br><span class="line">    tl := gl.Listener.(*net.TCPListener)</span><br><span class="line">    fl, _ := tl.File()</span><br><span class="line">    <span class="keyword">return</span> fl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要用上面的无缝重启版的Listener，只需要修改server.Serve</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netListener = newGracefulListener(l)</span><br><span class="line">server.Serve(netListener)</span><br></pre></td></tr></table></figure>
<p>为了避免挂起连接，使用以下方式创建server：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server := &amp;http.Server&#123;</span><br><span class="line">    Addr:           <span class="string">"0.0.0.0:8888"</span>,</span><br><span class="line">    ReadTimeout:    <span class="number">10</span> * time.Second,<span class="comment">//超时设置</span></span><br><span class="line">    WriteTimeout:   <span class="number">10</span> * time.Second,<span class="comment">//超时设置</span></span><br><span class="line">    MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a class="header-anchor" href="#其他"></a>其他</h1>
<h2 id="Q-A"><a class="header-anchor" href="#Q-A"></a>Q&amp;A</h2>
<p>可以在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gl *gracefulListener)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line">gl.Listener.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q:关闭listener吗，这样就不用在newGracefulListener里的goroutine了<br>
A:这样做不管用，没法关闭listener，但是原因还不清楚呢，有朋友知道可以分享下吗？</p>
<h2 id="参考文章："><a class="header-anchor" href="#参考文章："></a>参考文章：</h2>
<p><a href="https://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="noopener">Graceful Restart in Golang</a><br>
<a href="https://colobu.com/2015/10/09/Linux-Signals/" target="_blank" rel="noopener">Linux Signal及Golang中的信号处理</a></p>
]]></content>
    
    <summary type="html">
    
      无需终止原服务，以更优雅的方式无缝切入到新服务
    
    </summary>
    
      <category term="Go" scheme="https://gingjan.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://gingjan.com/tags/Go/"/>
    
      <category term="Hack" scheme="https://gingjan.com/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>Reactive Streams 响应式流处理</title>
    <link href="https://gingjan.com/2020/11/16/reactive-streams/"/>
    <id>https://gingjan.com/2020/11/16/reactive-streams/</id>
    <published>2020-11-16T02:36:32.000Z</published>
    <updated>2023-06-24T11:29:45.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reactive-Streams"><a class="header-anchor" href="#Reactive-Streams"></a>Reactive Streams</h1>
<p>Reactive Streams 是一项倡议，以提供标准的非阻塞异步流处理，包含运行环境（JVM，JavaScript）和网络协议的标准统一</p>
<p>处理数据流特别是体积大小无法预知的「live（实时）」数据流，需要在异步系统里进行特别「关照」，最突出的问题是要知道资源消耗的量和对资源消耗的控制，<br>
防止被大量的数据流入，消耗大量资源压垮系统<br>
为了可以在多机协作网络或单机多核上并行使用计算资源，异步是不可或缺的<br>
reactive streams的主要目标是管理流数据跨异步域传输，（跨异步域传输：可以类比想象成数据跨线程传递，）同时确保流的接收端不需缓冲任何数据，也即，作为<br>
本模型一部分的背压（反压 back pressure）使得线程间的中介——队列 的大小被限制了。<br>
如果背压的通讯是同步的，则异步带来的优点将毫无意义，因此必须注意Reactive Stream所有的具体实现（非阻塞和异步的实现等）</p>
<p>本规范的目的：所有遵守本规范的各实现可以顺利平滑地交互，以在整个流处理应用/系统中保留前面所述的好处和特性</p>
<h2 id="Scope"><a class="header-anchor" href="#Scope"></a>Scope</h2>
<p>Reactive Stream的范畴是找到 实现非阻塞异步数据流的back pressure目标 的 操作/实体 的接口interface，方法Method，协议protocol<br>
端的DSL和绑定API的协议</p>
<h2 id="基本语义"><a class="header-anchor" href="#基本语义"></a>基本语义</h2>
<p>基本语义定义了如何通过背压调节流元素的传输，至于元素如何传输，元素在传输过程中的表现，如何发出背压信号等都不属于本规范的范畴</p>
<h2 id="给实现者的提示"><a class="header-anchor" href="#给实现者的提示"></a>给实现者的提示</h2>
<p>若要实现本规范，建议先阅读<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md" target="_blank" rel="noopener">README</a>和<a href="http://www.reactive-streams.org/reactive-streams-1.0.3-javadoc" target="_blank" rel="noopener">Java API documentation</a><br>
，然后看<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#specification" target="_blank" rel="noopener">Specification</a>、<a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3/tck" target="_blank" rel="noopener">TCK</a>、<br>
<a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3/examples/src/main/java/org/reactivestreams/example/unicast" target="_blank" rel="noopener">example implementations</a>。<br>
如果有任何疑问，可以查阅<a href="https://github.com/reactive-streams/reactive-streams-jvm/issues?page=1&amp;state=closed" target="_blank" rel="noopener">closed issues</a>，若依旧无法解决你的疑问，则<br>
到<a href="https://github.com/reactive-streams/reactive-streams-jvm/issues/new" target="_blank" rel="noopener">new issue</a>提出你的问题</p>
<h3 id="深入阅读："><a class="header-anchor" href="#深入阅读："></a>深入阅读：</h3>
<p><a href="https://lotabout.me/2020/Back-Pressure/" target="_blank" rel="noopener">背压(Back Pressure)与流量控制</a><br>
<a href="http://www.reactive-streams.org/" target="_blank" rel="noopener">本文参考：Reactive Streams</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reactive-Streams&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Reactive-Streams&quot;&gt;&lt;/a&gt;Reactive Streams&lt;/h1&gt;
&lt;p&gt;Reactive Streams 是一项倡议，以提供标准的非阻塞异步流
    
    </summary>
    
      <category term="代码之上" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
    
      <category term="编程思想" scheme="https://gingjan.com/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Go最佳实践：如何选择「指针接收器」、「值接收器」</title>
    <link href="https://gingjan.com/2020/10/10/go-best-practices-pointer-or-value-receivers/"/>
    <id>https://gingjan.com/2020/10/10/go-best-practices-pointer-or-value-receivers/</id>
    <published>2020-10-10T04:16:43.000Z</published>
    <updated>2020-11-16T02:35:35.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="概念定义"><a class="header-anchor" href="#概念定义"></a>概念定义</h2>
<ul>
<li>指针接收器</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Type)</span> <span class="title">Method</span><span class="params">()</span></span> &#123;&#125; <span class="comment">//pointer receiver 指针接收器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>值接收器</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Type)</span> <span class="title">Method</span><span class="params">()</span></span> &#123;&#125; <span class="comment">//value receiver 值接收器</span></span><br></pre></td></tr></table></figure>
<h2 id="何时使用何者"><a class="header-anchor" href="#何时使用何者"></a>何时使用何者</h2>
<p>常在定义struct方法时遇到接收器类型的选择问题</p>
<h3 id="指针接收器"><a class="header-anchor" href="#指针接收器"></a>指针接收器</h3>
<p>需要改动接收器本身时：若需要在方法里修改接收器的状态或字段值时，使用指针接收器。因为值接收器只是本体的一个副本，对其任何的改动都只是作用在副本上</p>
<p>需要性能的优化：如果struct非常多字段，占用内存大，则使用指针接收器，因为值接收器的副本复制成本太大，导致性能低下。</p>
<h3 id="值接收器"><a class="header-anchor" href="#值接收器"></a>值接收器</h3>
<p>需要并发安全：值接收器因为是副本，因此是并发安全的</p>
<p>无需修改接收器本身时</p>
<h3 id="两者兼存时，如何权衡"><a class="header-anchor" href="#两者兼存时，如何权衡"></a>两者兼存时，如何权衡</h3>
<p>你定义的方法可能有指针接收器和值接收器，这时为了统一，选择全部统一改为指针接收器</p>
]]></content>
    
    <summary type="html">
    
      常在定义struct方法时遇到该问题
    
    </summary>
    
      <category term="Go" scheme="https://gingjan.com/categories/Go/"/>
    
      <category term="最佳实践" scheme="https://gingjan.com/categories/Go/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Go" scheme="https://gingjan.com/tags/Go/"/>
    
      <category term="最佳实践" scheme="https://gingjan.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Linux日志查看常用命令</title>
    <link href="https://gingjan.com/2020/09/29/common-command-of-linux-for-log/"/>
    <id>https://gingjan.com/2020/09/29/common-command-of-linux-for-log/</id>
    <published>2020-09-29T11:30:20.000Z</published>
    <updated>2020-10-05T03:54:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集常用的Linux日志查看命令</p>
<a id="more"></a>
<p>读取日志的常用命令有三个<code>cat</code>，<code>tail</code>，<code>head</code></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>-n</td>
<td>[file_name]</td>
<td>读取file_name数据，并附带上行号</td>
</tr>
<tr>
<td>tail</td>
<td>-n</td>
<td>10 [file_name]</td>
<td>从file_name最后一行开始，往上读取10行</td>
</tr>
<tr>
<td>tail</td>
<td>-n</td>
<td>-10 [file_name]</td>
<td>从file_name最后一行开始，往上读取10行</td>
</tr>
<tr>
<td>tail</td>
<td>-n</td>
<td>+10 [file_name]</td>
<td>从file_name第10行开始，往下读取到最后一行</td>
</tr>
<tr>
<td>head</td>
<td>-n</td>
<td>10 [file_name]</td>
<td>从file_name第1行开始读取10行</td>
</tr>
<tr>
<td>head</td>
<td>-n</td>
<td>+10 [file_name]</td>
<td>从file_name第1行开始读取10行</td>
</tr>
<tr>
<td>grep</td>
<td>-10n ‘keyword’</td>
<td>[file_name]</td>
<td>筛选file_name的keyword，并输出该keyword所在行的前后10行的日志(10+1+10=21行)</td>
</tr>
<tr>
<td>grep</td>
<td>-10n --color=always ‘keyword’</td>
<td>[file_name]</td>
<td>同上，对keyword上色标记输出</td>
</tr>
<tr>
<td>sed</td>
<td>-n</td>
<td>‘/2006-01-02 15:04:05/, /2006-01-02 15:04:06/p’ [file_name]</td>
<td>模式匹配，输出在匹配时间段内的日志</td>
</tr>
<tr>
<td>more</td>
<td></td>
<td></td>
<td>分页显示，空格键翻页</td>
</tr>
<tr>
<td>less</td>
<td></td>
<td></td>
<td>分页显示，空格键翻页</td>
</tr>
<tr>
<td>sort</td>
<td>-r</td>
<td></td>
<td>排序，-r：倒序</td>
</tr>
</tbody>
</table>
<p><code>tail</code>和<code>head</code> 结合使用<br>
<code>tail -n +5 [file_name] | head -n 3</code><br>
从第5行读取[file_name]到最后一行得出结果集1，然后再从第一行读结果集1，读到第3行</p>
<p><code>cat</code> + <code>gret</code> 结合使用<br>
<code>cat [file_name] | grep -10n 'keyword'</code><br>
筛选file_name的keyword，并输出该keyword所在行的前后10行的日志</p>
<p><code>grep</code> + <code>sort</code> 结合使用<br>
<code>grep -10n 'keyword' [file_name] | sort -r</code><br>
筛选file_name的keyword，并输出该keyword所在行的前后10行的日志，并以倒序排序</p>
<p><code>grep</code> + <code>sort</code> + <code>more</code> 结合使用<br>
<code>grep -10n 'keyword' [file_name] | sort -r | more</code><br>
筛选file_name的keyword，并输出该keyword所在行的前后10行的日志，并以倒序排序，再分页处理</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集常用的Linux日志查看命令&lt;/p&gt;
    
    </summary>
    
      <category term="命令" scheme="https://gingjan.com/categories/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="日志" scheme="https://gingjan.com/categories/%E5%91%BD%E4%BB%A4/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="命令" scheme="https://gingjan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="https://gingjan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>顺时针螺旋原则</title>
    <link href="https://gingjan.com/2020/05/01/clockwise-rule/"/>
    <id>https://gingjan.com/2020/05/01/clockwise-rule/</id>
    <published>2020-05-01T02:00:00.000Z</published>
    <updated>2020-10-05T07:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h2>
<p>可以根据顺时针螺旋原则，对C的复杂声明进行解读</p>
<p>按照以下三个步骤:</p>
<ol>
<li>从变量名开始,沿着顺时针方向(变量名处向上走),从第一个类型声明符号开始,当遇到下一个类型声明  符号则使用对应的自然语言描述它:<br>
<code>[X]</code> or <code>[]</code><br>
=&gt; [^Array X size of… or Array undefined size of…]<br>
[^Array X size of… or Array undefined size of…]:(数组 大小为 X 的… or 数组 大小为 未知 的…)<br>
<code>(type1, type2)</code><br>
=&gt; <code>function passing type1 and type2 returning... (函数 传入 type1 和 type2 返回...)</code><br>
<code>*</code><br>
=&gt; <code>pointer(s) to... (指针 指向...)</code></li>
<li>继续沿着顺时针方向使用自然语言描述对应声明符号直到所有符号描述成为止</li>
<li>圆括号<code>()</code>内的符号要先描述</li>
</ol>
<h2 id="示例"><a class="header-anchor" href="#示例"></a>示例</h2>
<h3 id="示例1-简单声明"><a class="header-anchor" href="#示例1-简单声明"></a>示例1:简单声明</h3>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> x   +-------+</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> +-+   </span>|</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> ^ </span>|<span class="string">   </span>|</span><br><span class="line">char <span class="symbol">*</span>str[10];</span><br><span class="line"> ^   ^   |<span class="string">   </span>|</span><br><span class="line"> |<span class="string">   +---+   </span>|</span><br><span class="line"> +-----------+</span><br></pre></td></tr></table></figure>
<p>首先看,变量<code>str</code>是什么<br>
<code>str is an... (变量str 是一个 ...)</code></p>
<ul>
<li>从变量名<code>str</code>开始沿着顺时针方向(向上)走,遇到第一个字符是<code>[</code>,即有数组,所以:<br>
<code>str is an array 10 of... (变量str 是一个数组大小为10的..).</code></li>
<li>继续沿着顺时针方向,下一个遇到的字符是<code>*</code>,即有指针,所以:<br>
<code>str is an array 10 of pointers to... (变量str 是一个数组大小为10的指针...)</code></li>
<li>继续沿着顺时针方向,下一个遇到的字符是本行结束符<code>;</code>,so跳过,下一个是<code>char</code>:<br>
<code>str is an array 10 of pointers to char (变量str 是一个数组大小为10的指针指向char类型)</code></li>
<li>现在每个字符都遍历了,因此完结</li>
</ul>
<h3 id="示例2-函数指针的声明"><a class="header-anchor" href="#示例2-函数指针的声明"></a>示例2:函数指针的声明</h3>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> x   +--------------------+</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> +---+              </span>|</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> </span>|<span class="string">+-+</span>|<span class="string">              </span>|</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> </span>|<span class="string">^ </span>||<span class="string">              </span>|</span><br><span class="line">char <span class="symbol">*</span>(<span class="symbol">*</span>fp)( int, float <span class="symbol">*</span>);</span><br><span class="line"> ^   ^ ^  ||<span class="string">              </span>|</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> +--+</span>|<span class="string">              </span>|</span><br><span class="line"> |<span class="string">   +-----+              </span>|</span><br><span class="line"> +------------------------+</span><br></pre></td></tr></table></figure>
<p>首先看,变量<code>fp</code>是什么?<br>
<code>fp is a... (fp是...)</code></p>
<ul>
<li>从fp开始,沿着顺时针方向(向上)遇到的第一个是<code>)</code>;因此<code>fp</code>是在圆括号<code>()</code>内的,所以在圆括号内以顺时针螺旋方式继续,下一个是<code>*</code>:<br>
<code>fp is a pointer to... (fp是一个指针指向...)</code></li>
<li>继续,出了圆括号范围后看到的是<code>(</code>,也即有函数:<br>
<code>fp is a pointer to a function passing an int and a pointer to float returning... (fp是一个指针指向函数,该函数传入int类型和指向float的指针类型)</code></li>
<li>继续,下个是<code>*</code>:<br>
<code>fp is a pointer to a function passing an int and a pointer to float returning a pointer to... (fp是一个指针指向函数,该函数传入int类型和指向float的指针类型并返回一个指针)</code></li>
<li>继续,下个是<code>;</code>,虽然到了行结束符,但还没有遍历完全部声明符号,因此继续并最后遇到<code>char</code>:<br>
<code>fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char ((fp是一个指针指向函数,该函数传入int类型和指向float的指针类型并返回一个指针,该指针指向char类型)</code></li>
</ul>
<h3 id="示例3"><a class="header-anchor" href="#示例3"></a>示例3</h3>
<p><code>void (*signal(int, void (*fp)(int)))(int);</code><br>
根据顺时针螺旋定则,分别以signal和fp为起点,以变量名为起点向上画线,再按照顺时针方向画圆,得出下图(当遇到<code>(</code>时,则跳过<code>(</code>到<code>)</code>之间的内容包括<code>)</code>;遇到<code>)</code>时,则不能跳过<code>(</code>到<code>)</code>之间除了<code>(</code>的内容)</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> x    +-----------------------------+</span><br><span class="line"> |<span class="string">    </span>|<span class="string">             x    +---+      </span>|</span><br><span class="line"> |<span class="string">    </span>|<span class="string">  +---+      </span>|<span class="string">    </span>|<span class="string">+-+</span>|<span class="string">      </span>|</span><br><span class="line"> |<span class="string">    </span>|<span class="string">  ^   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string">^ </span>||<span class="string">      </span>|</span><br><span class="line">void (<span class="symbol">*</span>signal(int, void (<span class="symbol">*</span>fp)(int)))(int);</span><br><span class="line"> ^    ^      |<span class="string">      ^    ^  </span>||<span class="string">      </span>|</span><br><span class="line"> |<span class="string">    +------+      </span>|<span class="string">    +--+</span>|<span class="string">      </span>|</span><br><span class="line"> |<span class="string">                  +--------+      </span>|</span><br><span class="line"> +----------------------------------+</span><br></pre></td></tr></table></figure>
<h4 id="分析"><a class="header-anchor" href="#分析"></a>分析</h4>
<ol start="0">
<li>
<p>先找到全部变量名:signal、fp</p>
</li>
<li>
<p>以fp为圆心画的圆:暂称fp圆;以signal为圆心画的圆:暂称signal圆</p>
</li>
<li>
<p>因为fp圆被包含在signal圆内,所以signal层级比fp高</p>
</li>
<li>
<p>根据顺时针螺旋定则,分别以signal和fp为起点,从12点钟方向开始顺时针转动,得出:<br>
signal圆所在层级,得出:<br>
signal(int,…),[设signalAsWhole=signal(int,…)]<br>
*signalAsWhole,[设signalAWPointer=*signalAsWhole]<br>
void (signalAWPointer)(int) 也即 void signalAWPointer(int)</p>
<p>fp圆所在层级,得出:<br>
fp<br>
*fp,[设fpAsWhole=*fp]<br>
void (fpAsWhole)(int) 也即 void fpAsWhole(int)</p>
</li>
</ol>
<p>从最高层开始分析:</p>
<ol>
<li>void signalAWPointer(int),可知是个函数,该函数传入int,返回void (函数)</li>
<li>signalAWPointer = *signalAsWhole,可知signalAWPointer是个指针 (指针)</li>
<li>signalAsWhole = signal(int,…), 可知是个函数 (函数)</li>
<li>其中「…」是fp圆 = void fpAsWhole(int), 可知是个函数,该函数传入int,返回void</li>
<li>设fpAsWhole = *fp 是个指针</li>
</ol>
<p>所以最后得出:</p>
<ul>
<li>「fp是指针,指向一个函数,该函数传入int返回void」 即 「fp是指向 传入int返回void 的函数指针」</li>
<li>「signal是个函数,该函数传入int,fp 并返回一个指针,该指针指向一个函数,该函数传入int返回void」 即 「signal是个函数,该函数传入int,fp并返回一个指向 传入int返回void的函数指针」</li>
</ul>
<p>同样,该原则可以应用到const常量和volatile:</p>
<h3 id="示例4"><a class="header-anchor" href="#示例4"></a>示例4</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *chptr;</span><br></pre></td></tr></table></figure>
<p>chptr是什么?<br>
chptr是一个指向「char常量」的指针 (chptr is a pointer to a char constant.)</p>
<h3 id="示例5"><a class="header-anchor" href="#示例5"></a>示例5</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure>
<p>chptr是什么?<br>
chptr是一个指向「char」的「常量指针」 (chptr is a constant pointer to char.)</p>
<h3 id="示例6"><a class="header-anchor" href="#示例6"></a>示例6</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure>
<p>chptr是什么?<br>
chptr是一个指向指向「char volatile」的「常量指针」 (chptr is a constant pointer to a char volatile.)</p>
<p>欢迎转载但请附上原文链接，谢谢。</p>
<p>参考:</p>
<p><a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">The Clockwise/Spiral Rule 顺时针螺旋原则</a></p>
<p>搭配食用:</p>
<p><a href="https://blog.go-zh.org/gos-declaration-syntax" target="_blank" rel="noopener">Go’s Declaration Syntax</a></p>
<p>如有错误，欢迎指出、讨论，大家共同进步 <sup>_</sup></p>
]]></content>
    
    <summary type="html">
    
      本文主要讲解何为顺时针螺旋原则
    
    </summary>
    
      <category term="代码之上" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="原则" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="原则" scheme="https://gingjan.com/tags/%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Laravel-自动发现扩展包</title>
    <link href="https://gingjan.com/2019/09/24/laravels-package-auto-discovery/"/>
    <id>https://gingjan.com/2019/09/24/laravels-package-auto-discovery/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解Laravel如果基于Composer实现自动发现扩展包</p>
<a id="more"></a>
<p>Laravel附带了一个composer.json文件,当一些Laravel包被拉取到本地后,还需要几步手动配置使之能在Laravel项目中使用</p>
<ul>
<li>注册 Service Provider</li>
<li>注册 Alias或Facade</li>
<li>发布 asset<br>
第一、二步已被 Taylor Otwell 确认有点繁琐,因此联合 Dries Vints 开发并推出了「自动注册 Service Provider 和 Facade」功能</li>
</ul>
<p>在搜索并安装/更新不同的扩展包时,Composer会触发多个事件,这些事件可供订阅,一旦订阅的事件被触发,可调起一段自定义的代码或一条可执行的命令行.<br>
当Composer生成最终的类加载文件.其中一个名为 post-autoload-dump 的事件将会被触发.而后,Laravel已可访问所有类并且项目可使用这些类了</p>
<p>之所以会这样,是因为Laravel在composer.json文件里订阅了 post-autoload-dump 事件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"post-autoload-dump"</span>: [</span><br><span class="line">        <span class="string">"Illuminate\\Foundation\\ComposerScripts::postAutoloadDump"</span>,</span><br><span class="line">        <span class="string">"@php artisan package:discover"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先,调起postAutoloadDump方法,该方法负责清除之前缓存的services和包.然后运行 package:discover 命令,这是关键所在</p>
<p>找寻扩展包<br>
<code>Illuminate\Foundation\Console\PackageDiscoverCommand</code> 调用 <code>Illuminate\Foundation\PackageManifest</code> 类的 <code>build()</code> 方法. <code>PackageManifest</code> 类里包含 Laravel自动找寻已安装包 的实现<br>
<code>PackageManifest</code> 类在应用启动时就被注册入容器里了(是在 <code>Illuminate\Foundation\Application::registerBaseServiceProviders()</code> 里注册)</p>
<p>在 <code>build()</code> 方法内,Laravel会去寻找 <code>vendor/composer/installed.json</code> 文件(该文件由composer生成),Laravel会映射这个文件的内容并且递归搜索含有 <code>extra.laravel</code> 的包</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"extra"</span>: &#123;</span><br><span class="line">    <span class="string">"laravel"</span>: &#123;</span><br><span class="line">        <span class="string">"providers"</span>: [</span><br><span class="line">            <span class="string">"Barryvdh\\Debugbar\\ServiceProvider"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"aliases"</span>: &#123;</span><br><span class="line">            <span class="string">"Debugbar"</span>: <span class="string">"Barryvdh\\Debugbar\\Facade"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后搜索 <code>composer.json</code> 文件的 <code>extra.laravel.dont-discover</code> 区段来判断是否有指定无需自动发现的包</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"extra"</span>: &#123;</span><br><span class="line">    <span class="string">"laravel"</span>: &#123;</span><br><span class="line">        <span class="string">"dont-discover"</span>: [</span><br><span class="line">            <span class="string">"barryvdh/laravel-debugbar"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以添加 <code>*</code> 到数组区段里来告诉laravel不执行自动发现</p>
<p>至此,laravel已经收集好了有关扩展包的信息.接下来是把这些信息写入到 <code>bootstrap/cache/packages.php</code> 文件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">return</span> <span class="keyword">array</span> (</span><br><span class="line">  <span class="string">'barryvdh/laravel-debugbar'</span> =&gt;</span><br><span class="line">  <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'providers'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">      <span class="number">0</span> =&gt; <span class="string">'Barryvdh\\Debugbar\\ServiceProvider'</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'aliases'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">      <span class="string">'Debugbar'</span> =&gt; <span class="string">'Barryvdh\\Debugbar\\Facade'</span>,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注册扩展包<br>
当Laravel Kernel启动时,会有两个 <code>bootstrapper启动器</code> 会被调用到</p>
<ul>
<li><code>\Illuminate\Foundation\Bootstrap\RegisterFacades</code></li>
<li><code>\Illuminate\Foundation\Bootstrap\RegisterProviders</code></li>
</ul>
<p>第一个使用 <code>Illuminate\Foundation\AliasLoader</code> 将所有 <code>Facade</code> 加载到容器里,现在唯一不同的是laravel会把 <code>packages.php</code> 里需要加载的 <code>aliases</code> 都一并加载到容器.(使用 <code>PackageManifest::aliases()</code> 方法来收集这些信息)</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in RegisterFacades::bootstrap()</span></span><br><span class="line">AliasLoader::getInstance(array_merge(</span><br><span class="line">    $app-&gt;make(<span class="string">'config'</span>)-&gt;get(<span class="string">'app.aliases'</span>, []),</span><br><span class="line">    $app-&gt;make(PackageManifest::class)-&gt;aliases()</span><br><span class="line">))-&gt;register();</span><br></pre></td></tr></table></figure>
<p>如上所示,<code>config/app.php</code> 里配置的 <code>aliases</code> 和 <code>PackageManifest类</code> 的 <code>aliases</code> 合并到一起.</p>
<p>相似地,<code>Service Provider</code> 也是这样注册. <code>RegisterProviders</code> 启动器调用 <code>Foundation\Application::registerConfiguredProviders()</code> 把Laravel从所有扩展包中收集的 <code>Service Provider</code> 注册入容器</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$providers = Collection::make(<span class="keyword">$this</span>-&gt;config[<span class="string">'app.providers'</span>])</span><br><span class="line">                -&gt;partition(<span class="function"><span class="keyword">function</span> <span class="params">($provider)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Str::startsWith($provider, <span class="string">'Illuminate\\'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">$providers-&gt;splice(<span class="number">1</span>, <span class="number">0</span>, [<span class="keyword">$this</span>-&gt;make(PackageManifest::class)-&gt;providers()]);</span><br></pre></td></tr></table></figure>
<p>欢迎转载但请附上链接，谢谢。</p>
<p><a href="https://divinglaravel.com/laravels-package-auto-discovery" target="_blank" rel="noopener">原文：laravels-package-auto-discovery</a></p>
<p>如有什么错误，欢迎提出、讨论，大家共同进步 <sup>_</sup></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解Laravel如果基于Composer实现自动发现扩展包&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Laravel" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Laravel/"/>
    
    
      <category term="框架" scheme="https://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="https://gingjan.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>如何选择AES加密模式(CBC、ECB、CTR、OCB、CFB)</title>
    <link href="https://gingjan.com/2018/08/12/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb/"/>
    <id>https://gingjan.com/2018/08/12/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb/</id>
    <published>2018-08-12T03:39:41.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果加密的数据块超过 1 block则不要选择ECB模式<br>
&lt;Excerpt in index | 首页摘要&gt;</p>
<a id="more"></a>
<p>&lt;The rest of contents | 余下全文&gt;</p>
<p>如果加密的数据块超过 1 block则不要选择ECB模式</p>
<p>CBC, OFB 和 CFB 模式很相似,然而如果你只是要加密而不需要解密,则选择OFB或CFB更合适,因为这两种模式可以节约空间</p>
<p>如果需要更快的加密速度(并行加密),选择CTR 而不是 CBC/OFB/CFB.</p>
<p>如果需要 对随机访问介质内的数据(如磁盘或内存中的数据)进行加密,选择XTS模式更合适</p>
<p>OCB是目前为止最好的模式,因为它可以一次性对数据进行加密和验证,然后在美国该模式是需要专利授权的</p>
<p>ECB 很少使用到除非只是加密1个数据块.如果是加密磁盘或内存的数据而不是stream(stream是一段一段的),XTS应该更适合你</p>
<p>每次加密时都要使用唯一且随机的IV(init vector,初始化向量),如果你无法保证随机性,则使用OCB模式,因为它只需要传入nonce而无需传入IV,IV和nonce这两个有点不同,如果被人猜到下一个nonce是不会导致安全问题,而被人猜到下一个IV则会导致安全问题(因为需要保证IV每次是随机的)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果加密的数据块超过 1 block则不要选择ECB模式&lt;br&gt;
&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="https://gingjan.com/categories/%E5%AE%89%E5%85%A8/"/>
    
      <category term="算法" scheme="https://gingjan.com/categories/%E5%AE%89%E5%85%A8/%E7%AE%97%E6%B3%95/"/>
    
      <category term="加密算法" scheme="https://gingjan.com/categories/%E5%AE%89%E5%85%A8/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="安全" scheme="https://gingjan.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="算法" scheme="https://gingjan.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Composer常用命令</title>
    <link href="https://gingjan.com/2018/08/09/composer-command/"/>
    <id>https://gingjan.com/2018/08/09/composer-command/</id>
    <published>2018-08-09T09:18:33.000Z</published>
    <updated>2020-10-05T09:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解并且亲测了常用的Composer命令</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>composer required</td>
<td></td>
<td>“xxx/xxx:v0.0.1”</td>
<td>更新包，自动判断包存不存在，不存在就安装，存在就更新</td>
</tr>
<tr>
<td>composer dump-autoload</td>
<td></td>
<td></td>
<td>不更新依赖,只更新autoload文件</td>
</tr>
<tr>
<td>composer install</td>
<td></td>
<td></td>
<td>根据composer.lock 更新/安装依赖</td>
</tr>
<tr>
<td>composer update</td>
<td></td>
<td></td>
<td>根据composer.json 更新/安装依赖 并更新composer.lock文件</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      本文持续更新中…
    
    </summary>
    
      <category term="依赖管理" scheme="https://gingjan.com/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/PHP/"/>
    
    
      <category term="依赖管理" scheme="https://gingjan.com/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
      <category term="Composer" scheme="https://gingjan.com/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>各种各样的锁</title>
    <link href="https://gingjan.com/2018/05/21/all-kinds-of-locks-md/"/>
    <id>https://gingjan.com/2018/05/21/all-kinds-of-locks-md/</id>
    <published>2018-05-21T15:40:01.000Z</published>
    <updated>2020-10-05T08:47:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程之间的锁"><a class="header-anchor" href="#线程之间的锁"></a>线程之间的锁</h2>
<p>可基于某个共享变量实现。也可使用下面介绍的<code>互斥锁</code>、<code>自旋锁</code>等实现</p>
<h2 id="进程之间的锁"><a class="header-anchor" href="#进程之间的锁"></a>进程之间的锁</h2>
<p>分同一台机器和不同机器。同一机器则同样可使用下面介绍的锁实现。不同机器则需使用分布式锁实现。</p>
<p><code>进程与锁不在同一台机器上（分布式锁），还需要注意网络传输的时间，因此需要判断传输时间，若传输时间大于锁的有效时间，则该锁无效。</code></p>
<h2 id="互斥锁"><a class="header-anchor" href="#互斥锁"></a>互斥锁</h2>
<p>当任务1无法获取锁时，则会进入睡眠态，当锁被释放后，任务1会被唤醒并尝试获取锁，因从用户态（尝试获取锁）进入内核态（无法获取锁）存在切换，<br>
因此较耗性能，通常在几十纳秒到几微秒之间</p>
<h2 id="自旋锁"><a class="header-anchor" href="#自旋锁"></a>自旋锁</h2>
<p>当任务1无法获取锁时，则会不断进行尝试而不进入睡眠态，因此不会进入内核态从而其性能较<code>互斥锁</code>更好。<br>
一般使用<code>WHILE</code>等循环语句实现<code>忙等待</code>，当然这会导致CPU空转从而浪费电能，可以使用CPU的<code>PAUSE</code>指令实现<code>忙等待</code>从而节约电能</p>
<blockquote>
<p>当任务耗时较短时，使用<code>自旋锁</code>比<code>互斥锁</code>更好，因为<code>互斥锁</code>的状态切换耗时可能多于任务本身的耗时</p>
</blockquote>
<h2 id="读写锁"><a class="header-anchor" href="#读写锁"></a>读写锁</h2>
<h3 id="原理"><a class="header-anchor" href="#原理"></a>原理</h3>
<ul>
<li>当<code>读锁</code>没被任务持有时，多个任务能够同时都获取读锁（并发）</li>
<li>但当<code>写锁</code>被某任务持有后，读任务获取读锁的操作会被阻塞，且其他写任务获取写锁的操作也会被阻塞。</li>
</ul>
<p>所以，<code>写锁</code>是排斥锁（X锁），而<code>读锁</code>则是共享锁（S锁）</p>
<p>当然，根据需要，还会分<code>读优先锁</code>和<code>写优先锁</code></p>
<h3 id="读优先锁"><a class="header-anchor" href="#读优先锁"></a>读优先锁</h3>
<p>任务1对资源上读锁，此时任务2需上写锁但无法获取，后续任务3需上读锁，此时任务3可获取读锁，待任务1、任务3、其他拥有读锁的任务都释放读锁后，任务2才能获取写锁。<br>
此为读优先锁，该锁有问题就是会造成<code>写饥饿</code>，即一切有任务获取读锁，导致写任务无法获取写锁，从而导致无法执行写操作。</p>
<h3 id="写优先锁"><a class="header-anchor" href="#写优先锁"></a>写优先锁</h3>
<p>任务1对资源上读锁，此时任务2需写锁但无法获取则阻塞等待，后续任务3需上读锁，但同样也无法获取读锁从而阻塞等待。<br>
待任务1释放读锁后，唤醒任务2使其获取写锁，若后续有任务4获取写锁，则当任务2释放写锁时，任务3仍未能获取读锁，而是唤醒任务4获取写锁。<br>
因此也会导致<code>饥饿</code>的现象<code>读饥饿</code></p>
<ul>
<li>既然都有<code>饥饿</code>现象，那么就来个公平锁，谁都不偏袒</li>
</ul>
<h3 id="公平锁"><a class="header-anchor" href="#公平锁"></a>公平锁</h3>
<p>无论读锁还是写锁，一律按照先来后到，排队等待锁，连续几个读锁请求则可一起共同获取读锁，但是在写锁请求后的读锁请求，则排队等待写锁释放后，才能获取读锁。<br>
这样既可以避免<code>饥饿</code>现象，也可以实现读的并发访问</p>
<blockquote>
<p><code>互斥锁</code>和<code>自旋锁</code>都是最基本的锁，<code>读写锁</code>可以根据场景来选择这两种锁其中的一个进行实现。</p>
</blockquote>
<h2 id="悲观锁"><a class="header-anchor" href="#悲观锁"></a>悲观锁</h2>
<p>悲观锁是指获取或使用一切资源前都认为该资源竞争激烈，需先对资源上锁再使用资源。如上所述的<code>互斥锁</code>、<code>自旋锁</code>和一切其他的<code>锁</code>都属于<code>悲观锁</code>的范畴，所以<code>悲观锁</code>其并发较差。</p>
<h2 id="乐观锁"><a class="header-anchor" href="#乐观锁"></a>乐观锁</h2>
<p>相对的，乐观锁就是认为资源竞争并不激烈，因此总是在最后一步才上锁。比如数据更新时使用的<code>版本号</code>手段。相对的，乐观锁并发较好</p>
<blockquote>
<p>竞争程度不激烈，资源被访问频率不高，则可以使用乐观锁</p>
</blockquote>
<h2 id="分布式锁"><a class="header-anchor" href="#分布式锁"></a>分布式锁</h2>
<p>锁与任务不在同一机器上，通常锁在另外单独的一台机器上，同多台机器上的多个不同进程访问。<br>
根据严格程度又分为多种不同的实现方式。</p>
<h2 id="一些锁的具体实现方法"><a class="header-anchor" href="#一些锁的具体实现方法"></a>一些锁的具体实现方法</h2>
<h3 id="使用Redis在内存存放一个标识以实现锁（分布式锁）"><a class="header-anchor" href="#使用Redis在内存存放一个标识以实现锁（分布式锁）"></a>使用Redis在内存存放一个标识以实现锁（分布式锁）</h3>
<p>使用Redis的string实现：</p>
<h4 id="加锁"><a class="header-anchor" href="#加锁"></a>加锁</h4>
<ol>
<li>进程生成唯一值作为当前进程的ID（下述用进程ID指代）</li>
<li>以锁名为key，进程ID为值存入string</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> lock1 [proc_id] NX EX <span class="number">30</span> //当lock1不存在时，设置lock1为<span class="keyword">key</span>，proc_id为<span class="keyword">value</span>的<span class="keyword">string</span>，且有效时间为<span class="number">30</span>s</span><br></pre></td></tr></table></figure>
<h4 id="解锁"><a class="header-anchor" href="#解锁"></a>解锁</h4>
<ol>
<li>涉及两步，第一步判断解锁进程是否是加锁进程，可通过进程ID识别</li>
<li>删除指定锁名的key<br>
因为涉及两个操作，可在进程内的代码层面进行判断+删除，也可以使用Redis提供的可执行LUA脚本处理</li>
</ol>
<h3 id="可基于MySQL乐观锁实现（分布式锁）"><a class="header-anchor" href="#可基于MySQL乐观锁实现（分布式锁）"></a>可基于MySQL乐观锁实现（分布式锁）</h3>
<p>可参考MySQL乐观锁的实现方式，这里不累述</p>
<h3 id="可重入锁"><a class="header-anchor" href="#可重入锁"></a>可重入锁</h3>
<p>若此时，加锁进程需要再次进入锁，则需引入可重入锁<br>
1.使用Redis的Hash替换String，将锁名作为key，进程ID作为field，第一次上次默认value为1，后面每加一次锁则value自增加1，如</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">lock1:</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"123123-random-id"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次加锁</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">lock1:</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"123123-random-id"</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解锁要执行相应次数，当value为0时，则删除该key完成解锁操作。</p>
<h3 id="联锁"><a class="header-anchor" href="#联锁"></a>联锁</h3>
<p>在多个不同的redis实例上获取到锁，把这些锁看作一个锁称为「联锁」。当全部redis实例的锁都获取到后才认为本次联锁成功获取。<br>
要获取多个redis实例上的锁目的是实现分布式锁的高可用，防止一个redis实例挂掉后，在其获取的锁被认为释放了。（当然你可能会认为可采用主从结构避免，但是也会存在slave来不及同步master时，master就挂了，此时slave当上master后，其他尝试获取锁的进程就会获得锁，导致两个进程对同一资源进行操作）<br>
在获取多个锁的过程，要注意设置最大时间，以防止最后一个锁还没获取到时，第一个获取的锁就已失效。<br>
有一个锁实例获取锁失败，则已获取锁的实例全部都要释放锁，重新进行获取操作，同理超时也是。</p>
<h3 id="RedLock锁"><a class="header-anchor" href="#RedLock锁"></a>RedLock锁</h3>
<p>基于redlock算法实现分布式高可用锁。与联锁类似，但是无需全部redis实例都获取到锁才算成功，只需要获到的锁的redis实例数量为redis锁实例总数的一半加一个即成功，即n/2+1。</p>
]]></content>
    
    <summary type="html">
    
      资源竞争机制里不可或缺的组件————锁
    
    </summary>
    
      <category term="机制" scheme="https://gingjan.com/categories/%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="锁" scheme="https://gingjan.com/tags/%E9%94%81/"/>
    
      <category term="机制" scheme="https://gingjan.com/tags/%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>持续集成、持续交付、持续部署</title>
    <link href="https://gingjan.com/2018/02/01/continuous-integration-and-delivery-and-deployment-md/"/>
    <id>https://gingjan.com/2018/02/01/continuous-integration-and-delivery-and-deployment-md/</id>
    <published>2018-02-01T12:02:01.000Z</published>
    <updated>2020-07-16T11:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2>
<p>现在企业的一般开发流程，从开发人员电脑开发，到发布上测试环境进行单元和集成测试，再发布到预发布环境进行「彩排」，最后才根据需要发布到生产环境上（当然还有些复杂流程就是会分A/B生产环境）。<br>
大致可抽出：开发环境-&gt;[单元测试]-&gt;[合并代码]-&gt;测试环境-&gt;[集成测试]-&gt;预发布环境-&gt;[功能测试]-&gt;生产环境<br>
那么「三个持续」分别负责哪一阶段或层面的工作呢？</p>
<ul>
<li>持续集成（Continuous Integration 即 CI）：这里很好理解，就是负责开发环境到测试环境上的工作，属于技术层面的概念。</li>
<li>持续部署（Continuous Deployment）：业务层面的概念，负责从<code>测试环境</code>到<code>预发布环境</code>到<code>生产环境</code>的代码自动化构建、测试、部署和发布。</li>
<li>持续交付（Continuous Delivery 即 CD）：实际上，持续交付和持续部署很容易混淆，持续交付多指业务层面上（与技术无关）的工作，它属于业务层面的概念。也即要是代码无论任何时候，都持续处于一个可交付给客户（可发布上线对外提供服务）的状态。</li>
</ul>
<h2 id="持续集成"><a class="header-anchor" href="#持续集成"></a>持续集成</h2>
<h3 id="通过一个故事来讲述CI的作用"><a class="header-anchor" href="#通过一个故事来讲述CI的作用"></a>通过一个故事来讲述CI的作用</h3>
<p>在某公司上班的A、B、C、D、E，正在编写一个超级大的应用，ABC是开发人员，D是测试人员，E是项目经理。<br>
在传统的开发方式下，ABC在各自机器上开自己的功能分支，并在此分支上进行开发。期间所有编码和自测工作都仅限于在自己机器上进行。在合并集成到主分支前，他们甚至会在各自分支上或机器上开发几周或几个月的时间。<br>
在某个时间点，项目经理E说要准备发布了，快合并到测试环境的主分支上。<br>
此时，开发人员A、B、C都急急忙忙地把各自分支合并到测试机的主分支上，但因为这三个不同的分支在合并前没一起测试过，而且A、B、C各自的开发环境与测试环境有差异，导致很多bug和问题在合并测试时接踵而至。<br>
合并到测试环境主分支后，测试员D准备进行自动和手动测试，他测出的Bug和问题数量将决定是否能按时发布。经过曲折且长时间的测试后，最终测试通过，项目经理E准备发布项目到生产环境。</p>
<p><img src="/img/CI-CD/ABCDE-story.png" alt="传统的开发模式"></p>
<h3 id="在这个过程中，大家的心路历程是如何的呢？"><a class="header-anchor" href="#在这个过程中，大家的心路历程是如何的呢？"></a>在这个过程中，大家的心路历程是如何的呢？</h3>
<ul>
<li>ABC作为开发人员，会非常难受，因为在合并时会出现各种各样问题，如代码冲突，依赖冲突等。</li>
<li>测试员D也难受，因为在ABC的开发期间，他只能干等着，但是在测试阶段，他又忙到爆炸，而且此时才能编写各种异常场景的测试用例。</li>
<li>项目经理E也是，合并集成阶段是整个项目里最大的不可控点，无法合理预估和规划接下来各阶段的时间，任何异常情况都会把发布推迟。</li>
</ul>
<p>以上主要问题都是因为<code>集成阶段</code>的不稳定和不可控导致，且每次发布前，都会有这个情况出现且越来越不受控制，维护的边际成本逐渐递增。</p>
<h3 id="引入持续集成"><a class="header-anchor" href="#引入持续集成"></a>引入持续集成</h3>
<p>从持续集成这四个字可知道，本质上就是不断重复且频繁的合并代码，集成各功能模块。<br>
怎么个<code>持续</code>集成法呢？<br>
不要一次性的<code>大合并大集成</code>，取而代之的是每当完成一个需求的功能块就马上进行合并集成，无需等待本排期内的其他需求，不用等到发布前的一次性<code>大合并</code>才进行。<br>
<code>注意：每个需求的功能模块代码在合并到主分支前，都要跑一次自动测试。</code><br>
<img src="/img/CI-CD/CI-1.png" alt="引入持续集成-工作流"><br>
<img src="/img/CI-CD/CI-2.png" alt="引入持续集成-结构"></p>
<h3 id="持续集成的要求"><a class="header-anchor" href="#持续集成的要求"></a>持续集成的要求</h3>
<ul>
<li>每个需求/功能开发完毕即刻合并到主分支（在合并前，功能分支要先做好单元测试，然后再合并到主分支并开始主分支的集成测试）。</li>
<li>当主分支合并了功能分支后且通过测试，该功能即完成。</li>
<li>在功能分支和主分支上，都要有自动测试。</li>
<li>开发人员需要持续、经常性拉取主分支的代码并合并到自己的功能分支上，以保证代码同步，防止出现过多冲突。</li>
</ul>
<h3 id="优点"><a class="header-anchor" href="#优点"></a>优点</h3>
<ul>
<li>防止各开发人员各自为政，导致<code>大合并</code>时出现各种环境问题、代码冲突，减少发布前的不可控情况。</li>
<li>将一次性的大测试拆分为多个小测试逐步进行。</li>
</ul>
<h3 id="升华"><a class="header-anchor" href="#升华"></a>升华</h3>
<p>持续集成的目的是让正在开发的软件始终处于可工作状态。同时强调，代码的提交是一种沟通方式，而既然是沟通就需要频繁，下图中代码的提交过程，事实上就是各条分支之间的对话过程。<br>
<img src="/img/CI-CD/branches-communication.jpg" alt="分支间的交流"></p>
<h2 id="持续部署"><a class="header-anchor" href="#持续部署"></a>持续部署</h2>
<p>在持续集成的基础上，将集成后的代码部署到更接近生产环境的<code>预发布环境</code>中。比如，完成单元测试后，可以把代码部署到连接着数据库的<code>Staging</code>环境中，进行更进一步的测试，此时会出现以下几种情况：</p>
<ul>
<li>测试环境与预发布环境不同，可能预发布环境需要额外配置参数。</li>
<li>在测试环境上可正常运行，在预发布环境上无法运行。</li>
<li>后面的部署预发布环境、生产环境都需要手动操作。</li>
</ul>
<h3 id="引入持续部署"><a class="header-anchor" href="#引入持续部署"></a>引入持续部署</h3>
<p>每个开发完毕的新功能在通过测试后自动部署到预发布环境staging，并最终自动部署到生产环境。<br>
<img src="/img/CI-CD/CDeployment.jpg" alt="引入持续集成-结构"></p>
<h2 id="持续交付"><a class="header-anchor" href="#持续交付"></a>持续交付</h2>
<p>持续交付需要与持续集成和持续部署（或叫持续发布）搭配，持续交付基于后两者的基础上，才能实现。就如持续部署实现自动化部署到预发布环境后，业务人员（如产品或运营等）根据需要，决定发布哪些新功能，才将此功能<code>一键</code>发布，部署到生产环境中。持续交付体验在业务人员可在任何时候根据需要来发布业务功能，而不受新功能代码的引入，导致系统不稳定，无法发布上线的影响。</p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>从两个字持续可知三者都是可频繁、重复、稳定的操作。<br>
持续集成是一切的基础，而基于此上的持续部署，贯穿整个过程。基于前两者，再上层的建筑就是持续交付。<br>
持续集成，持续部署都是技术层面上，有了技术层面上的保证，业务层面上的持续交付成为可能。<br>
技术服务于业务，而业务又依赖技术。</p>
]]></content>
    
    <summary type="html">
    
      本文简单介绍三者的来源和区别
    
    </summary>
    
      <category term="架构思想" scheme="https://gingjan.com/categories/%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="架构" scheme="https://gingjan.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="方法论" scheme="https://gingjan.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何在mac上解压分离的压缩文件</title>
    <link href="https://gingjan.com/2017/02/12/how-to-unzip-a-split-archive-on-mac-osx/"/>
    <id>https://gingjan.com/2017/02/12/how-to-unzip-a-split-archive-on-mac-osx/</id>
    <published>2017-02-12T14:04:40.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章向各位展示如何解压分离的压缩文件</p>
<a id="more"></a>
<p>首先，目前据我所知，有两种不同类型的分离压缩文件</p>
<h3 id="一、xxx-zip-001、xxx-zip-002、xxx-zip003类型"><a class="header-anchor" href="#一、xxx-zip-001、xxx-zip-002、xxx-zip003类型"></a>一、xxx.zip.001、xxx.zip.002、xxx.zip003类型</h3>
<h4 id="解决方案："><a class="header-anchor" href="#解决方案："></a>解决方案：</h4>
<p>在终端中输入：</p>
<p><code>for i in </code>seq  1 5<code>; do cat xxx.zip.00$i &gt;&gt; single.zip; done</code> #实则为一个循环语句</p>
<p><code>unzip single.zip</code></p>
<p>解压成功。</p>
<p>其实上面那句循环相当于：</p>
<p><code>cat xxx.zip.001 &gt; single.zip</code> #把数据重定向到single.zip</p>
<p><code>cat xxx.zip.002 &gt;&gt; single.zip</code> #把数据以追加方式重定向到single.zip</p>
<p><code>cat xxx.zip.003 &gt;&gt; single.zip</code></p>
<p><code>cat xxx.zip.004 &gt;&gt; single.zip</code></p>
<p><code>cat xxx.zip.005 &gt;&gt; single.zip</code></p>
<p>或者可以：<code>cat xxx.zip.00* &gt;&gt; already_exist_single.zip</code></p>
<h3 id="二、xxx-z01、xxx-z02、xxx-z03、xxx-zip类型"><a class="header-anchor" href="#二、xxx-z01、xxx-z02、xxx-z03、xxx-zip类型"></a>二、xxx.z01、xxx.z02、xxx.z03、xxx.zip类型</h3>
<h4 id="解决方案"><a class="header-anchor" href="#解决方案"></a>解决方案</h4>
<p><code>zip -s 0 xxx.zip —out unsplit.zip</code> #把分开的文件合并成一个文件</p>
<p><code>-s</code> 代表把压缩的文件分为几部分压缩，<code>0</code> 代表不分割，具体数字如 <code>100m</code> 则代表分为每份大小100m。</p>
<p>以上，如有错误，请指正，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章向各位展示如何解压分离的压缩文件&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mac" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mac/"/>
    
    
      <category term="Mac" scheme="https://gingjan.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Linux-让耗时任务在后台运行</title>
    <link href="https://gingjan.com/2016/09/01/Linux-run-in-background/"/>
    <id>https://gingjan.com/2016/09/01/Linux-run-in-background/</id>
    <published>2016-09-01T04:10:41.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>让终端的任务/耗时任务在后台运行</strong>：我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？</p>
<a id="more"></a>
<p>涉及命令<br>
<code>ps -ef</code> 查看进程<br>
<code>pstree</code> 查看进程树<br>
<code>jobs</code> 查看当前终端的任务列表<br>
<code>commands &amp;</code>，命令后加<code>&amp;</code>代表将该命令放置后台运行<br>
<code>nohup commands &amp;</code><br>
<code>setsid commands</code><br>
<code>(commands &amp;)</code> 效果同上面setsid<br>
<code>ctrl+z</code> (暂停/挂起当前 作业，在使用编辑器时特别有用，退出编辑器时，保存了光标所在的当前位置，下次进入编辑器时不用再次寻找上次光标所处位置)<br>
<code>bg %work_num如bg %1</code>（把作业从挂起转为继续运行）<br>
<code>disown -h %1work_num</code>使某个作业忽略HUP信号<br>
<code>disown -ah</code> 所有作业忽略HUP信号<br>
<code>disown -rh</code> 使正在运行的作业忽略HUP信号<br>
<code>screen -dmS session_name</code> 建立一个断开模式的会话<br>
<code>screen -list</code> 列出所有会话<br>
<code>screen -r session_name</code> 重新连接指定会话</p>
<p>我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？</p>
<h2 id="一、逐个添加"><a class="header-anchor" href="#一、逐个添加"></a>一、逐个添加</h2>
<p>1.通过忽略hangup信号（此信号在终端关闭或者网络断开时就会发出），该种方式可通过jobs命令来查看作业列表<br>
<code>nohup ping www.google.com &amp;</code><br>
查看进程<br>
<code>ps -ef | grep www.google.com</code></p>
<p>2.通过把任务移为其他进程（非终端进程）的子进程来运行，这样就不会受到终端的HUP信号影响了，该种方式通过jobs命令是无法查看作业列表<br>
<code>setsid ping www.google.com</code></p>
<p>3.把任务放置到子shell(subshell)下运行，这样就不会受到终端的HUP信号影响了，该种方式通过jobs命令是无法查看作业列表，因为任务已经不属于该终端的作业了<br>
<code>(ping www.google.com &amp;)</code></p>
<hr>
<h2 id="二、补救"><a class="header-anchor" href="#二、补救"></a>二、补救</h2>
<p>如果我们执行了一个耗时任务，想在该耗时任务运行期间让它到后台运行，这时添加nohup或setsid已经迟了，怎么做？</p>
<h3 id="disown"><a class="header-anchor" href="#disown"></a>disown</h3>
<p><code>disown -h %1</code></p>
<hr>
<h2 id="三、一步完成"><a class="header-anchor" href="#三、一步完成"></a>三、一步完成</h2>
<p>当有很多耗时任务，而我们又不想一个一个去加nohup ,setsid时，怎么办？</p>
<h3 id="screen"><a class="header-anchor" href="#screen"></a>screen</h3>
<p><code>screen -dmS session_name</code></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">参考：https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;让终端的任务/耗时任务在后台运行&lt;/strong&gt;：我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
      <category term="常用命令" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="命令" scheme="https://gingjan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="https://gingjan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>查看一次SQL的执行时间与相关参数</title>
    <link href="https://gingjan.com/2016/07/03/mysql-sql-execution-check-out/"/>
    <id>https://gingjan.com/2016/07/03/mysql-sql-execution-check-out/</id>
    <published>2016-07-03T09:02:47.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>** mysql之sql执行过程窥探 **：本文讲解如何窥探sql执行过程的相关参数</p>
<a id="more"></a>
<p>1.首先查看当前session（会话）的profiling是否打开<br>
<code>select @@profiling</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql1.png" alt="profiling=0，未打开"><br>
若为0，则未打开，</p>
<p>2.打开profiling<br>
<code>set profiling=1</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql2.png" alt="set profiling=1，开启profiling"></p>
<p>3.执行一些sql<br>
<img src="/img/mysql-sql-execution-check-out/mysql3.png" alt="执行sql"></p>
<p>4.查看所有已执行的sql的profile<br>
<code>show profiles</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql4.png" alt="profiles"></p>
<p>5.看看刚才某条sql执行的具体时间拆分，2是个某次查询的id<br>
<code>show profile for query id</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql5.png" alt="profile for query 2"></p>
<p>6.看看刚才某条sql执行的具体时间拆分，并加上相应的cpu信息 (cpu也可以换成all，以查看更多系统指标)<br>
<code>show profile cpu for query id</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql6.png" alt="profile cpu for query 2"></p>
<p>整理自：<a href="http://itindex.net/detail/51526-mysql-sql-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">http://itindex.net/detail/51526-mysql-sql-执行时间</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** mysql之sql执行过程窥探 **：本文讲解如何窥探sql执行过程的相关参数&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="https://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
    
      <category term="MySQL" scheme="https://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/MySQL/"/>
    
    
      <category term="数据库" scheme="https://gingjan.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://gingjan.com/tags/MySQL/"/>
    
      <category term="SQL" scheme="https://gingjan.com/tags/SQL/"/>
    
      <category term="性能优化" scheme="https://gingjan.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>REST API 响应状态码</title>
    <link href="https://gingjan.com/2016/06/21/rest-status-code-setting/"/>
    <id>https://gingjan.com/2016/06/21/rest-status-code-setting/</id>
    <published>2016-06-21T11:18:08.000Z</published>
    <updated>2020-10-05T09:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了设计REST API时，返回的响应应该设置什么样的状态码</p>
<a id="more"></a>
<h2 id="响应状态码"><a class="header-anchor" href="#响应状态码"></a>响应状态码</h2>
<p>在涉及REST风格的API时，使用适当和Http响应状态码是很重要的，这样可以提高API消费者（客户端）对API响应信息的理解</p>
<h3 id="状态码分为5大类"><a class="header-anchor" href="#状态码分为5大类"></a>状态码分为5大类</h3>
<ul>
<li>1xx：临时响应</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：请求错误</li>
<li>5xx：服务器错误</li>
</ul>
<h3 id="每类的详细"><a class="header-anchor" href="#每类的详细"></a>每类的详细</h3>
<p>状态码 | HTTP方法 | 响应体内容 | 含义 | Status text<br>
:---------------: | :--------------: | :--------------: | :--------------:<br>
1xx | | | |<br>
2xx | | | |<br>
200 | GET,PUT | 资源 | 操作成功 | OK<br>
201 | POST | 资源,元数据 | 资源创建成功 | Created<br>
202 | POST,PUT,DELETE,PATCH | N/A | 请求已被接受 | Accepted<br>
204 | DELETE,PUT,PATCH | N/A | 操作已经执行成功，但是响应体没有数据返回。多用于多次修改同一个资源时填写表单的情况下 | No Content<br>
205 | POST | N/A | 操作已经执行成功，但是响应体没有数据返回。多用于创建资源时填写表单的情况下。请看下面解释与204的区别 |<br>
3xx | | | |<br>
301	| GET | uri链接 | 资源已被移除（永久重定向） | Moved permamently<br>
302 | GET | uri链接 | 重定向（临时重定向），http/1.0 的产物 | Found<br>
303 | GET | uri链接 | 重定向（临时重定向），同302，http/1.1的产物，浏览器会根据返回的uri，自动请求该uri | See Other<br>
304	| GET | N/A | 资源没有被修改，使用时header必须带上If-Modified_Since或者If-None-Match | Not Modified<br>
307 | GET | uri链接 | 重定向（临时重定向），同302，http/1.1的产物，浏览器会根据返回的uri，自动请求该uri | Temporary Redirect<br>
4xx | | | |<br>
400 | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 参数列表错误(缺少，格式不匹配)<br>
401 | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 未授权<br>
403	| GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 访问受限，授权过期<br>
404	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 资源，服务未找到<br>
405	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 不允许的http方法<br>
409	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 资源冲突，或者资源被锁定<br>
415	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 不支持的数据(媒体)类型<br>
429	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 请求过多被限制<br>
5xx | | | |<br>
500	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 服务器内部错误/应用系统内部错误<br>
501 | GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 接口未实现</p>
<blockquote>
<p>附加说明：N/A 代表不适用</p>
</blockquote>
<hr>
<h2 id="接口文档"><a class="header-anchor" href="#接口文档"></a>接口文档</h2>
<ul>
<li>简单说明</li>
<li>访问地址</li>
<li>请求方式</li>
<li>返回结果</li>
<li>返回结果的字段说明</li>
<li>错误代码</li>
<li>更新记录</li>
</ul>
<hr>
<h2 id="状态码的详解"><a class="header-anchor" href="#状态码的详解"></a>状态码的详解</h2>
<h3 id="HTTP响应状态码主要分为这几种大类："><a class="header-anchor" href="#HTTP响应状态码主要分为这几种大类："></a>HTTP响应状态码主要分为这几种大类：</h3>
<ul>
<li>1xx：临时响应</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：请求错误</li>
<li>5xx：服务器错误</li>
</ul>
<h3 id="204"><a class="header-anchor" href="#204"></a>204</h3>
<p>请求执行成功，但是响应体没有数据返回，浏览器不用刷新页面也不用跳转页面，所以如果是表单页面，那么表单里填写的数据将不会被清除。另外一点，即使是<a>标签，如果a标签里的链接返回的是204，那么页面也是不会发生跳转。同时返回204也是代表客户端和服务器端的状态（指该资源状态）已经同步</p>
<h3 id="205-（204与205区别）"><a class="header-anchor" href="#205-（204与205区别）"></a>205 （204与205区别）</h3>
<p>请求执行成功，但是响应体没有数据返回，浏览器清空表单数据，方便用户再次填写新数据。</p>
<h3 id="304（304与204区别）"><a class="header-anchor" href="#304（304与204区别）"></a>304（304与204区别）</h3>
<p>注意与204的区别，204情况下是返回空文档，并且该文档会替换上次缓存的文件，因此会有文档/文件没有加载的情况（如没有加载jQuery文件因此提示无$函数等）。而304是使用上次缓存</p>
<hr>
<h2 id="其他需要注意的地方"><a class="header-anchor" href="#其他需要注意的地方"></a>其他需要注意的地方</h2>
<p>这里谈谈REST其他需要注意的地方，注意，以下内容不是标准。</p>
<h3 id="PUT与PATCH区别"><a class="header-anchor" href="#PUT与PATCH区别"></a>PUT与PATCH区别</h3>
<p>我们都知道，更新操作可以通过PUT与PATCH方式提交请求，但是问题来了，PUT和PATCH有什么区别呢？<br>
PUT，正如其词，就是把一大堆数据PUT到服务端，使用PUT更新资源时，需要把资源的所有属性都要提交到服务端。<br>
PATCH，补丁，碎片，可以知道，使用PATCH更新资源时，只需要把资源的部分属性/信息提交到服务端即可。</p>
<h3 id="关于URI设计"><a class="header-anchor" href="#关于URI设计"></a>关于URI设计</h3>
<ul>
<li>从属关系使用嵌套形式，即articles/1/comments，articles/1/comments/2</li>
<li>筛选使用查询键值对的形式，即?key=value，articles?title=first_api</li>
</ul>
<h2 id="关于各种框架对REST的支持与实现"><a class="header-anchor" href="#关于各种框架对REST的支持与实现"></a>关于各种框架对REST的支持与实现</h2>
<p>本节内容打算放到另一篇文章讲<br>
未完待续…</p>
<p><a href="http://www.cnblogs.com/cathsfz/archive/2012/06/19/2553431.html" target="_blank" rel="noopener">整理自</a><br>
<a href="http://www.bkjia.com/headlines/491296.html" target="_blank" rel="noopener">整理自</a><br>
<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">整理自</a><br>
<a href="http://www.cnblogs.com/cathsfz/archive/2012/06/19/2553431.html" target="_blank" rel="noopener">整理自</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了设计REST API时，返回的响应应该设置什么样的状态码&lt;/p&gt;
    
    </summary>
    
      <category term="代码之上" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="API接口设计" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="REST" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/REST/"/>
    
    
      <category term="REST" scheme="https://gingjan.com/tags/REST/"/>
    
      <category term="API接口" scheme="https://gingjan.com/tags/API%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Yii的redirect()方法无法终止执行代码</title>
    <link href="https://gingjan.com/2016/06/16/yii-redirect-cannot-stop-execution/"/>
    <id>https://gingjan.com/2016/06/16/yii-redirect-cannot-stop-execution/</id>
    <published>2016-06-16T02:55:54.000Z</published>
    <updated>2020-10-05T09:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>** 坑爹的redirect() **：在controller里的redirect方法在跳转后，无法终止后续代码的执行。特别在init方法中更棘手。</p>
<a id="more"></a>
<h3 id="遇到的情况-问题"><a class="header-anchor" href="#遇到的情况-问题"></a>遇到的情况/问题</h3>
<p>在写权限控制的时候，在BaseController里的init方法设置了权限检测，如果权限不足则跳转并且终止执行后续代码，可是问题来了，使用了redirect()方法后，确实是跳转了，但是后续操作依然可以执行，显然没有做到控制权限的效果。</p>
<h3 id="问题分析"><a class="header-anchor" href="#问题分析"></a>问题分析</h3>
<p>查看redirect源码后，发现redirect()方法只是做了一些头的设置和跳转，并不会终止后续代码的执行，通过在init方法里加<code>return</code> 、<code>return false</code>、 <code>return true</code>等方法后，依然无效。难道要用<code>header('Location: ' . $redirect_url);exit;</code>来解决问题？测试后，使用该方法确实可以解决问题，但是这样写会不会有点恶心啊，于是乎发现Yii有提供<code>Yii:$app-&gt;response-&gt;send();</code>和<code>Yii:$app-&gt;end();</code>可以做到同样效果，最后就在init里使用了<code>Yii::$app-&gt;end();</code>来解决了这个问题。</p>
<h3 id="再次遇到问题"><a class="header-anchor" href="#再次遇到问题"></a>再次遇到问题</h3>
<p>经过检验，在普通的actionName()方法里，可以使用return 来终止后续代码的执行，但是在init里却不管用，什么情况？<strong>有待研究</strong>(因为init()只是执行了并没有return？)</p>
<h3 id="解决方案"><a class="header-anchor" href="#解决方案"></a>解决方案</h3>
<ul>
<li>在普通的actionName方法里，可以使用<code>return</code>、<code>Yii:$app-&gt;response-&gt;send();</code>、<code>Yii:$app-&gt;end();</code>来解决问题，建议使用<code>return</code>更简洁</li>
<li>在init方法里，只能使用<code>Yii:$app-&gt;response-&gt;send();</code>和<code>Yii:$app-&gt;end();</code>来解决问题了。</li>
</ul>
<p>如有什么错误，欢迎指定和讨论</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 坑爹的redirect() **：在controller里的redirect方法在跳转后，无法终止后续代码的执行。特别在init方法中更棘手。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Yii" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Yii/"/>
    
    
      <category term="框架" scheme="https://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Yii" scheme="https://gingjan.com/tags/Yii/"/>
    
  </entry>
  
  <entry>
    <title>在Yii中如何处理级联删除</title>
    <link href="https://gingjan.com/2016/06/13/cascade-delete-in-yii/"/>
    <id>https://gingjan.com/2016/06/13/cascade-delete-in-yii/</id>
    <published>2016-06-13T03:39:41.000Z</published>
    <updated>2020-10-05T09:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Yii框架在代码层进行级联删除</p>
<a id="more"></a>
<p>数据库表里使用了外键并且使用了Restrict模式，导致删除一张表的记录时，因为外键和其他表关联起来了，导致无法删除，需要把关联表的记录同时也删除了才可以操作目标表记录的删除操作。</p>
<p>第一步：重写beforeDelete()<br>
在Model里，重写beforeDelete()，然后在该方法的最后一行<code>return parent::beforeDelete();</code>即可<br>
当然与beforeDelete方法对应的afterDelete方法也能做其他事情。<br>
充分发挥before和after的作用吧</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $id = <span class="keyword">$this</span>-&gt;id;;</span><br><span class="line">        A::deleteAll([<span class="string">'id'</span>=&gt;$id]);<span class="comment">//级联删除</span></span><br><span class="line">        B::deleteAll([<span class="string">'id'</span>=&gt;$id]);</span><br><span class="line">        C::deleteAll([<span class="string">'id'</span>=&gt;$id]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>::beforeDelete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yii框架在代码层进行级联删除&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Yii" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Yii/"/>
    
    
      <category term="框架" scheme="https://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Yii" scheme="https://gingjan.com/tags/Yii/"/>
    
  </entry>
  
</feed>
