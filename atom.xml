<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GingJan&#39;s Blog</title>
  <subtitle>Life Feeds On Negentropy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gingjan.com/"/>
  <updated>2020-10-10T04:26:23.000Z</updated>
  <id>https://gingjan.com/</id>
  
  <author>
    <name>GingJan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go最佳实践：如何选择「指针接收器」、「值接收器」</title>
    <link href="https://gingjan.com/2020/10/10/go-best-practices-pointer-or-value-receivers/"/>
    <id>https://gingjan.com/2020/10/10/go-best-practices-pointer-or-value-receivers/</id>
    <published>2020-10-10T04:16:43.000Z</published>
    <updated>2020-10-10T04:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="概念定义"><a class="header-anchor" href="#概念定义"></a>概念定义</h2>
<ul>
<li>指针接收器</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Type)</span> <span class="title">Method</span><span class="params">()</span></span> &#123;&#125; <span class="comment">//pointer receiver 指针接收器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>值接收器</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Type)</span> <span class="title">Method</span><span class="params">()</span></span> &#123;&#125; <span class="comment">//value receiver 值接收器</span></span><br></pre></td></tr></table></figure>
<h2 id="何时使用何者"><a class="header-anchor" href="#何时使用何者"></a>何时使用何者</h2>
<p>常在定义struct方法时遇到接收器类型的选择问题</p>
<h3 id="指针接收器"><a class="header-anchor" href="#指针接收器"></a>指针接收器</h3>
<p>需要改动接收器本身时：若需要在方法里修改接收器的状态或字段值时，使用指针接收器。因为值接收器只是本体的一个副本，对其任何的改动都只是作用在副本上</p>
<p>需要性能的优化：如果struct非常多字段，占用内存大，则使用指针接收器，因为值接收器的副本复制成本太大，导致性能低下。</p>
<h3 id="值接收器"><a class="header-anchor" href="#值接收器"></a>值接收器</h3>
<p>需要并发安全：值接收器因为是副本，因此是并发安全的</p>
<p>无需修改接收器本身时</p>
<h3 id="两者兼存时，如何权衡"><a class="header-anchor" href="#两者兼存时，如何权衡"></a>两者兼存时，如何权衡</h3>
<p>你定义的方法可能有指针接收器和值接收器，这时为了统一，选择全部统一改为指针接收器</p>
]]></content>
    
    <summary type="html">
    
      常在定义struct方法时遇到该问题
    
    </summary>
    
      <category term="Go - 最佳实践" scheme="https://gingjan.com/categories/Go-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="最佳实践" scheme="https://gingjan.com/categories/Go-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Go" scheme="https://gingjan.com/tags/Go/"/>
    
      <category term="最佳实践" scheme="https://gingjan.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Linux日志查看常用命令</title>
    <link href="https://gingjan.com/2020/09/29/common-command-of-linux-for-log/"/>
    <id>https://gingjan.com/2020/09/29/common-command-of-linux-for-log/</id>
    <published>2020-09-29T11:30:20.000Z</published>
    <updated>2020-10-05T03:54:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集常用的Linux日志查看命令</p>
<a id="more"></a>
<p>读取日志的常用命令有三个<code>cat</code>，<code>tail</code>，<code>head</code></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>-n</td>
<td>[file_name]</td>
<td>读取file_name数据，并附带上行号</td>
</tr>
<tr>
<td>tail</td>
<td>-n</td>
<td>10 [file_name]</td>
<td>从file_name最后一行开始，往上读取10行</td>
</tr>
<tr>
<td>tail</td>
<td>-n</td>
<td>-10 [file_name]</td>
<td>从file_name最后一行开始，往上读取10行</td>
</tr>
<tr>
<td>tail</td>
<td>-n</td>
<td>+10 [file_name]</td>
<td>从file_name第10行开始，往下读取到最后一行</td>
</tr>
<tr>
<td>head</td>
<td>-n</td>
<td>10 [file_name]</td>
<td>从file_name第1行开始读取10行</td>
</tr>
<tr>
<td>head</td>
<td>-n</td>
<td>+10 [file_name]</td>
<td>从file_name第1行开始读取10行</td>
</tr>
<tr>
<td>grep</td>
<td>-10n ‘keyword’</td>
<td>[file_name]</td>
<td>筛选file_name的keyword，并输出该keyword所在行的前后10行的日志(10+1+10=21行)</td>
</tr>
<tr>
<td>grep</td>
<td>-10n --color=always ‘keyword’</td>
<td>[file_name]</td>
<td>同上，对keyword上色标记输出</td>
</tr>
<tr>
<td>sed</td>
<td>-n</td>
<td>‘/2006-01-02 15:04:05/, /2006-01-02 15:04:06/p’ [file_name]</td>
<td>模式匹配，输出在匹配时间段内的日志</td>
</tr>
<tr>
<td>more</td>
<td></td>
<td></td>
<td>分页显示，空格键翻页</td>
</tr>
<tr>
<td>less</td>
<td></td>
<td></td>
<td>分页显示，空格键翻页</td>
</tr>
<tr>
<td>sort</td>
<td>-r</td>
<td></td>
<td>排序，-r：倒序</td>
</tr>
</tbody>
</table>
<p><code>tail</code>和<code>head</code> 结合使用<br>
<code>tail -n +5 [file_name] | head -n 3</code><br>
从第5行读取[file_name]到最后一行得出结果集1，然后再从第一行读结果集1，读到第3行</p>
<p><code>cat</code> + <code>gret</code> 结合使用<br>
<code>cat [file_name] | grep -10n 'keyword'</code><br>
筛选file_name的keyword，并输出该keyword所在行的前后10行的日志</p>
<p><code>grep</code> + <code>sort</code> 结合使用<br>
<code>grep -10n 'keyword' [file_name] | sort -r</code><br>
筛选file_name的keyword，并输出该keyword所在行的前后10行的日志，并以倒序排序</p>
<p><code>grep</code> + <code>sort</code> + <code>more</code> 结合使用<br>
<code>grep -10n 'keyword' [file_name] | sort -r | more</code><br>
筛选file_name的keyword，并输出该keyword所在行的前后10行的日志，并以倒序排序，再分页处理</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集常用的Linux日志查看命令&lt;/p&gt;
    
    </summary>
    
      <category term="命令" scheme="https://gingjan.com/categories/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="日志" scheme="https://gingjan.com/categories/%E5%91%BD%E4%BB%A4/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="命令" scheme="https://gingjan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="https://gingjan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>顺时针螺旋原则</title>
    <link href="https://gingjan.com/2020/05/01/clockwise-rule/"/>
    <id>https://gingjan.com/2020/05/01/clockwise-rule/</id>
    <published>2020-05-01T02:00:00.000Z</published>
    <updated>2020-10-05T07:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h2>
<p>可以根据顺时针螺旋原则，对C的复杂声明进行解读</p>
<p>按照以下三个步骤:</p>
<ol>
<li>从变量名开始,沿着顺时针方向(变量名处向上走),从第一个类型声明符号开始,当遇到下一个类型声明  符号则使用对应的自然语言描述它:<br>
<code>[X]</code> or <code>[]</code><br>
=&gt; [^Array X size of… or Array undefined size of…]<br>
[^Array X size of… or Array undefined size of…]:(数组 大小为 X 的… or 数组 大小为 未知 的…)<br>
<code>(type1, type2)</code><br>
=&gt; <code>function passing type1 and type2 returning... (函数 传入 type1 和 type2 返回...)</code><br>
<code>*</code><br>
=&gt; <code>pointer(s) to... (指针 指向...)</code></li>
<li>继续沿着顺时针方向使用自然语言描述对应声明符号直到所有符号描述成为止</li>
<li>圆括号<code>()</code>内的符号要先描述</li>
</ol>
<h2 id="示例"><a class="header-anchor" href="#示例"></a>示例</h2>
<h3 id="示例1-简单声明"><a class="header-anchor" href="#示例1-简单声明"></a>示例1:简单声明</h3>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> x   +-------+</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> +-+   </span>|</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> ^ </span>|<span class="string">   </span>|</span><br><span class="line">char <span class="symbol">*</span>str[10];</span><br><span class="line"> ^   ^   |<span class="string">   </span>|</span><br><span class="line"> |<span class="string">   +---+   </span>|</span><br><span class="line"> +-----------+</span><br></pre></td></tr></table></figure>
<p>首先看,变量<code>str</code>是什么<br>
<code>str is an... (变量str 是一个 ...)</code></p>
<ul>
<li>从变量名<code>str</code>开始沿着顺时针方向(向上)走,遇到第一个字符是<code>[</code>,即有数组,所以:<br>
<code>str is an array 10 of... (变量str 是一个数组大小为10的..).</code></li>
<li>继续沿着顺时针方向,下一个遇到的字符是<code>*</code>,即有指针,所以:<br>
<code>str is an array 10 of pointers to... (变量str 是一个数组大小为10的指针...)</code></li>
<li>继续沿着顺时针方向,下一个遇到的字符是本行结束符<code>;</code>,so跳过,下一个是<code>char</code>:<br>
<code>str is an array 10 of pointers to char (变量str 是一个数组大小为10的指针指向char类型)</code></li>
<li>现在每个字符都遍历了,因此完结</li>
</ul>
<h3 id="示例2-函数指针的声明"><a class="header-anchor" href="#示例2-函数指针的声明"></a>示例2:函数指针的声明</h3>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> x   +--------------------+</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> +---+              </span>|</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> </span>|<span class="string">+-+</span>|<span class="string">              </span>|</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> </span>|<span class="string">^ </span>||<span class="string">              </span>|</span><br><span class="line">char <span class="symbol">*</span>(<span class="symbol">*</span>fp)( int, float <span class="symbol">*</span>);</span><br><span class="line"> ^   ^ ^  ||<span class="string">              </span>|</span><br><span class="line"> |<span class="string">   </span>|<span class="string"> +--+</span>|<span class="string">              </span>|</span><br><span class="line"> |<span class="string">   +-----+              </span>|</span><br><span class="line"> +------------------------+</span><br></pre></td></tr></table></figure>
<p>首先看,变量<code>fp</code>是什么?<br>
<code>fp is a... (fp是...)</code></p>
<ul>
<li>从fp开始,沿着顺时针方向(向上)遇到的第一个是<code>)</code>;因此<code>fp</code>是在圆括号<code>()</code>内的,所以在圆括号内以顺时针螺旋方式继续,下一个是<code>*</code>:<br>
<code>fp is a pointer to... (fp是一个指针指向...)</code></li>
<li>继续,出了圆括号范围后看到的是<code>(</code>,也即有函数:<br>
<code>fp is a pointer to a function passing an int and a pointer to float returning... (fp是一个指针指向函数,该函数传入int类型和指向float的指针类型)</code></li>
<li>继续,下个是<code>*</code>:<br>
<code>fp is a pointer to a function passing an int and a pointer to float returning a pointer to... (fp是一个指针指向函数,该函数传入int类型和指向float的指针类型并返回一个指针)</code></li>
<li>继续,下个是<code>;</code>,虽然到了行结束符,但还没有遍历完全部声明符号,因此继续并最后遇到<code>char</code>:<br>
<code>fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char ((fp是一个指针指向函数,该函数传入int类型和指向float的指针类型并返回一个指针,该指针指向char类型)</code></li>
</ul>
<h3 id="示例3"><a class="header-anchor" href="#示例3"></a>示例3</h3>
<p><code>void (*signal(int, void (*fp)(int)))(int);</code><br>
根据顺时针螺旋定则,分别以signal和fp为起点,以变量名为起点向上画线,再按照顺时针方向画圆,得出下图(当遇到<code>(</code>时,则跳过<code>(</code>到<code>)</code>之间的内容包括<code>)</code>;遇到<code>)</code>时,则不能跳过<code>(</code>到<code>)</code>之间除了<code>(</code>的内容)</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> x    +-----------------------------+</span><br><span class="line"> |<span class="string">    </span>|<span class="string">             x    +---+      </span>|</span><br><span class="line"> |<span class="string">    </span>|<span class="string">  +---+      </span>|<span class="string">    </span>|<span class="string">+-+</span>|<span class="string">      </span>|</span><br><span class="line"> |<span class="string">    </span>|<span class="string">  ^   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string">^ </span>||<span class="string">      </span>|</span><br><span class="line">void (<span class="symbol">*</span>signal(int, void (<span class="symbol">*</span>fp)(int)))(int);</span><br><span class="line"> ^    ^      |<span class="string">      ^    ^  </span>||<span class="string">      </span>|</span><br><span class="line"> |<span class="string">    +------+      </span>|<span class="string">    +--+</span>|<span class="string">      </span>|</span><br><span class="line"> |<span class="string">                  +--------+      </span>|</span><br><span class="line"> +----------------------------------+</span><br></pre></td></tr></table></figure>
<h4 id="分析"><a class="header-anchor" href="#分析"></a>分析</h4>
<ol start="0">
<li>
<p>先找到全部变量名:signal、fp</p>
</li>
<li>
<p>以fp为圆心画的圆:暂称fp圆;以signal为圆心画的圆:暂称signal圆</p>
</li>
<li>
<p>因为fp圆被包含在signal圆内,所以signal层级比fp高</p>
</li>
<li>
<p>根据顺时针螺旋定则,分别以signal和fp为起点,从12点钟方向开始顺时针转动,得出:<br>
signal圆所在层级,得出:<br>
signal(int,…),[设signalAsWhole=signal(int,…)]<br>
*signalAsWhole,[设signalAWPointer=*signalAsWhole]<br>
void (signalAWPointer)(int) 也即 void signalAWPointer(int)</p>
<p>fp圆所在层级,得出:<br>
fp<br>
*fp,[设fpAsWhole=*fp]<br>
void (fpAsWhole)(int) 也即 void fpAsWhole(int)</p>
</li>
</ol>
<p>从最高层开始分析:</p>
<ol>
<li>void signalAWPointer(int),可知是个函数,该函数传入int,返回void (函数)</li>
<li>signalAWPointer = *signalAsWhole,可知signalAWPointer是个指针 (指针)</li>
<li>signalAsWhole = signal(int,…), 可知是个函数 (函数)</li>
<li>其中「…」是fp圆 = void fpAsWhole(int), 可知是个函数,该函数传入int,返回void</li>
<li>设fpAsWhole = *fp 是个指针</li>
</ol>
<p>所以最后得出:</p>
<ul>
<li>「fp是指针,指向一个函数,该函数传入int返回void」 即 「fp是指向 传入int返回void 的函数指针」</li>
<li>「signal是个函数,该函数传入int,fp 并返回一个指针,该指针指向一个函数,该函数传入int返回void」 即 「signal是个函数,该函数传入int,fp并返回一个指向 传入int返回void的函数指针」</li>
</ul>
<p>同样,该原则可以应用到const常量和volatile:</p>
<h3 id="示例4"><a class="header-anchor" href="#示例4"></a>示例4</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *chptr;</span><br></pre></td></tr></table></figure>
<p>chptr是什么?<br>
chptr是一个指向「char常量」的指针 (chptr is a pointer to a char constant.)</p>
<h3 id="示例5"><a class="header-anchor" href="#示例5"></a>示例5</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure>
<p>chptr是什么?<br>
chptr是一个指向「char」的「常量指针」 (chptr is a constant pointer to char.)</p>
<h3 id="示例6"><a class="header-anchor" href="#示例6"></a>示例6</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure>
<p>chptr是什么?<br>
chptr是一个指向指向「char volatile」的「常量指针」 (chptr is a constant pointer to a char volatile.)</p>
<p>欢迎转载但请附上原文链接，谢谢。</p>
<p>参考:</p>
<p><a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">The Clockwise/Spiral Rule 顺时针螺旋原则</a></p>
<p>搭配食用:</p>
<p><a href="https://blog.go-zh.org/gos-declaration-syntax" target="_blank" rel="noopener">Go’s Declaration Syntax</a></p>
<p>如有错误，欢迎指出、讨论，大家共同进步 <sup>_</sup></p>
]]></content>
    
    <summary type="html">
    
      本文主要讲解何为顺时针螺旋原则
    
    </summary>
    
      <category term="代码之上" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="原则" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="原则" scheme="https://gingjan.com/tags/%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Laravel-自动发现扩展包</title>
    <link href="https://gingjan.com/2019/09/24/laravels-package-auto-discovery/"/>
    <id>https://gingjan.com/2019/09/24/laravels-package-auto-discovery/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解Laravel如果基于Composer实现自动发现扩展包</p>
<a id="more"></a>
<p>Laravel附带了一个composer.json文件,当一些Laravel包被拉取到本地后,还需要几步手动配置使之能在Laravel项目中使用</p>
<ul>
<li>注册 Service Provider</li>
<li>注册 Alias或Facade</li>
<li>发布 asset<br>
第一、二步已被 Taylor Otwell 确认有点繁琐,因此联合 Dries Vints 开发并推出了「自动注册 Service Provider 和 Facade」功能</li>
</ul>
<p>在搜索并安装/更新不同的扩展包时,Composer会触发多个事件,这些事件可供订阅,一旦订阅的事件被触发,可调起一段自定义的代码或一条可执行的命令行.<br>
当Composer生成最终的类加载文件.其中一个名为 post-autoload-dump 的事件将会被触发.而后,Laravel已可访问所有类并且项目可使用这些类了</p>
<p>之所以会这样,是因为Laravel在composer.json文件里订阅了 post-autoload-dump 事件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"post-autoload-dump"</span>: [</span><br><span class="line">        <span class="string">"Illuminate\\Foundation\\ComposerScripts::postAutoloadDump"</span>,</span><br><span class="line">        <span class="string">"@php artisan package:discover"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先,调起postAutoloadDump方法,该方法负责清除之前缓存的services和包.然后运行 package:discover 命令,这是关键所在</p>
<p>找寻扩展包<br>
<code>Illuminate\Foundation\Console\PackageDiscoverCommand</code> 调用 <code>Illuminate\Foundation\PackageManifest</code> 类的 <code>build()</code> 方法. <code>PackageManifest</code> 类里包含 Laravel自动找寻已安装包 的实现<br>
<code>PackageManifest</code> 类在应用启动时就被注册入容器里了(是在 <code>Illuminate\Foundation\Application::registerBaseServiceProviders()</code> 里注册)</p>
<p>在 <code>build()</code> 方法内,Laravel会去寻找 <code>vendor/composer/installed.json</code> 文件(该文件由composer生成),Laravel会映射这个文件的内容并且递归搜索含有 <code>extra.laravel</code> 的包</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"extra"</span>: &#123;</span><br><span class="line">    <span class="string">"laravel"</span>: &#123;</span><br><span class="line">        <span class="string">"providers"</span>: [</span><br><span class="line">            <span class="string">"Barryvdh\\Debugbar\\ServiceProvider"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"aliases"</span>: &#123;</span><br><span class="line">            <span class="string">"Debugbar"</span>: <span class="string">"Barryvdh\\Debugbar\\Facade"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后搜索 <code>composer.json</code> 文件的 <code>extra.laravel.dont-discover</code> 区段来判断是否有指定无需自动发现的包</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"extra"</span>: &#123;</span><br><span class="line">    <span class="string">"laravel"</span>: &#123;</span><br><span class="line">        <span class="string">"dont-discover"</span>: [</span><br><span class="line">            <span class="string">"barryvdh/laravel-debugbar"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以添加 <code>*</code> 到数组区段里来告诉laravel不执行自动发现</p>
<p>至此,laravel已经收集好了有关扩展包的信息.接下来是把这些信息写入到 <code>bootstrap/cache/packages.php</code> 文件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">return</span> <span class="keyword">array</span> (</span><br><span class="line">  <span class="string">'barryvdh/laravel-debugbar'</span> =&gt;</span><br><span class="line">  <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'providers'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">      <span class="number">0</span> =&gt; <span class="string">'Barryvdh\\Debugbar\\ServiceProvider'</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'aliases'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">      <span class="string">'Debugbar'</span> =&gt; <span class="string">'Barryvdh\\Debugbar\\Facade'</span>,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注册扩展包<br>
当Laravel Kernel启动时,会有两个 <code>bootstrapper启动器</code> 会被调用到</p>
<ul>
<li><code>\Illuminate\Foundation\Bootstrap\RegisterFacades</code></li>
<li><code>\Illuminate\Foundation\Bootstrap\RegisterProviders</code></li>
</ul>
<p>第一个使用 <code>Illuminate\Foundation\AliasLoader</code> 将所有 <code>Facade</code> 加载到容器里,现在唯一不同的是laravel会把 <code>packages.php</code> 里需要加载的 <code>aliases</code> 都一并加载到容器.(使用 <code>PackageManifest::aliases()</code> 方法来收集这些信息)</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in RegisterFacades::bootstrap()</span></span><br><span class="line">AliasLoader::getInstance(array_merge(</span><br><span class="line">    $app-&gt;make(<span class="string">'config'</span>)-&gt;get(<span class="string">'app.aliases'</span>, []),</span><br><span class="line">    $app-&gt;make(PackageManifest::class)-&gt;aliases()</span><br><span class="line">))-&gt;register();</span><br></pre></td></tr></table></figure>
<p>如上所示,<code>config/app.php</code> 里配置的 <code>aliases</code> 和 <code>PackageManifest类</code> 的 <code>aliases</code> 合并到一起.</p>
<p>相似地,<code>Service Provider</code> 也是这样注册. <code>RegisterProviders</code> 启动器调用 <code>Foundation\Application::registerConfiguredProviders()</code> 把Laravel从所有扩展包中收集的 <code>Service Provider</code> 注册入容器</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$providers = Collection::make(<span class="keyword">$this</span>-&gt;config[<span class="string">'app.providers'</span>])</span><br><span class="line">                -&gt;partition(<span class="function"><span class="keyword">function</span> <span class="params">($provider)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Str::startsWith($provider, <span class="string">'Illuminate\\'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">$providers-&gt;splice(<span class="number">1</span>, <span class="number">0</span>, [<span class="keyword">$this</span>-&gt;make(PackageManifest::class)-&gt;providers()]);</span><br></pre></td></tr></table></figure>
<p>欢迎转载但请附上链接，谢谢。</p>
<p><a href="https://divinglaravel.com/laravels-package-auto-discovery" target="_blank" rel="noopener">原文：laravels-package-auto-discovery</a></p>
<p>如有什么错误，欢迎提出、讨论，大家共同进步 <sup>_</sup></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解Laravel如果基于Composer实现自动发现扩展包&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Laravel" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Laravel/"/>
    
    
      <category term="框架" scheme="https://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="https://gingjan.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>如何选择AES加密模式(CBC、ECB、CTR、OCB、CFB)</title>
    <link href="https://gingjan.com/2018/08/12/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb/"/>
    <id>https://gingjan.com/2018/08/12/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb/</id>
    <published>2018-08-12T03:39:41.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果加密的数据块超过 1 block则不要选择ECB模式<br>
&lt;Excerpt in index | 首页摘要&gt;</p>
<a id="more"></a>
<p>&lt;The rest of contents | 余下全文&gt;</p>
<p>如果加密的数据块超过 1 block则不要选择ECB模式</p>
<p>CBC, OFB 和 CFB 模式很相似,然而如果你只是要加密而不需要解密,则选择OFB或CFB更合适,因为这两种模式可以节约空间</p>
<p>如果需要更快的加密速度(并行加密),选择CTR 而不是 CBC/OFB/CFB.</p>
<p>如果需要 对随机访问介质内的数据(如磁盘或内存中的数据)进行加密,选择XTS模式更合适</p>
<p>OCB是目前为止最好的模式,因为它可以一次性对数据进行加密和验证,然后在美国该模式是需要专利授权的</p>
<p>ECB 很少使用到除非只是加密1个数据块.如果是加密磁盘或内存的数据而不是stream(stream是一段一段的),XTS应该更适合你</p>
<p>每次加密时都要使用唯一且随机的IV(init vector,初始化向量),如果你无法保证随机性,则使用OCB模式,因为它只需要传入nonce而无需传入IV,IV和nonce这两个有点不同,如果被人猜到下一个nonce是不会导致安全问题,而被人猜到下一个IV则会导致安全问题(因为需要保证IV每次是随机的)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果加密的数据块超过 1 block则不要选择ECB模式&lt;br&gt;
&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="https://gingjan.com/categories/%E5%AE%89%E5%85%A8/"/>
    
      <category term="算法" scheme="https://gingjan.com/categories/%E5%AE%89%E5%85%A8/%E7%AE%97%E6%B3%95/"/>
    
      <category term="加密算法" scheme="https://gingjan.com/categories/%E5%AE%89%E5%85%A8/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="安全" scheme="https://gingjan.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="算法" scheme="https://gingjan.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Composer常用命令</title>
    <link href="https://gingjan.com/2018/08/09/composer-command/"/>
    <id>https://gingjan.com/2018/08/09/composer-command/</id>
    <published>2018-08-09T09:18:33.000Z</published>
    <updated>2020-10-05T09:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解并且亲测了常用的Composer命令</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>composer required</td>
<td></td>
<td>“xxx/xxx:v0.0.1”</td>
<td>更新包，自动判断包存不存在，不存在就安装，存在就更新</td>
</tr>
<tr>
<td>composer dump-autoload</td>
<td></td>
<td></td>
<td>不更新依赖,只更新autoload文件</td>
</tr>
<tr>
<td>composer install</td>
<td></td>
<td></td>
<td>根据composer.lock 更新/安装依赖</td>
</tr>
<tr>
<td>composer update</td>
<td></td>
<td></td>
<td>根据composer.json 更新/安装依赖 并更新composer.lock文件</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      本文持续更新中…
    
    </summary>
    
      <category term="依赖管理" scheme="https://gingjan.com/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/PHP/"/>
    
    
      <category term="依赖管理" scheme="https://gingjan.com/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
      <category term="Composer" scheme="https://gingjan.com/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>各种各样的锁</title>
    <link href="https://gingjan.com/2018/05/21/all-kinds-of-locks-md/"/>
    <id>https://gingjan.com/2018/05/21/all-kinds-of-locks-md/</id>
    <published>2018-05-21T15:40:01.000Z</published>
    <updated>2020-10-05T08:47:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程之间的锁"><a class="header-anchor" href="#线程之间的锁"></a>线程之间的锁</h2>
<p>可基于某个共享变量实现。也可使用下面介绍的<code>互斥锁</code>、<code>自旋锁</code>等实现</p>
<h2 id="进程之间的锁"><a class="header-anchor" href="#进程之间的锁"></a>进程之间的锁</h2>
<p>分同一台机器和不同机器。同一机器则同样可使用下面介绍的锁实现。不同机器则需使用分布式锁实现。</p>
<p><code>进程与锁不在同一台机器上（分布式锁），还需要注意网络传输的时间，因此需要判断传输时间，若传输时间大于锁的有效时间，则该锁无效。</code></p>
<h2 id="互斥锁"><a class="header-anchor" href="#互斥锁"></a>互斥锁</h2>
<p>当任务1无法获取锁时，则会进入睡眠态，当锁被释放后，任务1会被唤醒并尝试获取锁，因从用户态（尝试获取锁）进入内核态（无法获取锁）存在切换，<br>
因此较耗性能，通常在几十纳秒到几微秒之间</p>
<h2 id="自旋锁"><a class="header-anchor" href="#自旋锁"></a>自旋锁</h2>
<p>当任务1无法获取锁时，则会不断进行尝试而不进入睡眠态，因此不会进入内核态从而其性能较<code>互斥锁</code>更好。<br>
一般使用<code>WHILE</code>等循环语句实现<code>忙等待</code>，当然这会导致CPU空转从而浪费电能，可以使用CPU的<code>PAUSE</code>指令实现<code>忙等待</code>从而节约电能</p>
<blockquote>
<p>当任务耗时较短时，使用<code>自旋锁</code>比<code>互斥锁</code>更好，因为<code>互斥锁</code>的状态切换耗时可能多于任务本身的耗时</p>
</blockquote>
<h2 id="读写锁"><a class="header-anchor" href="#读写锁"></a>读写锁</h2>
<h3 id="原理"><a class="header-anchor" href="#原理"></a>原理</h3>
<ul>
<li>当<code>读锁</code>没被任务持有时，多个任务能够同时都获取读锁（并发）</li>
<li>但当<code>写锁</code>被某任务持有后，读任务获取读锁的操作会被阻塞，且其他写任务获取写锁的操作也会被阻塞。</li>
</ul>
<p>所以，<code>写锁</code>是排斥锁（X锁），而<code>读锁</code>则是共享锁（S锁）</p>
<p>当然，根据需要，还会分<code>读优先锁</code>和<code>写优先锁</code></p>
<h3 id="读优先锁"><a class="header-anchor" href="#读优先锁"></a>读优先锁</h3>
<p>任务1对资源上读锁，此时任务2需上写锁但无法获取，后续任务3需上读锁，此时任务3可获取读锁，待任务1、任务3、其他拥有读锁的任务都释放读锁后，任务2才能获取写锁。<br>
此为读优先锁，该锁有问题就是会造成<code>写饥饿</code>，即一切有任务获取读锁，导致写任务无法获取写锁，从而导致无法执行写操作。</p>
<h3 id="写优先锁"><a class="header-anchor" href="#写优先锁"></a>写优先锁</h3>
<p>任务1对资源上读锁，此时任务2需写锁但无法获取则阻塞等待，后续任务3需上读锁，但同样也无法获取读锁从而阻塞等待。<br>
待任务1释放读锁后，唤醒任务2使其获取写锁，若后续有任务4获取写锁，则当任务2释放写锁时，任务3仍未能获取读锁，而是唤醒任务4获取写锁。<br>
因此也会导致<code>饥饿</code>的现象<code>读饥饿</code></p>
<ul>
<li>既然都有<code>饥饿</code>现象，那么就来个公平锁，谁都不偏袒</li>
</ul>
<h3 id="公平锁"><a class="header-anchor" href="#公平锁"></a>公平锁</h3>
<p>无论读锁还是写锁，一律按照先来后到，排队等待锁，连续几个读锁请求则可一起共同获取读锁，但是在写锁请求后的读锁请求，则排队等待写锁释放后，才能获取读锁。<br>
这样既可以避免<code>饥饿</code>现象，也可以实现读的并发访问</p>
<blockquote>
<p><code>互斥锁</code>和<code>自旋锁</code>都是最基本的锁，<code>读写锁</code>可以根据场景来选择这两种锁其中的一个进行实现。</p>
</blockquote>
<h2 id="悲观锁"><a class="header-anchor" href="#悲观锁"></a>悲观锁</h2>
<p>悲观锁是指获取或使用一切资源前都认为该资源竞争激烈，需先对资源上锁再使用资源。如上所述的<code>互斥锁</code>、<code>自旋锁</code>和一切其他的<code>锁</code>都属于<code>悲观锁</code>的范畴，所以<code>悲观锁</code>其并发较差。</p>
<h2 id="乐观锁"><a class="header-anchor" href="#乐观锁"></a>乐观锁</h2>
<p>相对的，乐观锁就是认为资源竞争并不激烈，因此总是在最后一步才上锁。比如数据更新时使用的<code>版本号</code>手段。相对的，乐观锁并发较好</p>
<blockquote>
<p>竞争程度不激烈，资源被访问频率不高，则可以使用乐观锁</p>
</blockquote>
<h2 id="分布式锁"><a class="header-anchor" href="#分布式锁"></a>分布式锁</h2>
<p>锁与任务不在同一机器上，通常锁在另外单独的一台机器上，同多台机器上的多个不同进程访问。<br>
根据严格程度又分为多种不同的实现方式。</p>
<h2 id="一些锁的具体实现方法"><a class="header-anchor" href="#一些锁的具体实现方法"></a>一些锁的具体实现方法</h2>
<h3 id="使用Redis在内存存放一个标识以实现锁（分布式锁）"><a class="header-anchor" href="#使用Redis在内存存放一个标识以实现锁（分布式锁）"></a>使用Redis在内存存放一个标识以实现锁（分布式锁）</h3>
<p>使用Redis的string实现：</p>
<h4 id="加锁"><a class="header-anchor" href="#加锁"></a>加锁</h4>
<ol>
<li>进程生成唯一值作为当前进程的ID（下述用进程ID指代）</li>
<li>以锁名为key，进程ID为值存入string</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> lock1 [proc_id] NX EX <span class="number">30</span> //当lock1不存在时，设置lock1为<span class="keyword">key</span>，proc_id为<span class="keyword">value</span>的<span class="keyword">string</span>，且有效时间为<span class="number">30</span>s</span><br></pre></td></tr></table></figure>
<h4 id="解锁"><a class="header-anchor" href="#解锁"></a>解锁</h4>
<ol>
<li>涉及两步，第一步判断解锁进程是否是加锁进程，可通过进程ID识别</li>
<li>删除指定锁名的key<br>
因为涉及两个操作，可在进程内的代码层面进行判断+删除，也可以使用Redis提供的可执行LUA脚本处理</li>
</ol>
<h3 id="可基于MySQL乐观锁实现（分布式锁）"><a class="header-anchor" href="#可基于MySQL乐观锁实现（分布式锁）"></a>可基于MySQL乐观锁实现（分布式锁）</h3>
<p>可参考MySQL乐观锁的实现方式，这里不累述</p>
<h3 id="可重入锁"><a class="header-anchor" href="#可重入锁"></a>可重入锁</h3>
<p>若此时，加锁进程需要再次进入锁，则需引入可重入锁<br>
1.使用Redis的Hash替换String，将锁名作为key，进程ID作为field，第一次上次默认value为1，后面每加一次锁则value自增加1，如</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">lock1:</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"123123-random-id"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次加锁</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">lock1:</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"123123-random-id"</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解锁要执行相应次数，当value为0时，则删除该key完成解锁操作。</p>
<h3 id="联锁"><a class="header-anchor" href="#联锁"></a>联锁</h3>
<p>在多个不同的redis实例上获取到锁，把这些锁看作一个锁称为「联锁」。当全部redis实例的锁都获取到后才认为本次联锁成功获取。<br>
要获取多个redis实例上的锁目的是实现分布式锁的高可用，防止一个redis实例挂掉后，在其获取的锁被认为释放了。（当然你可能会认为可采用主从结构避免，但是也会存在slave来不及同步master时，master就挂了，此时slave当上master后，其他尝试获取锁的进程就会获得锁，导致两个进程对同一资源进行操作）<br>
在获取多个锁的过程，要注意设置最大时间，以防止最后一个锁还没获取到时，第一个获取的锁就已失效。<br>
有一个锁实例获取锁失败，则已获取锁的实例全部都要释放锁，重新进行获取操作，同理超时也是。</p>
<h3 id="RedLock锁"><a class="header-anchor" href="#RedLock锁"></a>RedLock锁</h3>
<p>基于redlock算法实现分布式高可用锁。与联锁类似，但是无需全部redis实例都获取到锁才算成功，只需要获到的锁的redis实例数量为redis锁实例总数的一半加一个即成功，即n/2+1。</p>
]]></content>
    
    <summary type="html">
    
      资源竞争机制里不可或缺的组件————锁
    
    </summary>
    
      <category term="机制" scheme="https://gingjan.com/categories/%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="锁" scheme="https://gingjan.com/tags/%E9%94%81/"/>
    
      <category term="机制" scheme="https://gingjan.com/tags/%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>持续集成、持续交付、持续部署</title>
    <link href="https://gingjan.com/2018/02/01/continuous-integration-and-delivery-and-deployment-md/"/>
    <id>https://gingjan.com/2018/02/01/continuous-integration-and-delivery-and-deployment-md/</id>
    <published>2018-02-01T12:02:01.000Z</published>
    <updated>2020-07-16T11:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2>
<p>现在企业的一般开发流程，从开发人员电脑开发，到发布上测试环境进行单元和集成测试，再发布到预发布环境进行「彩排」，最后才根据需要发布到生产环境上（当然还有些复杂流程就是会分A/B生产环境）。<br>
大致可抽出：开发环境-&gt;[单元测试]-&gt;[合并代码]-&gt;测试环境-&gt;[集成测试]-&gt;预发布环境-&gt;[功能测试]-&gt;生产环境<br>
那么「三个持续」分别负责哪一阶段或层面的工作呢？</p>
<ul>
<li>持续集成（Continuous Integration 即 CI）：这里很好理解，就是负责开发环境到测试环境上的工作，属于技术层面的概念。</li>
<li>持续部署（Continuous Deployment）：业务层面的概念，负责从<code>测试环境</code>到<code>预发布环境</code>到<code>生产环境</code>的代码自动化构建、测试、部署和发布。</li>
<li>持续交付（Continuous Delivery 即 CD）：实际上，持续交付和持续部署很容易混淆，持续交付多指业务层面上（与技术无关）的工作，它属于业务层面的概念。也即要是代码无论任何时候，都持续处于一个可交付给客户（可发布上线对外提供服务）的状态。</li>
</ul>
<h2 id="持续集成"><a class="header-anchor" href="#持续集成"></a>持续集成</h2>
<h3 id="通过一个故事来讲述CI的作用"><a class="header-anchor" href="#通过一个故事来讲述CI的作用"></a>通过一个故事来讲述CI的作用</h3>
<p>在某公司上班的A、B、C、D、E，正在编写一个超级大的应用，ABC是开发人员，D是测试人员，E是项目经理。<br>
在传统的开发方式下，ABC在各自机器上开自己的功能分支，并在此分支上进行开发。期间所有编码和自测工作都仅限于在自己机器上进行。在合并集成到主分支前，他们甚至会在各自分支上或机器上开发几周或几个月的时间。<br>
在某个时间点，项目经理E说要准备发布了，快合并到测试环境的主分支上。<br>
此时，开发人员A、B、C都急急忙忙地把各自分支合并到测试机的主分支上，但因为这三个不同的分支在合并前没一起测试过，而且A、B、C各自的开发环境与测试环境有差异，导致很多bug和问题在合并测试时接踵而至。<br>
合并到测试环境主分支后，测试员D准备进行自动和手动测试，他测出的Bug和问题数量将决定是否能按时发布。经过曲折且长时间的测试后，最终测试通过，项目经理E准备发布项目到生产环境。</p>
<p><img src="/img/CI-CD/ABCDE-story.png" alt="传统的开发模式"></p>
<h3 id="在这个过程中，大家的心路历程是如何的呢？"><a class="header-anchor" href="#在这个过程中，大家的心路历程是如何的呢？"></a>在这个过程中，大家的心路历程是如何的呢？</h3>
<ul>
<li>ABC作为开发人员，会非常难受，因为在合并时会出现各种各样问题，如代码冲突，依赖冲突等。</li>
<li>测试员D也难受，因为在ABC的开发期间，他只能干等着，但是在测试阶段，他又忙到爆炸，而且此时才能编写各种异常场景的测试用例。</li>
<li>项目经理E也是，合并集成阶段是整个项目里最大的不可控点，无法合理预估和规划接下来各阶段的时间，任何异常情况都会把发布推迟。</li>
</ul>
<p>以上主要问题都是因为<code>集成阶段</code>的不稳定和不可控导致，且每次发布前，都会有这个情况出现且越来越不受控制，维护的边际成本逐渐递增。</p>
<h3 id="引入持续集成"><a class="header-anchor" href="#引入持续集成"></a>引入持续集成</h3>
<p>从持续集成这四个字可知道，本质上就是不断重复且频繁的合并代码，集成各功能模块。<br>
怎么个<code>持续</code>集成法呢？<br>
不要一次性的<code>大合并大集成</code>，取而代之的是每当完成一个需求的功能块就马上进行合并集成，无需等待本排期内的其他需求，不用等到发布前的一次性<code>大合并</code>才进行。<br>
<code>注意：每个需求的功能模块代码在合并到主分支前，都要跑一次自动测试。</code><br>
<img src="/img/CI-CD/CI-1.png" alt="引入持续集成-工作流"><br>
<img src="/img/CI-CD/CI-2.png" alt="引入持续集成-结构"></p>
<h3 id="持续集成的要求"><a class="header-anchor" href="#持续集成的要求"></a>持续集成的要求</h3>
<ul>
<li>每个需求/功能开发完毕即刻合并到主分支（在合并前，功能分支要先做好单元测试，然后再合并到主分支并开始主分支的集成测试）。</li>
<li>当主分支合并了功能分支后且通过测试，该功能即完成。</li>
<li>在功能分支和主分支上，都要有自动测试。</li>
<li>开发人员需要持续、经常性拉取主分支的代码并合并到自己的功能分支上，以保证代码同步，防止出现过多冲突。</li>
</ul>
<h3 id="优点"><a class="header-anchor" href="#优点"></a>优点</h3>
<ul>
<li>防止各开发人员各自为政，导致<code>大合并</code>时出现各种环境问题、代码冲突，减少发布前的不可控情况。</li>
<li>将一次性的大测试拆分为多个小测试逐步进行。</li>
</ul>
<h3 id="升华"><a class="header-anchor" href="#升华"></a>升华</h3>
<p>持续集成的目的是让正在开发的软件始终处于可工作状态。同时强调，代码的提交是一种沟通方式，而既然是沟通就需要频繁，下图中代码的提交过程，事实上就是各条分支之间的对话过程。<br>
<img src="/img/CI-CD/branches-communication.jpg" alt="分支间的交流"></p>
<h2 id="持续部署"><a class="header-anchor" href="#持续部署"></a>持续部署</h2>
<p>在持续集成的基础上，将集成后的代码部署到更接近生产环境的<code>预发布环境</code>中。比如，完成单元测试后，可以把代码部署到连接着数据库的<code>Staging</code>环境中，进行更进一步的测试，此时会出现以下几种情况：</p>
<ul>
<li>测试环境与预发布环境不同，可能预发布环境需要额外配置参数。</li>
<li>在测试环境上可正常运行，在预发布环境上无法运行。</li>
<li>后面的部署预发布环境、生产环境都需要手动操作。</li>
</ul>
<h3 id="引入持续部署"><a class="header-anchor" href="#引入持续部署"></a>引入持续部署</h3>
<p>每个开发完毕的新功能在通过测试后自动部署到预发布环境staging，并最终自动部署到生产环境。<br>
<img src="/img/CI-CD/CDeployment.jpg" alt="引入持续集成-结构"></p>
<h2 id="持续交付"><a class="header-anchor" href="#持续交付"></a>持续交付</h2>
<p>持续交付需要与持续集成和持续部署（或叫持续发布）搭配，持续交付基于后两者的基础上，才能实现。就如持续部署实现自动化部署到预发布环境后，业务人员（如产品或运营等）根据需要，决定发布哪些新功能，才将此功能<code>一键</code>发布，部署到生产环境中。持续交付体验在业务人员可在任何时候根据需要来发布业务功能，而不受新功能代码的引入，导致系统不稳定，无法发布上线的影响。</p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>从两个字持续可知三者都是可频繁、重复、稳定的操作。<br>
持续集成是一切的基础，而基于此上的持续部署，贯穿整个过程。基于前两者，再上层的建筑就是持续交付。<br>
持续集成，持续部署都是技术层面上，有了技术层面上的保证，业务层面上的持续交付成为可能。<br>
技术服务于业务，而业务又依赖技术。</p>
]]></content>
    
    <summary type="html">
    
      本文简单介绍三者的来源和区别
    
    </summary>
    
      <category term="架构思想" scheme="https://gingjan.com/categories/%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="架构" scheme="https://gingjan.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="方法论" scheme="https://gingjan.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何在mac上解压分离的压缩文件</title>
    <link href="https://gingjan.com/2017/02/12/how-to-unzip-a-split-archive-on-mac-osx/"/>
    <id>https://gingjan.com/2017/02/12/how-to-unzip-a-split-archive-on-mac-osx/</id>
    <published>2017-02-12T14:04:40.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章向各位展示如何解压分离的压缩文件</p>
<a id="more"></a>
<p>首先，目前据我所知，有两种不同类型的分离压缩文件</p>
<h3 id="一、xxx-zip-001、xxx-zip-002、xxx-zip003类型"><a class="header-anchor" href="#一、xxx-zip-001、xxx-zip-002、xxx-zip003类型"></a>一、xxx.zip.001、xxx.zip.002、xxx.zip003类型</h3>
<h4 id="解决方案："><a class="header-anchor" href="#解决方案："></a>解决方案：</h4>
<p>在终端中输入：</p>
<p><code>for i in </code>seq  1 5<code>; do cat xxx.zip.00$i &gt;&gt; single.zip; done</code> #实则为一个循环语句</p>
<p><code>unzip single.zip</code></p>
<p>解压成功。</p>
<p>其实上面那句循环相当于：</p>
<p><code>cat xxx.zip.001 &gt; single.zip</code> #把数据重定向到single.zip</p>
<p><code>cat xxx.zip.002 &gt;&gt; single.zip</code> #把数据以追加方式重定向到single.zip</p>
<p><code>cat xxx.zip.003 &gt;&gt; single.zip</code></p>
<p><code>cat xxx.zip.004 &gt;&gt; single.zip</code></p>
<p><code>cat xxx.zip.005 &gt;&gt; single.zip</code></p>
<p>或者可以：<code>cat xxx.zip.00* &gt;&gt; already_exist_single.zip</code></p>
<h3 id="二、xxx-z01、xxx-z02、xxx-z03、xxx-zip类型"><a class="header-anchor" href="#二、xxx-z01、xxx-z02、xxx-z03、xxx-zip类型"></a>二、xxx.z01、xxx.z02、xxx.z03、xxx.zip类型</h3>
<h4 id="解决方案"><a class="header-anchor" href="#解决方案"></a>解决方案</h4>
<p><code>zip -s 0 xxx.zip —out unsplit.zip</code> #把分开的文件合并成一个文件</p>
<p><code>-s</code> 代表把压缩的文件分为几部分压缩，<code>0</code> 代表不分割，具体数字如 <code>100m</code> 则代表分为每份大小100m。</p>
<p>以上，如有错误，请指正，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章向各位展示如何解压分离的压缩文件&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mac" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mac/"/>
    
    
      <category term="Mac" scheme="https://gingjan.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Linux-让耗时任务在后台运行</title>
    <link href="https://gingjan.com/2016/09/01/Linux-run-in-background/"/>
    <id>https://gingjan.com/2016/09/01/Linux-run-in-background/</id>
    <published>2016-09-01T04:10:41.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>让终端的任务/耗时任务在后台运行</strong>：我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？</p>
<a id="more"></a>
<p>涉及命令<br>
<code>ps -ef</code> 查看进程<br>
<code>pstree</code> 查看进程树<br>
<code>jobs</code> 查看当前终端的任务列表<br>
<code>commands &amp;</code>，命令后加<code>&amp;</code>代表将该命令放置后台运行<br>
<code>nohup commands &amp;</code><br>
<code>setsid commands</code><br>
<code>(commands &amp;)</code> 效果同上面setsid<br>
<code>ctrl+z</code> (暂停/挂起当前 作业，在使用编辑器时特别有用，退出编辑器时，保存了光标所在的当前位置，下次进入编辑器时不用再次寻找上次光标所处位置)<br>
<code>bg %work_num如bg %1</code>（把作业从挂起转为继续运行）<br>
<code>disown -h %1work_num</code>使某个作业忽略HUP信号<br>
<code>disown -ah</code> 所有作业忽略HUP信号<br>
<code>disown -rh</code> 使正在运行的作业忽略HUP信号<br>
<code>screen -dmS session_name</code> 建立一个断开模式的会话<br>
<code>screen -list</code> 列出所有会话<br>
<code>screen -r session_name</code> 重新连接指定会话</p>
<p>我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？</p>
<h2 id="一、逐个添加"><a class="header-anchor" href="#一、逐个添加"></a>一、逐个添加</h2>
<p>1.通过忽略hangup信号（此信号在终端关闭或者网络断开时就会发出），该种方式可通过jobs命令来查看作业列表<br>
<code>nohup ping www.google.com &amp;</code><br>
查看进程<br>
<code>ps -ef | grep www.google.com</code></p>
<p>2.通过把任务移为其他进程（非终端进程）的子进程来运行，这样就不会受到终端的HUP信号影响了，该种方式通过jobs命令是无法查看作业列表<br>
<code>setsid ping www.google.com</code></p>
<p>3.把任务放置到子shell(subshell)下运行，这样就不会受到终端的HUP信号影响了，该种方式通过jobs命令是无法查看作业列表，因为任务已经不属于该终端的作业了<br>
<code>(ping www.google.com &amp;)</code></p>
<hr>
<h2 id="二、补救"><a class="header-anchor" href="#二、补救"></a>二、补救</h2>
<p>如果我们执行了一个耗时任务，想在该耗时任务运行期间让它到后台运行，这时添加nohup或setsid已经迟了，怎么做？</p>
<h3 id="disown"><a class="header-anchor" href="#disown"></a>disown</h3>
<p><code>disown -h %1</code></p>
<hr>
<h2 id="三、一步完成"><a class="header-anchor" href="#三、一步完成"></a>三、一步完成</h2>
<p>当有很多耗时任务，而我们又不想一个一个去加nohup ,setsid时，怎么办？</p>
<h3 id="screen"><a class="header-anchor" href="#screen"></a>screen</h3>
<p><code>screen -dmS session_name</code></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">参考：https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;让终端的任务/耗时任务在后台运行&lt;/strong&gt;：我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
      <category term="常用命令" scheme="https://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="命令" scheme="https://gingjan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="https://gingjan.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>查看一次SQL的执行时间与相关参数</title>
    <link href="https://gingjan.com/2016/07/03/mysql-sql-execution-check-out/"/>
    <id>https://gingjan.com/2016/07/03/mysql-sql-execution-check-out/</id>
    <published>2016-07-03T09:02:47.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>** mysql之sql执行过程窥探 **：本文讲解如何窥探sql执行过程的相关参数</p>
<a id="more"></a>
<p>1.首先查看当前session（会话）的profiling是否打开<br>
<code>select @@profiling</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql1.png" alt="profiling=0，未打开"><br>
若为0，则未打开，</p>
<p>2.打开profiling<br>
<code>set profiling=1</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql2.png" alt="set profiling=1，开启profiling"></p>
<p>3.执行一些sql<br>
<img src="/img/mysql-sql-execution-check-out/mysql3.png" alt="执行sql"></p>
<p>4.查看所有已执行的sql的profile<br>
<code>show profiles</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql4.png" alt="profiles"></p>
<p>5.看看刚才某条sql执行的具体时间拆分，2是个某次查询的id<br>
<code>show profile for query id</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql5.png" alt="profile for query 2"></p>
<p>6.看看刚才某条sql执行的具体时间拆分，并加上相应的cpu信息 (cpu也可以换成all，以查看更多系统指标)<br>
<code>show profile cpu for query id</code><br>
<img src="/img/mysql-sql-execution-check-out/mysql6.png" alt="profile cpu for query 2"></p>
<p>整理自：<a href="http://itindex.net/detail/51526-mysql-sql-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">http://itindex.net/detail/51526-mysql-sql-执行时间</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** mysql之sql执行过程窥探 **：本文讲解如何窥探sql执行过程的相关参数&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="https://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
    
      <category term="MySQL" scheme="https://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/MySQL/"/>
    
    
      <category term="数据库" scheme="https://gingjan.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://gingjan.com/tags/MySQL/"/>
    
      <category term="SQL" scheme="https://gingjan.com/tags/SQL/"/>
    
      <category term="性能优化" scheme="https://gingjan.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>REST API 响应状态码</title>
    <link href="https://gingjan.com/2016/06/21/rest-status-code-setting/"/>
    <id>https://gingjan.com/2016/06/21/rest-status-code-setting/</id>
    <published>2016-06-21T11:18:08.000Z</published>
    <updated>2020-10-05T09:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了设计REST API时，返回的响应应该设置什么样的状态码</p>
<a id="more"></a>
<h2 id="响应状态码"><a class="header-anchor" href="#响应状态码"></a>响应状态码</h2>
<p>在涉及REST风格的API时，使用适当和Http响应状态码是很重要的，这样可以提高API消费者（客户端）对API响应信息的理解</p>
<h3 id="状态码分为5大类"><a class="header-anchor" href="#状态码分为5大类"></a>状态码分为5大类</h3>
<ul>
<li>1xx：临时响应</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：请求错误</li>
<li>5xx：服务器错误</li>
</ul>
<h3 id="每类的详细"><a class="header-anchor" href="#每类的详细"></a>每类的详细</h3>
<p>状态码 | HTTP方法 | 响应体内容 | 含义 | Status text<br>
:---------------: | :--------------: | :--------------: | :--------------:<br>
1xx | | | |<br>
2xx | | | |<br>
200 | GET,PUT | 资源 | 操作成功 | OK<br>
201 | POST | 资源,元数据 | 资源创建成功 | Created<br>
202 | POST,PUT,DELETE,PATCH | N/A | 请求已被接受 | Accepted<br>
204 | DELETE,PUT,PATCH | N/A | 操作已经执行成功，但是响应体没有数据返回。多用于多次修改同一个资源时填写表单的情况下 | No Content<br>
205 | POST | N/A | 操作已经执行成功，但是响应体没有数据返回。多用于创建资源时填写表单的情况下。请看下面解释与204的区别 |<br>
3xx | | | |<br>
301	| GET | uri链接 | 资源已被移除（永久重定向） | Moved permamently<br>
302 | GET | uri链接 | 重定向（临时重定向），http/1.0 的产物 | Found<br>
303 | GET | uri链接 | 重定向（临时重定向），同302，http/1.1的产物，浏览器会根据返回的uri，自动请求该uri | See Other<br>
304	| GET | N/A | 资源没有被修改，使用时header必须带上If-Modified_Since或者If-None-Match | Not Modified<br>
307 | GET | uri链接 | 重定向（临时重定向），同302，http/1.1的产物，浏览器会根据返回的uri，自动请求该uri | Temporary Redirect<br>
4xx | | | |<br>
400 | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 参数列表错误(缺少，格式不匹配)<br>
401 | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 未授权<br>
403	| GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 访问受限，授权过期<br>
404	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 资源，服务未找到<br>
405	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 不允许的http方法<br>
409	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 资源冲突，或者资源被锁定<br>
415	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 不支持的数据(媒体)类型<br>
429	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 请求过多被限制<br>
5xx | | | |<br>
500	| GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 服务器内部错误/应用系统内部错误<br>
501 | GET,POST,PUT,DELETE,PATCH	| 错误提示(消息) | 接口未实现</p>
<blockquote>
<p>附加说明：N/A 代表不适用</p>
</blockquote>
<hr>
<h2 id="接口文档"><a class="header-anchor" href="#接口文档"></a>接口文档</h2>
<ul>
<li>简单说明</li>
<li>访问地址</li>
<li>请求方式</li>
<li>返回结果</li>
<li>返回结果的字段说明</li>
<li>错误代码</li>
<li>更新记录</li>
</ul>
<hr>
<h2 id="状态码的详解"><a class="header-anchor" href="#状态码的详解"></a>状态码的详解</h2>
<h3 id="HTTP响应状态码主要分为这几种大类："><a class="header-anchor" href="#HTTP响应状态码主要分为这几种大类："></a>HTTP响应状态码主要分为这几种大类：</h3>
<ul>
<li>1xx：临时响应</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：请求错误</li>
<li>5xx：服务器错误</li>
</ul>
<h3 id="204"><a class="header-anchor" href="#204"></a>204</h3>
<p>请求执行成功，但是响应体没有数据返回，浏览器不用刷新页面也不用跳转页面，所以如果是表单页面，那么表单里填写的数据将不会被清除。另外一点，即使是<a>标签，如果a标签里的链接返回的是204，那么页面也是不会发生跳转。同时返回204也是代表客户端和服务器端的状态（指该资源状态）已经同步</p>
<h3 id="205-（204与205区别）"><a class="header-anchor" href="#205-（204与205区别）"></a>205 （204与205区别）</h3>
<p>请求执行成功，但是响应体没有数据返回，浏览器清空表单数据，方便用户再次填写新数据。</p>
<h3 id="304（304与204区别）"><a class="header-anchor" href="#304（304与204区别）"></a>304（304与204区别）</h3>
<p>注意与204的区别，204情况下是返回空文档，并且该文档会替换上次缓存的文件，因此会有文档/文件没有加载的情况（如没有加载jQuery文件因此提示无$函数等）。而304是使用上次缓存</p>
<hr>
<h2 id="其他需要注意的地方"><a class="header-anchor" href="#其他需要注意的地方"></a>其他需要注意的地方</h2>
<p>这里谈谈REST其他需要注意的地方，注意，以下内容不是标准。</p>
<h3 id="PUT与PATCH区别"><a class="header-anchor" href="#PUT与PATCH区别"></a>PUT与PATCH区别</h3>
<p>我们都知道，更新操作可以通过PUT与PATCH方式提交请求，但是问题来了，PUT和PATCH有什么区别呢？<br>
PUT，正如其词，就是把一大堆数据PUT到服务端，使用PUT更新资源时，需要把资源的所有属性都要提交到服务端。<br>
PATCH，补丁，碎片，可以知道，使用PATCH更新资源时，只需要把资源的部分属性/信息提交到服务端即可。</p>
<h3 id="关于URI设计"><a class="header-anchor" href="#关于URI设计"></a>关于URI设计</h3>
<ul>
<li>从属关系使用嵌套形式，即articles/1/comments，articles/1/comments/2</li>
<li>筛选使用查询键值对的形式，即?key=value，articles?title=first_api</li>
</ul>
<h2 id="关于各种框架对REST的支持与实现"><a class="header-anchor" href="#关于各种框架对REST的支持与实现"></a>关于各种框架对REST的支持与实现</h2>
<p>本节内容打算放到另一篇文章讲<br>
未完待续…</p>
<p><a href="http://www.cnblogs.com/cathsfz/archive/2012/06/19/2553431.html" target="_blank" rel="noopener">整理自</a><br>
<a href="http://www.bkjia.com/headlines/491296.html" target="_blank" rel="noopener">整理自</a><br>
<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">整理自</a><br>
<a href="http://www.cnblogs.com/cathsfz/archive/2012/06/19/2553431.html" target="_blank" rel="noopener">整理自</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了设计REST API时，返回的响应应该设置什么样的状态码&lt;/p&gt;
    
    </summary>
    
      <category term="代码之上" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="API接口设计" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="REST" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/REST/"/>
    
    
      <category term="REST" scheme="https://gingjan.com/tags/REST/"/>
    
      <category term="API接口" scheme="https://gingjan.com/tags/API%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Yii的redirect()方法无法终止执行代码</title>
    <link href="https://gingjan.com/2016/06/16/yii-redirect-cannot-stop-execution/"/>
    <id>https://gingjan.com/2016/06/16/yii-redirect-cannot-stop-execution/</id>
    <published>2016-06-16T02:55:54.000Z</published>
    <updated>2020-10-05T09:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>** 坑爹的redirect() **：在controller里的redirect方法在跳转后，无法终止后续代码的执行。特别在init方法中更棘手。</p>
<a id="more"></a>
<h3 id="遇到的情况-问题"><a class="header-anchor" href="#遇到的情况-问题"></a>遇到的情况/问题</h3>
<p>在写权限控制的时候，在BaseController里的init方法设置了权限检测，如果权限不足则跳转并且终止执行后续代码，可是问题来了，使用了redirect()方法后，确实是跳转了，但是后续操作依然可以执行，显然没有做到控制权限的效果。</p>
<h3 id="问题分析"><a class="header-anchor" href="#问题分析"></a>问题分析</h3>
<p>查看redirect源码后，发现redirect()方法只是做了一些头的设置和跳转，并不会终止后续代码的执行，通过在init方法里加<code>return</code> 、<code>return false</code>、 <code>return true</code>等方法后，依然无效。难道要用<code>header('Location: ' . $redirect_url);exit;</code>来解决问题？测试后，使用该方法确实可以解决问题，但是这样写会不会有点恶心啊，于是乎发现Yii有提供<code>Yii:$app-&gt;response-&gt;send();</code>和<code>Yii:$app-&gt;end();</code>可以做到同样效果，最后就在init里使用了<code>Yii::$app-&gt;end();</code>来解决了这个问题。</p>
<h3 id="再次遇到问题"><a class="header-anchor" href="#再次遇到问题"></a>再次遇到问题</h3>
<p>经过检验，在普通的actionName()方法里，可以使用return 来终止后续代码的执行，但是在init里却不管用，什么情况？<strong>有待研究</strong>(因为init()只是执行了并没有return？)</p>
<h3 id="解决方案"><a class="header-anchor" href="#解决方案"></a>解决方案</h3>
<ul>
<li>在普通的actionName方法里，可以使用<code>return</code>、<code>Yii:$app-&gt;response-&gt;send();</code>、<code>Yii:$app-&gt;end();</code>来解决问题，建议使用<code>return</code>更简洁</li>
<li>在init方法里，只能使用<code>Yii:$app-&gt;response-&gt;send();</code>和<code>Yii:$app-&gt;end();</code>来解决问题了。</li>
</ul>
<p>如有什么错误，欢迎指定和讨论</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 坑爹的redirect() **：在controller里的redirect方法在跳转后，无法终止后续代码的执行。特别在init方法中更棘手。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Yii" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Yii/"/>
    
    
      <category term="框架" scheme="https://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Yii" scheme="https://gingjan.com/tags/Yii/"/>
    
  </entry>
  
  <entry>
    <title>在Yii中如何处理级联删除</title>
    <link href="https://gingjan.com/2016/06/13/cascade-delete-in-yii/"/>
    <id>https://gingjan.com/2016/06/13/cascade-delete-in-yii/</id>
    <published>2016-06-13T03:39:41.000Z</published>
    <updated>2020-10-05T09:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Yii框架在代码层进行级联删除</p>
<a id="more"></a>
<p>数据库表里使用了外键并且使用了Restrict模式，导致删除一张表的记录时，因为外键和其他表关联起来了，导致无法删除，需要把关联表的记录同时也删除了才可以操作目标表记录的删除操作。</p>
<p>第一步：重写beforeDelete()<br>
在Model里，重写beforeDelete()，然后在该方法的最后一行<code>return parent::beforeDelete();</code>即可<br>
当然与beforeDelete方法对应的afterDelete方法也能做其他事情。<br>
充分发挥before和after的作用吧</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $id = <span class="keyword">$this</span>-&gt;id;;</span><br><span class="line">        A::deleteAll([<span class="string">'id'</span>=&gt;$id]);<span class="comment">//级联删除</span></span><br><span class="line">        B::deleteAll([<span class="string">'id'</span>=&gt;$id]);</span><br><span class="line">        C::deleteAll([<span class="string">'id'</span>=&gt;$id]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>::beforeDelete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yii框架在代码层进行级联删除&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Yii" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Yii/"/>
    
    
      <category term="框架" scheme="https://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Yii" scheme="https://gingjan.com/tags/Yii/"/>
    
  </entry>
  
  <entry>
    <title>访问修饰符的意义</title>
    <link href="https://gingjan.com/2016/06/06/accessing-control-and-locator-qualifer-purpose/"/>
    <id>https://gingjan.com/2016/06/06/accessing-control-and-locator-qualifer-purpose/</id>
    <published>2016-06-06T14:45:07.000Z</published>
    <updated>2020-10-05T09:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解为何有些成员变量需要设置成私有的，为什么不能直接设置成public直接在外部访问，以及PHP魔术方法__get()和__set()的使用</p>
<a id="more"></a>
<p>先上一段代码好说明问题</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_salary;<span class="comment">//私用属性命名加_</span></span><br><span class="line">    <span class="comment">//setter and getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;<span class="comment">//如果只有get，那么说明该 属性/成员变量 只是可读，不可写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSalary</span><span class="params">($salary)</span> </span>&#123;<span class="comment">//如果只有set，说明该 属性/成员变量 只是可写，不可读</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_salary = $salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上，我们觉得好像private改成public也没什么大问题，但是如果有这样一个场景，调用代码中，多处调用了User的salary属性，有写的也有读的，但是有一天，你不想让调用者修改salary了（禁用写），那怎么办？要怎么保证调用者的代码中没有直接修改salary的代码？如果提供了setter，那么只要把setter删掉，一旦调用代码中有没清理干净的对salary进行写入/修改 的代码，那么就会抛出异常。而使用public $salary这种方式的话，改成private后，虽然是可以禁止写了但是连读取也被禁止了。</li>
<li>对写入数据的操作/过滤，使用setter和getter，可以统一对写入/读取 进行操作或者过滤，比如要去掉写入数据中的空格，如果使用public，那么要在每个调用处写上trim()，但是我们无法保证每处都写上trim了。如果用setter，那么我们可以在setter中写一次trim即可，而且也保证对每次写入都会进行过滤，不会有遗漏。</li>
</ul>
<blockquote>
<p>注意:由于 __get() 和 __set() 是在遍历所有成员变量，找不到匹配的成员变量时才被调用。因此，其效率是低于直接访问成员变量的形式。在一些表示数据结构、数据集合等简单情况下，且不需读写控制等， 可以考虑使用成员变量作为属性直接访问，这样可以提高一点效率。<br>
另外一个提高效率的技巧就是：使用 $k1 = $obj-&gt;getK1() 来代替 $k1 = $obj-&gt;K1 ， 用 $obj-&gt;setK1($value) 来代替 $obj-&gt;K1 = $value 。 这在功能上是完全一样的效果，但是避免了使用 __get() 和 __set() ，相当于绕过了遍历的过程。</p>
</blockquote>
<p>这里还要区分，在类里成员变量和属性的区别。成员变量和属性的区别与联系在于：</p>
<ul>
<li>成员变量是一个“内”概念，反映的是就类的结构构成而言的该你那。属性是一个“外”概念，反映的是类的功能逻辑意义而言的概念。</li>
<li>成员变量没有读写权限控制，而属性可以指定为只读或只写，或可读可写。</li>
<li>成员变量不对读出作任何后处理，不对写入作任何预处理，而属性则可以。</li>
<li>public成员变量可以视为一个可读可写、没有任何预处理或后处理的属性。 而private成员变量由于外部不可见，与属性“外”的特性不相符，所以不能视为属性。</li>
<li>虽然大多数情况下，属性会由某个或某些成员变量来表示，但属性与成员变量没有必然的对应关系， 比如与非门的 output 属性，就没有一个所谓的 $output 成员变量与之对应。</li>
</ul>
<p>为了更形象，我们看个例子</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAndGate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_k1;</span><br><span class="line">    <span class="keyword">private</span> $_k2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setK1</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$_k1 = $value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setK2</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$_k2 = $value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getOutput</span><span class="params">()</span> </span>&#123;<span class="comment">//与非门有两个输入，当两个输入都为真时，与非门的输出为假，否则，输出为真。</span></span><br><span class="line">        <span class="keyword">if</span> ( !<span class="keyword">$this</span>-&gt;_k1 || !<span class="keyword">$this</span>-&gt;_k2 ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;_k1 &amp;&amp; <span class="keyword">$this</span>-&gt;_k2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，与非门类有两个成员变量， <code>$_k1</code> 和 <code>$_k2</code> 。<strong>但是有3个属性</strong>，表示2个输入的 <code>key1</code> 和 <code>key2</code> ，以及表示输出的 <code>output </code>。<br>
由于我们知道，属性一般是通过<code>$obj-&gt;property</code>方式来访问的，但是这里根本没有<code>output</code>这个成员变量呀？那还怎么访问呢？<br>
没错，这时候就要靠我们的<code>魔术方法__get()</code>来配合<code>getter</code>了，上<code>__get()</code>的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    $getter = <span class="string">'get'</span> . $name;<span class="comment">//如此，当调用$obj-&gt;output属性时，就会去调用getOutput()，以达到具有output属性的效果</span></span><br><span class="line">    <span class="keyword">if</span> (method_exists(<span class="keyword">$this</span>, $getter)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$getter();</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (method_exists(<span class="keyword">$this</span>, <span class="string">'set'</span>.$name)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'只存在setter，也即该属性为只写'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'无'</span> , $name , <span class="string">'属性'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欢迎转载但请附上链接，谢谢。</p>
<p><a href="http://www.digpage.com/property.html" target="_blank" rel="noopener">参考：http://www.digpage.com/property.html</a></p>
<p>如有什么错误，欢迎提出、讨论，大家共同进步 <sup>_</sup></p>
]]></content>
    
    <summary type="html">
    
      本文主要讲解为何有些成员变量需要设置成私有的，为什么不能直接设置成public直接在外部访问，以及PHP魔术方法__get()和__set()的使用
    
    </summary>
    
      <category term="代码之上" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="OOP" scheme="https://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/OOP/"/>
    
    
      <category term="OOP" scheme="https://gingjan.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Yii框架的服务定位器</title>
    <link href="https://gingjan.com/2016/06/02/yii-service-locator/"/>
    <id>https://gingjan.com/2016/06/02/yii-service-locator/</id>
    <published>2016-06-02T12:02:51.000Z</published>
    <updated>2020-10-05T09:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>** Yii——组件注册 **：Yii的组件相当于Laravel的服务，同样需要注册到一个IOC容器中，以便在应用其他地方使用这些组件/服务</p>
<a id="more"></a>
<p>这相当与在laravel中，使用$app应用的register或者singleton方法注册服务，而在Yii中则称为服务定位器Service Locator。</p>
<h2 id="注册组件"><a class="header-anchor" href="#注册组件"></a>注册组件</h2>
<p>在Yii中，要注册组件(laravel中称之为服务)可以使用如下方式：</p>
<h3 id="方法一：set方法"><a class="header-anchor" href="#方法一：set方法"></a>方法一：set方法</h3>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">yii</span>\<span class="title">di</span>\<span class="title">ServiceLocator</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">yii</span>\<span class="title">caching</span>\<span class="title">FileCache</span>;</span><br><span class="line">$locator = <span class="keyword">new</span> ServiceLocator;</span><br><span class="line">$locator-&gt;set(<span class="string">'cache'</span>, <span class="string">'yii\caching\ApcCache'</span>);<span class="comment">//使用类名直接创建</span></span><br><span class="line">$locator-&gt;set(<span class="string">'db'</span>, [<span class="comment">//通过配置数组来注册</span></span><br><span class="line"><span class="string">'class'</span> =&gt; <span class="string">'yii\db\Connection'</span>,</span><br><span class="line"><span class="string">'dsn'</span> =&gt; <span class="string">'mysql:host=localhost;dbname=demo'</span>,</span><br><span class="line"><span class="string">'username'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line"><span class="string">'password'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">]);</span><br><span class="line">$locator-&gt;set(<span class="string">'search'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="comment">//通过一个匿名函数返回实例来注册</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> app\components\SolrService;</span><br><span class="line">&#125;);</span><br><span class="line">$locator-&gt;set(<span class="string">'pageCache'</span>, <span class="keyword">new</span> FileCache);<span class="comment">//直接使用new实例化来注册</span></span><br></pre></td></tr></table></figure>
<h3 id="方法二：在配置文件中配置"><a class="header-anchor" href="#方法二：在配置文件中配置"></a>方法二：在配置文件中配置</h3>
<p>返回配置数组的方式，即在应用的配置文件中配置components项</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'components'</span> =&gt; [</span><br><span class="line">        <span class="string">'db'</span> =&gt; [</span><br><span class="line">            <span class="string">'class'</span> =&gt; <span class="string">'yii\db\Connection'</span>,</span><br><span class="line">            <span class="string">'dsn'</span> =&gt; <span class="string">'mysql:host=localhost;dbname=demo'</span>,</span><br><span class="line">            <span class="string">'username'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line">            <span class="string">'password'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'cache'</span> =&gt; <span class="string">'yii\caching\ApcCache'</span>,</span><br><span class="line">        <span class="string">'search'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> app\components\SolrService;</span><br><span class="line">        &#125;，</span><br><span class="line">    ]，</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请谨慎注册太多应用组件，应用组件就像全局变量，使用太多可能加大测试和维护的难度。 一般情况下可以在需要时再创建本地组件。</p>
</blockquote>
<hr>
<h2 id="使用-访问-组件"><a class="header-anchor" href="#使用-访问-组件"></a>使用/访问 组件</h2>
<p>通过访问上面注册时的名字/ID 来访问，两种方式，get(‘name/id’)和属性<br>
$cache = $locator-&gt;get(‘cache’);<br>
$cache = $locator-&gt;cache;//通过属性</p>
<hr>
<h2 id="检查是否注册某个组件"><a class="header-anchor" href="#检查是否注册某个组件"></a>检查是否注册某个组件</h2>
<p>$locator-&gt;has(‘name’);</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** Yii——组件注册 **：Yii的组件相当于Laravel的服务，同样需要注册到一个IOC容器中，以便在应用其他地方使用这些组件/服务&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Yii" scheme="https://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Yii/"/>
    
    
      <category term="框架" scheme="https://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Yii" scheme="https://gingjan.com/tags/Yii/"/>
    
  </entry>
  
  <entry>
    <title>Javascript的单线程和异步之间的关系</title>
    <link href="https://gingjan.com/2016/06/01/js-async-single-thread-queue/"/>
    <id>https://gingjan.com/2016/06/01/js-async-single-thread-queue/</id>
    <published>2016-06-01T03:26:32.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍javascript的异步和单线程的关系，以及简单解释了单线程的js怎么异步处理。</p>
<a id="more"></a>
<h2 id="异步计时函数setTimeout"><a class="header-anchor" href="#异步计时函数setTimeout"></a>异步计时函数setTimeout()</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> begin = <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="comment">//代码开始</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    alert(<span class="string">'你好，这个程序已经运行了'</span> + (end - begin) + <span class="string">'毫秒'</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>);<span class="comment">//1秒后弹出对话框</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">new</span> <span class="built_in">Date</span>() - begin) &lt; <span class="number">6000</span>) &#123;&#125;<span class="comment">//循环代码持续3秒，3秒后，整个js调用栈的程序才执行完毕（在控制台中可以看到3秒后才出现一个响应undefined）</span></span><br></pre></td></tr></table></figure>
<p>上面的代码跟下面的对比一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> begin = <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="comment">//代码开始</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    alert(<span class="string">'你好，这个程序已经运行了'</span> + (end - begin) + <span class="string">'毫秒'</span>);</span><br><span class="line">&#125;,<span class="number">6000</span>);<span class="comment">//6秒后弹出对话框</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">new</span> <span class="built_in">Date</span>() - begin) &lt; <span class="number">3000</span>) &#123;&#125;<span class="comment">//循环代码持续3秒，3秒后，js调用栈执行完毕，控制台出现undefined，然后再过6-3=3秒后，出现弹框</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>
当js解析器解析到setTimeout时，就调用了浏览器的api——异步函数setTimeout，此时js继续往下解析执行，而浏览器就另有一个线程来处理异步函数setTimeout，也就是1秒后把回调函数放入js执行队列中。而此时，js调用栈中继续执行剩下的代码，直至完成了后面的循环后（调用栈中所有代码已经执行完毕）才解析队列中的回调函数来执行。</p>
<hr>
<h2 id="异步IO函数"><a class="header-anchor" href="#异步IO函数"></a>异步IO函数</h2>
<p>这里我们介绍下ajax，为了方便起见，直接使用jquery来说明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('http://blog.zjien.com', function(resData)&#123;</span><br><span class="line">alert(resData);</span><br><span class="line">&#125; );</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>js在解析并执行到$.get()时，发起http请求，我看打开F12可以看到请求是处于Pending状态，通过WireShark或Fiddler2可以查看到HTTP请求状态，可知请求是成功发送并且有响应，但是因为下面的while是死循环，因此$.get()里的回调函数一直在队列中排队，得不到js的解析和执行，呈现出假死的状态。<br>
换一种形式来展示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('http://blog.zjien.com',function(resData)&#123;</span><br><span class="line">alert(resData);</span><br><span class="line">&#125;);</span><br><span class="line">alert(<span class="string">'go on?'</span>);</span><br></pre></td></tr></table></figure>
<p>js解析并执行到go on时，浏览器弹出窗口，暂时不要关闭窗口，通过F12可以看到，请求是Pending状态，但通过Wireshark等工具看到请求是完成并得到响应的，只是因为go on阻塞/阻止了时间循环，导致$.get的回调无法执行，只有按下确定关闭了go on框，回调才得以执行。这是在chrome的情况如此。<br>
在Firefox下却不会出现此情况，go on并不能阻止事件循环，所以上面两个代码段的ajax（$.get）的回调都可以执行，于是界面出现3个alert弹框。</p>
<blockquote>
<p>注意，每个窗口有一个js线程(单线程)，若一个窗口中有多个tag，那么这多个tag都是用同一个js线程。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍javascript的异步和单线程的关系，以及简单解释了单线程的js怎么异步处理。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"/>
    
      <category term="基础" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/Javascript/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="js" scheme="https://gingjan.com/tags/js/"/>
    
      <category term="Javascript" scheme="https://gingjan.com/tags/Javascript/"/>
    
      <category term="异步" scheme="https://gingjan.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="线程" scheme="https://gingjan.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="队列" scheme="https://gingjan.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>超时调用和循环调用</title>
    <link href="https://gingjan.com/2016/05/25/settimeout-and-setintervel/"/>
    <id>https://gingjan.com/2016/05/25/settimeout-and-setintervel/</id>
    <published>2016-05-25T15:36:28.000Z</published>
    <updated>2020-10-05T09:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>** setTimeout和setInterval **：本文介绍这两个浏览器提供的api及其底层的原理</p>
<a id="more"></a>
<h3 id="超时调用就是setTimeout-function-delay"><a class="header-anchor" href="#超时调用就是setTimeout-function-delay"></a>超时调用就是setTimeout(function(){}, delay);</h3>
<p>第一参数：要执行的回调函数<br>
第二参数：延迟多少毫秒，表示在指定时间之后添加回调函数到执行队列中，如果指定时间之后队列中没有其他要执行的代码，那么被添加的代码（即回调函数）会被立即执行。如果队列中有其他代码，那么回调函数会在队列里的代码执行完毕之后才执行。</p>
<p>可以使用<code>clearTimeout()；</code>来清楚 未执行 的任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="number">1000</span>);</span><br><span class="line">clearTimeout(a);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="循环调用就是setInterval"><a class="header-anchor" href="#循环调用就是setInterval"></a>循环调用就是setInterval();</h3>
<p>第一参数：要执行的回调函数<br>
第二参数：延迟多少毫秒，表示定期添加回调函数到执行队列中，如果指定时间之后队列中没有其他要执行的代码，那么被添加的代码（即回调函数）会被立即执行。如果队列中有其他代码，那么回调函数会在队列里的代码执行完毕之后才执行。注意，这个函数会定期不停的添加回调函数到执行队列的。</p>
<p>清除同上，使用<code>clearInterval(a);</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="number">1000</span>);</span><br><span class="line">clearInterval(a);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上两个函数都不一定会严格按照指定的时间间隔执行，这主要看执行队列中是否还有其他待执行的代码（也因为JS是单线程的）</p>
</blockquote>
<blockquote>
<p>注意,setTimeout和setInterval都是浏览器的api（由浏览器提供的内置函数），是一种异步函数。上面所说的队列是准确来说是指 异步任务队列 ，而js在执行着的代码是处于js调用栈里的代码<br>
<img src="/img/js-called-stack1.png" alt="js调用栈和异步队列1"><br>
<img src="/img/js-called-stack2.png" alt="js调用栈和异步队列2"></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** setTimeout和setInterval **：本文介绍这两个浏览器提供的api及其底层的原理&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"/>
    
      <category term="基础" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/Javascript/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Javascript" scheme="https://gingjan.com/tags/Javascript/"/>
    
      <category term="异步" scheme="https://gingjan.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="回调" scheme="https://gingjan.com/tags/%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://gingjan.com/2016/05/24/git-command/"/>
    <id>https://gingjan.com/2016/05/24/git-command/</id>
    <published>2016-05-24T09:08:33.000Z</published>
    <updated>2020-10-05T09:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解并且亲测了常用的Git命令</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init</td>
<td></td>
<td></td>
<td>初始化/新建 当前目录为本地git仓库</td>
</tr>
<tr>
<td>git add</td>
<td>-A或-add</td>
<td></td>
<td>添加当前目录下所有未被tracking以及被修改的文件到index中</td>
</tr>
<tr>
<td>git add</td>
<td></td>
<td>file</td>
<td>添加 file文件/指定文件 到index中</td>
</tr>
<tr>
<td>git add</td>
<td></td>
<td>.</td>
<td>递归添加当前目录下的所有文件(包含目录)到index中</td>
</tr>
<tr>
<td>git rm</td>
<td>–cached</td>
<td>file</td>
<td>只删除index中指定的文件，而处于工作目录（也即文件目录）中的文件不会受到影响（不会被删除）</td>
</tr>
<tr>
<td>git rm</td>
<td>-f或–force</td>
<td>file</td>
<td>同时删除index和工作目录中指定的文件</td>
</tr>
<tr>
<td>git rm</td>
<td>-r</td>
<td>*</td>
<td>删除index暂存区里的全部文件</td>
</tr>
<tr>
<td>git status</td>
<td></td>
<td></td>
<td>查看整个项目已经初始化的目录下所有文件的状态(处于 .gitignore 文件里的文件会被)</td>
</tr>
<tr>
<td>git status</td>
<td></td>
<td>.</td>
<td>查看当前目录下所有文件和目录的状态(非递归,也即当前目录内的子目录内的文件无法查看)</td>
</tr>
<tr>
<td>git commit</td>
<td>-m</td>
<td>‘message’</td>
<td>提交当前index中的文件到仓库repo中，并且附上提交说明/信息</td>
</tr>
<tr>
<td>git commit</td>
<td>-am</td>
<td>‘message’</td>
<td>git add 和 git commit 的组合</td>
</tr>
<tr>
<td>git commit</td>
<td>–amend -m</td>
<td>‘this is amend command’</td>
<td>当index没有新文件/修改的文件的前提下，该参数可以用来修改上一次commit的说明。当index中有新的文件或者修改的文件，该参数就会把这次index里的文件追加到上一次的commit中，而不会产生一次新的commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td></td>
<td>显示所有的commit记录</td>
</tr>
<tr>
<td>git log</td>
<td>-1</td>
<td></td>
<td>显示1行日志 -n为n行</td>
</tr>
<tr>
<td>git log</td>
<td>–stat</td>
<td></td>
<td>显示每个文件的变动信息</td>
</tr>
<tr>
<td>git log</td>
<td>-p -m</td>
<td></td>
<td></td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>v1.0</td>
<td>显示v1.0的日志</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1 ^branch-2</td>
<td>查看 branch-1 有，而 branch-2 中没有的 commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-2 ^branch-1</td>
<td>同理 查看 branch-2 有，而 branch-1 中没有的 commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1…branch-2</td>
<td>查看 branch-2 中比 branch-1 中多提交了哪些commit，注意，列出来的是两个点后边（此处即branch-2）比前边（此处即branch-1）多提交的内容。</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-2…branch-1</td>
<td>同理 查看 branch-1 中比 branch-2 中多提交了哪些commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1…branch-2</td>
<td>不知道谁提交的多谁提交的少，单纯想知道有什么不一样，注意三个点</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>–left-right branch-1…branch-2</td>
<td>在上述情况下，再显示出每个提交是在哪个分支上，注意 commit 后面的箭头，根据我们在 --left-right branch-1…branch-2 的顺序，左箭头 &lt; 表示是 branch-1 的，右箭头 &gt; 表示是 branch-2的。</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>fjf01</td>
<td>显示某个commit的详细内容</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>HEAD</td>
<td>显示HEAD指向的commit的提交日志</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>HEAD^</td>
<td>显示HEAD的父(上一个版本)的commit的提交日志</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>HEAD^^</td>
<td>显示HEAD的上两个版本的commit的提交日志</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>HEAD^5</td>
<td>显示HEAD的上5个版本的commit的提交日志</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>v1.0</td>
<td>显示v1.0标签的版本信息</td>
</tr>
<tr>
<td>git tag</td>
<td></td>
<td></td>
<td>显示已存在的tag</td>
</tr>
<tr>
<td>git tag</td>
<td>-l</td>
<td></td>
<td>显示已存在的tag</td>
</tr>
<tr>
<td>git tag</td>
<td>-a v3.0 -m ‘new version’</td>
<td></td>
<td>给当前HEAD指向的commit打上标签(tag)，每次打tag都需要加上说明-m</td>
</tr>
<tr>
<td>git tag</td>
<td>-a v3.1 eci3t8 -m ‘new version’</td>
<td></td>
<td>给以前的某个历史提交打上标签(tag)，并附加上说明-m</td>
</tr>
<tr>
<td>git push</td>
<td>–tags</td>
<td></td>
<td>把本地全部标签推送到远程仓库，不加–tags参数默认是不会把标签推送到远程的</td>
</tr>
<tr>
<td>git push</td>
<td>remote_host</td>
<td>v1.0.1</td>
<td>推送本地指定标签到远程</td>
</tr>
<tr>
<td>git push</td>
<td>remote_host --delete tag</td>
<td>v1.0.1</td>
<td>删除远程指定标签</td>
</tr>
<tr>
<td>git clone</td>
<td></td>
<td>xxx.git</td>
<td>克隆远程仓库到本地</td>
</tr>
<tr>
<td>git clone</td>
<td></td>
<td>xxx.git local_dir</td>
<td>克隆远程仓库到本地指定目录下</td>
</tr>
<tr>
<td>git clone</td>
<td>-b</td>
<td>new_branch_name <a href="https://xxxxx.git" target="_blank" rel="noopener">https://xxxxx.git</a></td>
<td>clone时创建新的分支替代默认Origin HEAD（master）</td>
</tr>
</tbody>
</table>
<h3 id="配置"><a class="header-anchor" href="#配置"></a>配置</h3>
<table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git config</td>
<td>–system</td>
<td><a href="http://user.name" target="_blank" rel="noopener">user.name</a> “your name”</td>
<td>该系统下，所有用户使用的配置</td>
</tr>
<tr>
<td>git config</td>
<td>–global</td>
<td><a href="http://user.name" target="_blank" rel="noopener">user.name</a> “your name”</td>
<td>该用户下的配置</td>
</tr>
<tr>
<td>git config</td>
<td>–local</td>
<td><a href="http://user.name" target="_blank" rel="noopener">user.name</a> “your name”</td>
<td>该 项目project/仓库repository 下的配置</td>
</tr>
<tr>
<td>git config</td>
<td>–system</td>
<td>user.email <a href="mailto:myemail@gmail.com">myemail@gmail.com</a></td>
<td></td>
</tr>
<tr>
<td>git config</td>
<td>–global</td>
<td>user.email <a href="mailto:myemail@gmail.com">myemail@gmail.com</a></td>
<td></td>
</tr>
<tr>
<td>git config</td>
<td>–local</td>
<td>user.email <a href="mailto:myemail@gmail.com">myemail@gmail.com</a></td>
<td></td>
</tr>
<tr>
<td>git config</td>
<td>–list</td>
<td></td>
<td>查看配置，注意，所处的目录不同，显示的配置信息也不同哦</td>
</tr>
</tbody>
</table>
<h3 id="分支命令"><a class="header-anchor" href="#分支命令"></a>分支命令</h3>
<table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git checkout</td>
<td></td>
<td>dev</td>
<td>切换到dev分支上，也是把dev分支的代码检出到工作区（working tree）</td>
</tr>
<tr>
<td>git checkout</td>
<td></td>
<td>sha1-value</td>
<td>把指定历史版本的代码完整检出到工作区</td>
</tr>
<tr>
<td>git checkout</td>
<td></td>
<td>sha1-value /path/to/file</td>
<td>将指定文件的某个历史版本检出到工作区</td>
</tr>
<tr>
<td>git checkout</td>
<td></td>
<td>sha1-value:/path/to/file new-name</td>
<td>将指定文件的某个历史版本检出到工作区并且修改该文件名</td>
</tr>
<tr>
<td>git checkout</td>
<td>-t</td>
<td>origin/dev</td>
<td>创建本地dev分支(与远程对应分支同名)并换到该分支上，并且设置新分支dev的upstream信息</td>
</tr>
<tr>
<td>git checkout</td>
<td>-b</td>
<td>dev origin/dev</td>
<td>等同于上面命令。从当前分支创建并检出（切换到）新分支的命令。实际上是git checkout -b new-branch-name current-branch 的简写形式，即默认从当前HEAD分支创建新新分支</td>
</tr>
<tr>
<td>git checkout</td>
<td>-b</td>
<td>new-branch-name 172je2</td>
<td>从历史版本为 172je2 上创建新分支并且切换到该分之上</td>
</tr>
<tr>
<td>git checkout</td>
<td>–</td>
<td><file-name></td>
<td>取消对文件的修改,还原到最近的版本,废弃本地做的修改</td>
</tr>
<tr>
<td>git branch</td>
<td>new-branch-name</td>
<td>172je2</td>
<td>从历史版本为 172je2 上创建新分支，但不会切换到该分之上</td>
</tr>
<tr>
<td>git branch</td>
<td>-a</td>
<td></td>
<td>查看所有分支</td>
</tr>
<tr>
<td>git branch</td>
<td>-d</td>
<td>branch_name</td>
<td>删除branch_name分支</td>
</tr>
<tr>
<td>git merge</td>
<td></td>
<td>branch_name</td>
<td>把branch_name分支合并到本分支中（fast-forward模式）</td>
</tr>
<tr>
<td>git merge</td>
<td>–no-ff</td>
<td>branch_name</td>
<td>把branch_name分支合并到本分支中，非fast-forward模式，即会创建一个合并的提交</td>
</tr>
</tbody>
</table>
<h3 id="分支对比"><a class="header-anchor" href="#分支对比"></a>分支对比</h3>
<table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git diff branch1 branch2</td>
<td>–stat</td>
<td></td>
<td>显示出所有有差异的文件列表</td>
</tr>
<tr>
<td>git diff branch1 branch2</td>
<td></td>
<td>文件名(带路径)</td>
<td>显示指定文件的详细差异</td>
</tr>
<tr>
<td>git diff branch1 branch2</td>
<td></td>
<td></td>
<td>显示出所有有差异的文件的详细差异</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1 ^branch-2</td>
<td>查看 branch-1 有，而 branch-2 中没有的 commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-2 ^branch-1</td>
<td>同理 查看 branch-2 有，而 branch-1 中没有的 commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1…branch-2</td>
<td>查看 branch-2 中比 branch-1 中多提交了哪些commit，注意，列出来的是两个点后边（此处即branch-2）比前边（此处即branch-1）多提交的内容。</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-2…branch-1</td>
<td>同理 查看 branch-1 中比 branch-2 中多提交了哪些commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1…branch-2</td>
<td>不知道谁提交的多谁提交的少，单纯想知道有什么不一样，注意三个点</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>–left-right branch-1…branch-2</td>
<td>在上述情况下，再显示出每个提交是在哪个分支上，注意 commit 后面的箭头，根据我们在 --left-right branch-1…branch-2 的顺序，左箭头 &lt; 表示是 branch-1 的，右箭头 &gt; 表示是 branch-2的。</td>
</tr>
</tbody>
</table>
<h3 id="修改commit"><a class="header-anchor" href="#修改commit"></a>修改commit</h3>
<table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git rebase</td>
<td>-i</td>
<td>到哪个旧commit的hash值</td>
<td>注意，该commit是不会被合并的。接着进入交互模式，排第一行的是最旧的commit，除了这一个外，把每个commit前的pick改成squash，就相当于合并到第一行的commit上，接着修改commit信息。</td>
</tr>
</tbody>
</table>
<h2 id="按功能排序"><a class="header-anchor" href="#按功能排序"></a>按功能排序</h2>
<h3 id="取消修改-恢复版本"><a class="header-anchor" href="#取消修改-恢复版本"></a>取消修改,恢复版本</h3>
<p><strong>取消对文件的修改。还原到最近的版本，废弃本地做的修改。</strong><br>
<code>git checkout -- &lt;file&gt;</code></p>
<p><strong>取消已经暂存的文件。即，撤销先前&quot;git add&quot;的操作</strong><br>
<code>git reset HEAD &lt;file&gt;...</code></p>
<p><strong>修改最后一次提交。用于修改上一次的提交信息，或漏提交文件等情况。</strong><br>
<code>git commit --amend</code></p>
<p><strong>回退所有内容到上一个版本</strong><br>
<code>git reset HEAD^</code></p>
<p><strong>回退a.py这个文件的版本到上一个版本</strong><br>
<code>git reset HEAD^ a.py</code></p>
<p><strong>向前回退到第3个版本</strong><br>
<code>git reset –soft HEAD~3</code></p>
<p><strong>将本地的状态回退到和远程的一样</strong><br>
<code>git reset –hard origin/master</code></p>
<p><strong>回退到某个版本</strong><br>
<code>git reset 057d</code></p>
<p><strong>回退到上一次提交的状态，按照某一次的commit完全反向的进行一次commit.(代码回滚到上个版本，并提交git)</strong><br>
<code>git revert HEAD</code></p>
<p><strong>回滚单个文件</strong><br>
<code>git reset sha-1 path/to/file</code><br>
<code>git commit path/to/file -m 'message'</code><br>
<code>git checkout path/to/file</code></p>
<blockquote>
<p>几点说明：</p>
</blockquote>
<ul>
<li>一次commit是指当你输入git log是，看到的一串码，如commit e7d1b777de790970af704dbeac8c0ef3d21335b4，这算一次commit</li>
</ul>
<p>[<a href="https://www.pureweber.com/article/git-pretty-output/" target="_blank" rel="noopener">https://www.pureweber.com/article/git-pretty-output/</a>]</p>
]]></content>
    
    <summary type="html">
    
      本文持续更新中…
    
    </summary>
    
      <category term="CVS" scheme="https://gingjan.com/categories/CVS/"/>
    
      <category term="Git" scheme="https://gingjan.com/categories/CVS/Git/"/>
    
      <category term="Git命令" scheme="https://gingjan.com/categories/CVS/Git/Git%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Git" scheme="https://gingjan.com/tags/Git/"/>
    
      <category term="CVS" scheme="https://gingjan.com/tags/CVS/"/>
    
  </entry>
  
  <entry>
    <title>同步编程与异步编程的转换和对比</title>
    <link href="https://gingjan.com/2016/05/24/sync-vs-async-and-they-transfers/"/>
    <id>https://gingjan.com/2016/05/24/sync-vs-async-and-they-transfers/</id>
    <published>2016-05-23T18:38:42.000Z</published>
    <updated>2020-10-05T09:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>** 同步转换异步 **： 本文介绍了nodejs下的同步模型转换成异步模型（异步代码的设计）</p>
<a id="more"></a>
<h2 id="开始转变思路"><a class="header-anchor" href="#开始转变思路"></a>开始转变思路</h2>
<p>这里转变思路是指由同步模型代码转换成异步模型代码<br>
要使用Node.js，就有必要了解异步编程的工作原理。异步代码设计并非简单的设计，需要一番学习。本文在同步代码示例旁边给出了异步代码示例，表明如何更改同步代码，才能变成异步代码。这些示例都围绕Node.js的文件系统(fs)模块，因为它是唯一含有同步I/O操作及异步I/O操作的模块。有了这两种示例，你可以开始转变思路了。</p>
<hr>
<h2 id="相关代码和独立代码"><a class="header-anchor" href="#相关代码和独立代码"></a>相关代码和独立代码</h2>
<p>回调函数(callback function)是Node.js中异步事件驱动型编程的基本构建模块。它们是作为变量，传递给异步I/O操作的函数。一旦操作完成，回调函数就被调用。回调函数是Node.js中实现事件的机制。<br>
下面显示的示例表明了如何将同步I/O操作转换成异步I/O操作，并显示了回调函数的使用。示例使用异步fs.readdirSync()调用，读取当前目录的文件名称，然后把文件名称记录到控制台，最后读取当前进程的进程编号(process id)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*相关代码和独立代码*/</span></span><br><span class="line">    <span class="comment">//任务：读取当前目录下的所有文件名称。并获取当前进程的编号pid</span></span><br><span class="line">    <span class="comment">//对任务的分析：因为读取文件名称 和 获取当前进程pid 是两件无关联的独立事情，所以如果要在一份代码中完成这两任务，可以考虑对它们进行异步处理</span></span><br><span class="line"><span class="comment">//同步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),filenames,i,processId;</span><br><span class="line"><span class="comment">//1、读取当前目录下的文件名称</span></span><br><span class="line">filenames = fs.readdirSync(<span class="string">'.'</span>);<span class="comment">//处理器等待该处的IO操作，所以此处需要改成异步fs.readdir()</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; filenames.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(filenames[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到此，都是做了同一件事，就是读取文件名称并且显示在控制台上。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ready"</span>);</span><br><span class="line"><span class="comment">//2、获取当前进程的pid</span></span><br><span class="line">processId = process.getuid();<span class="comment">//因为是同步模式，所以要在上面readdirSync执行完后才会执行此行代码。</span></span><br><span class="line"><span class="comment">//异步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>), filenames, i, processId;</span><br><span class="line"><span class="comment">//1、读取当前目录下的文件名称</span></span><br><span class="line">fs.readdir(<span class="string">'.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, filenames</span>) </span>&#123;<span class="comment">//第二个参数为回调，因为这里是异步模式，而跟任务1有关的一系列操作都放到回调里面，因为当读取完成后，相关联的一系列操作将会被回调，执行。</span></span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;filenames.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(filenames[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ready'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//2、获取当前进程的pid</span></span><br><span class="line">processId = process.getuid();<span class="comment">//因为是异步模式，所以当上面readdir被调用后，不用等待它执行完毕，就马上执行此行代码。这就是异步模式</span></span><br></pre></td></tr></table></figure>
<p>在同步示例中，处理器等待fs.readdirSync() I/O操作，所以这是需要更改的操作。Node.js中该函数的异步版本是fs.readdir()。它与fs.readdirSync()一样，但是回调函数作为第二个参数。<br>
使用回调函数模式的规则如下：把同步函数换成对应的异步函数，然后把原先在同步调用后执行的代码放在回调函数里面。回调函数中的代码与同步示例中的代码执行一模一样的操作。它把文件名称记录到控制台。它在异步I/O操作返回之后执行。<br>
就像文件名称的记录依赖fs.readdirSync() I/O操作的结果，所列文件数量的记录也依赖其结果。进程编号的存储独立于I/O操作的结果。因而，必须把它们移到异步代码中的不同位置。<br>
规则就是将相关代码移到回调函数中，而独立代码的位置不用管。一旦I/O操作完成，相关代码就被执行，而独立代码在I/O操作被调用之后立即执行。</p>
<hr>
<h2 id="对顺序要求严格的任务"><a class="header-anchor" href="#对顺序要求严格的任务"></a>对顺序要求严格的任务</h2>
<p>同步代码中的标准模式是线性顺序：几行代码都必须下一行接上一行来执行，因为每一行代码依赖上一行代码的结果。在下面示例中，代码首先变更了文件的访问模式(比如Unix chmod命令)，对文件更名，然后检查更名后文件是不是符号链接。很显然，该代码无法乱序运行，不然文件在模式变更前就被更名了，或者符号链接检查在文件被更名前就执行了。这两种情况都会导致出错。因而，顺序必须予以保留。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序严格的任务*/</span></span><br><span class="line"><span class="comment">//任务：1、修改文件的访问权限。2、然后对文件改名。3、然后检查更名后的文件是不是符号链接(symlink也即Linux里的软连接)。</span></span><br><span class="line"><span class="comment">//对任务的分析：很显然，该任务无法乱序运行，不然文件在访问权限变更前就被改名了，或者对符号链接的检查在文件被更名前就执行了。这两种情况都会导致出错。因而，顺序完成这两任务是必须予以保留的。</span></span><br><span class="line"><span class="comment">//同步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>), oldFilename, newFilename, isSymLink;</span><br><span class="line">oldFilename = <span class="string">'./processId.txt'</span>;</span><br><span class="line">newFilename = <span class="string">'./processIdOld.txt'</span>;</span><br><span class="line">fs.chmodSync(oldFilename, <span class="number">777</span>);</span><br><span class="line">fs.renameSync(oldFilename, newFilename);</span><br><span class="line">isSymLink = fs.lstatSync(newFilename).isSymbolicLink();</span><br><span class="line"><span class="comment">//异步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>), oldFilename, newFilename, isSymLink;</span><br><span class="line">oldFilename = <span class="string">'./processId.txt'</span>;</span><br><span class="line">newFilename = <span class="string">'./processIdOld.txt'</span>;</span><br><span class="line">fs.chmod(oldFilename, <span class="number">777</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;<span class="comment">//虽然这里是采用了异步处理，但是因为这些任务都是需要顺序处理才不会出错，因为在回调里嵌套回调，这里才能保证异步模式下顺序处理这种顺序任务</span></span><br><span class="line">    fs.rename(oldFilename, newFilename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        fs.lstat(newFilename, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> isSymLink = stats.isSymbolicLink();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在异步代码中，这些顺序变成了嵌套回调。该示例显示了fs.lstat()回调嵌套在fs.rename()回调里面，而fs.rename()回调嵌套在fs.chmod()回调里面。</p>
<hr>
<h2 id="并行处理"><a class="header-anchor" href="#并行处理"></a>并行处理</h2>
<p>异步代码特别适合操作I/O操作的并行处理：代码的执行并不因I/O调用的返回而受阻。多个I/O操作可以并行开始。在下面示例中，某个目录中所有文件的大小都在循环中累加，以获得那些文件占用的总字节数。使用异步代码，循环的每次迭代都必须等到获取单个文件大小的I/O调用返回为止。<br>
异步代码允许快速连续地在循环中开始所有I/O调用，不用等结果返回。只要其中一个I/O操作完成，回调函数就被调用，而该文件的大小就可以添加到总字节数中。<br>
唯一必不可少的有一个恰当的停止标准，它决定着我们完成处理后，就计算所有文件的总字节数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*并行处理*/</span></span><br><span class="line"><span class="comment">//任务：1、获取当前目录下所用文件的大小。2、然后统计所有文件的总大小</span></span><br><span class="line"><span class="comment">//分析：因为需要首先知道每个文件的大小，而对每个文件的大小的获取是独立的，因此可以使用异步模式来同时读取多个文件的大小，最后需要设置一个标志用以告诉所有文件(最后一个文件)的大小都已经获取到并且总大小已经统计完成了，可以输出到控制台。</span></span><br><span class="line"><span class="comment">//同步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateByteSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalBytes = <span class="number">0</span>, i, filenames, stats;</span><br><span class="line">    filenames = fs.readdirSync(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;filenames.length;i++) &#123;</span><br><span class="line">        stat = fs.statSync(<span class="string">'./'</span> + filenames[i]);<span class="comment">//同步，这样下一个文件大小的获取需要等到本轮读取该文件大小完成才能进行。</span></span><br><span class="line">        totalBytes += stats.size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(totalBytes);</span><br><span class="line">&#125;</span><br><span class="line">calculateByteSize();<span class="comment">//等到里面全部操作(都是同步操作)都执行完毕，函数才返回（结束）【同步】</span></span><br><span class="line"><span class="comment">//异步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">totalBytes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateByteSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readdir(<span class="string">'.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, filenames</span>) </span>&#123;<span class="comment">//引申出的一个问题，在一个函数内调用一个异步操作，那么是异步操作全部完成后该函数才结束，还是函数先结束，但是异步操作依然还在运行？</span></span><br><span class="line">        <span class="keyword">var</span> i;</span><br><span class="line">        count = filenames.length;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;filenames.length;i++) &#123;</span><br><span class="line">            fs.stat(<span class="string">'./'</span>+filenames[i], <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;<span class="comment">//调用fs.stat()了就马上继续下一轮循环，不等待该轮执行完成。这样就可以多个文件同时进行大小的获取。</span></span><br><span class="line">                totalBytes += stats.size;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(totalBytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">calculateByteSize();<span class="comment">//就此例而言，该函数被调用后就马上结束了。而里面的操作(都是异步操作)还在运行中【异步】。至于为什么函数结束后，里面的变量还能用，这就涉及到了闭包的知识点了</span></span><br></pre></td></tr></table></figure>
<p>同步示例简单又直观。在异步版本中，第一个fs.readdir()被调用，以读取目录中的文件名称。在回调函数中，针对每个文件调用fs.stat()，返回该文件的统计信息。这部分不出所料。</p>
<p>值得关注的方面出现在计算总字节数的fs.stat()回调函数中。所用的停止标准是目录的文件数量。变量count以文件数量来初始化，倒计数回调函数执行的次数。一旦数量为0，所有I/O操作都被回调，所有文件的总字节数被计算出来。计算完毕后，字节数可以记录到控制台。</p>
<p>异步示例有另一个值得关注的特性：它使用闭包(closure)。闭包是函数里面的函数，内层函数访问外层函数中声明的变量，即便在外层函数已完成之后。fs.stat()回调函数是闭包，因为它早在fs.readdir()回调函数完成后，访问在该函数中声明的count和totalBytes这两个变量。闭包有关于它自己的上下文。在该上下文中，可以放置在函数中访问的变量。</p>
<p>要是没有闭包，count和totalBytes这两个变量都必须是全局变量。这是由于fs.stat()回调函数没有放置变量的任何上下文。calculateBiteSize()函数早已结束，只有全局上下文仍在那里。这时候闭包就能派得上用场。变量可以放在该上下文中，那样可以从函数里面访问它们。</p>
<hr>
<h2 id="代码复用"><a class="header-anchor" href="#代码复用"></a>代码复用</h2>
<p>代码片段可以在JavaScript中复用，只要把代码片段包在函数里面。然后，可以从程序中的不同位置调用这些函数。如果函数中使用了I/O操作，那么改成异步代码时，就需要某种重构。</p>
<p>下面的异步示例显示了返回某个目录中文件数量的函数countFiles()。countFiles()使用I/O操作fs.readdirSync() 来确定文件数量。span&gt;countFiles()本身被调用，使用两个不同的输入参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*代码复用*/</span></span><br><span class="line"><span class="comment">//任务：1、返回某个目录中文件数量</span></span><br><span class="line"><span class="comment">//同步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path1 = <span class="string">'./'</span>, path2 = <span class="string">'.././'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countFiles</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> filenames = fs.readdirSync(path);<span class="comment">//同步方式获取目录下所有文件</span></span><br><span class="line">    <span class="keyword">return</span> filenames.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(countFiles(path1)+<span class="string">'files in '</span> + path1);</span><br><span class="line"><span class="built_in">console</span>.log(countFiles(path2)+<span class="string">'files in '</span> + path2);</span><br><span class="line"><span class="comment">//异步</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path1 = <span class="string">'./'</span>, path2 = <span class="string">'.././'</span>, logCount;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countFiles</span>(<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">    fs.readdir(path, <span class="function"><span class="keyword">function</span> (<span class="params">err, filenames</span>) </span>&#123;</span><br><span class="line">        callback(err, path, filenames.length);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">logCount = <span class="function"><span class="keyword">function</span>(<span class="params">err, path, count</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">'files in '</span>+ path);</span><br><span class="line">&#125;;</span><br><span class="line">countFiles(path1, logCount);<span class="comment">//若这里依然是使用console.log去调用countFiles，因为countFiles是异步的，等到countFiles处理完毕返回值的时候，console.log已经结束运行了(因为countFile是异步的，所以console.log调用了countFiles之后就马上结束而不等待countFiles返回结果了)。所以是由conutFiles去调用console.log。于是把log放进异步的回调函数里才可以</span></span><br><span class="line">countFiles(path2, logCount);</span><br></pre></td></tr></table></figure>
<p>把fs.readdirSync()换成异步fs.readdir()迫使闭包函数countFiles()也变成异步，因为调用countFiles()的代码依赖该函数的结果。毕竟，只有fs.readdir()返回后，结果才会出现。这导致了countFiles()重构，以便还能接受回调函数。整个控制流程突然倒过来了：不是console.log()调用countiles()，countFiles()再调用fs.readdirSync()，在异步示例中，而是countFiles()调用fs.readdir()，然后countFiles()再调用console.log()。</p>
<hr>
<h2 id="结束语"><a class="header-anchor" href="#结束语"></a>结束语</h2>
<p>本文着重介绍了异步编程的一些基本模式。将思路转变到异步编程绝非易事，需要一段时间来适应。虽然难度增加了，但是获得的回报是显著提高了并发性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** 同步转换异步 **： 本文介绍了nodejs下的同步模型转换成异步模型（异步代码的设计）&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="NodeJS" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/NodeJS/"/>
    
      <category term="基础" scheme="https://gingjan.com/categories/%E5%89%8D%E7%AB%AF/NodeJS/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="NodeJS" scheme="https://gingjan.com/tags/NodeJS/"/>
    
  </entry>
  
</feed>
