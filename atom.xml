<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GingJan&#39;s Blog</title>
  <subtitle>放弃幻想 准备斗争</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gingjan.com/"/>
  <updated>2020-05-19T09:39:19.000Z</updated>
  <id>http://gingjan.com/</id>
  
  <author>
    <name>GingJan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker run命令里 --name 和 --hostname的区别</title>
    <link href="http://gingjan.com/2020/05/19/difference-between-name-and-hostname-in-docker-run-command/"/>
    <id>http://gingjan.com/2020/05/19/difference-between-name-and-hostname-in-docker-run-command/</id>
    <published>2020-05-19T08:05:22.000Z</published>
    <updated>2020-05-19T09:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　都是name,乱得一批<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>在使用<code>docker run</code>命令创建容器时,会分配一个UUID作为容器的id,但是这个id太长而且太难记忆,于是可以使用<code>--name</code>参数指定一个名字给该容器.<br>同样,当容器创建后,hostname默认也为该UUID,但可以使用<code>--hostname</code>将它重写为更好记的名字</p>
<p>现在考虑以下场景,在代码里,你要访问docker的某个容器,但因为容器的id是在创建容器时生成的并且很难使用,因此为该容器指定了一个name以便外界调用该容器.<br>那么hostname是在什么场景使用呢?<br>当你容器内的应用需要指定的hostname时,此时<code>--hostname</code>就派上用场,它只会更改容器内部的hostname,但不会更该docker容器外的DNS,也不会更改网络隔离的信息,所以外部是无法使用hostname访问该容器</p>
<p>所以,当有两个在同一网络下(且该网络是非默认bridge模式的),要使用name或id在docker内嵌的DNS下访问对方.</p>
<p>总结:容器与容器之间的访问要用name或id,而容器内部应用之间的访问,需要再带上hostname(即在单个容器内部,应用之间使用hostname访问.那多个容器之间,各容器之间的内部应用需要访问是否将name和hostname带上就能了呢?有待验证)</p>
<p>hostname的作用还有待进一步探讨</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　都是name,乱得一批&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://gingjan.com/categories/docker/"/>
    
      <category term="命令参数" scheme="http://gingjan.com/categories/docker/%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/"/>
    
    
      <category term="命令" scheme="http://gingjan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="docker" scheme="http://gingjan.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Go之类型与传递</title>
    <link href="http://gingjan.com/2020/05/06/go-type/"/>
    <id>http://gingjan.com/2020/05/06/go-type/</id>
    <published>2020-05-06T06:03:29.000Z</published>
    <updated>2020-05-19T07:42:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　Go各类型在传递时的区别<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>首先从两个角度方向思考,类型和传递</p>
<p>从类型角度，类型可分为值类型和引用类型，一般而言，我们说到引用，强调的都是类型。</p>
<p>从传递角度，有值传递、址传递、引用传递，传递是在函数调用时才会提到的概念，用于表明实参与形参的关系。</p>
<p>在程序运行的时候，操作系统会为每个变量分配一块内存放变量内容，而这块内存有一个编号，即内存地址，也就是变量的地址。现在 CPU 一般都是 64 位，因而，这个地址的长度一般也就是 8 个字节。</p>
<p>谈到引用就得说指针，指针即地址。引用，某块内存的别名。引用代指某个内存地址</p>
<p>除了指针和引用，还有另外一个更广泛的概念，值。</p>
<p>谈变量传递时，常会提到值传递、址传递和引用传递。从广义上看，对大部分的语言而言，指针和引用都属于值。而从狭义角度来说，则可分为值、址和引用。</p>
<p>小结:<br>类型: 引用类型、指针类型、值类型【Go总共就两种类型，引用类型和值类型，这里为了讨论才把指针类型挑出来】<br>引用类型是某种结构体,该结构体里有指针类型的字段,属于复合类型<br>指针类型是存其他变量地址的「特殊值类型」,属于复合类型<br>值类型是最广泛的概念<br>ps：值类型有：int、float、bool、string等基础类型【使用这些类型的变量直接指向存在内存中的值：】，array、struct复合类型<br>引用类型有：指针、slice、map、channel</p>
<p>传递: 引用传递、址传递、值传递<br>引用传递是实参与形参的地址都一致<br>址传递是特殊的值传递,即传的是地址<br>ps:Go中无论什么类型,一切传递都是值传递(即复制一个副本给形参)</p>
<p>slice、map、chan都是引用类型,因为在Go里一切传递都是值传递,因此它们都是值传递(这可通过判断实参形参地址是否一致来判定,若是实参形参的地址一致即为引用传递)<br>其实就是传递的时候全部类型都是copy一份，就算传递的是指针(地址)，那也是把这个指针(地址)copy了，但是指针指向的对象是同一个，所以形参的修改是有效的<br>ps: C++ 传递的引用其实就是指针的拷贝，而 go 传递的是指针上层结构体的拷贝(如slice)。</p>
<p>引用类型、指针类型、值类型<br>值类型:布尔型、整型、浮点型、字符型、字符串型、数组、结构体【常会通过「&amp;」取地址，在方法函数间传递可以避免拷贝,使用new创建+初始化,返回的是对应类型的指针】<br>引用类型:slice、channel、接口、map、函数、指针(特殊)【其实所谓的引用类型本质就是结构体构建的数据类型】【一般不涉及取址操作，当然，它们本质是一个结构体，其中的指针类型成员指向了真正的内容，使用make创建+初始化,返回的是make时指定的类型实例】<br>值类型的特点是：变量直接存储值，内存通常在栈中分配<br>引用类型的特点是：变量存储的是一个地址，这个地址指向的内存里才是真正存储的值，内存通常在堆中分配</p>
<p>基础类型:布尔型、整型、浮点型、复数型【complex128(2+3i)】、字符型、字符串型、错误类型<br>复合类型/派生类型:指针、数组、slice、map、channel、struct、接口、函数<br>Go的复合类型是基础类型的组合</p>
<p>传入map、chan到函数里<br>func modify(m map)这样的函数，等价于func modify(p <em>hmap)<br>func modify(c chan)这样的函数，等价于func modify(p </em>hchan)<br>特殊的slice<br>当把slice传入函数时，对形参slice的修改只能修改到与实参slice的同一指向的底层数组，而无法修改len和cap（因为形参只是实参的副本），若要修改len和cap，则需要把slice的指针传入函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)  <span class="comment">//第一个参数表示存储类型,第二个表示存储数组长度,第三个是指如果数组最大长度,如果长度超出10,他就会翻倍,分配一个长度20的内存块,如果不设置,最大容量就是数组长度</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(s))</span><br><span class="line">	test(s)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%p"</span>, &amp;s)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%p"</span>, &amp;s)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	s[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(s))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考文章:<br>《一文理清 Go 引用的常见疑惑》<a href="https://juejin.im/post/5d8f05b55188254a371f1a77">https://juejin.im/post/5d8f05b55188254a371f1a77</a><br>《Go语言参数传递是传值还是传引用》<a href="https://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html">https://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Go各类型在传递时的区别&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="后端语言" scheme="http://gingjan.com/categories/%E5%90%8E%E7%AB%AF%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Go" scheme="http://gingjan.com/categories/%E5%90%8E%E7%AB%AF%E8%AF%AD%E8%A8%80/Go/"/>
    
      <category term="基础" scheme="http://gingjan.com/categories/%E5%90%8E%E7%AB%AF%E8%AF%AD%E8%A8%80/Go/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Go" scheme="http://gingjan.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>顺时针螺旋原则</title>
    <link href="http://gingjan.com/2020/05/01/clockwise-rule/"/>
    <id>http://gingjan.com/2020/05/01/clockwise-rule/</id>
    <published>2020-05-01T02:00:00.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文主要讲解何为顺时针螺旋原则<br>    <Excerpt in index | 首页摘要></p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>基于顺时针螺旋原则，C可以解析复杂的类型声明<br>按照以下三个步骤:</p>
<ol>
<li>从变量名开始,沿着顺时针方向(变量名处向上走),从第一个类型声明符号开始,当遇到下一个类型声明符号则使用对应的自然语言描述它:<br><code>[X]</code> or <code>[]</code><br>=&gt; [^Array X size of… or Array undefined size of…]<br>[^Array X size of… or Array undefined size of…]:(数组 大小为 X 的… or 数组 大小为 未知 的…)<br><code>(type1, type2)</code><br>=&gt; <code>function passing type1 and type2 returning... (函数 传入 type1 和 type2 返回...)</code><br><code>*</code><br>=&gt; <code>pointer(s) to... (指针 指向...)</code></li>
<li>继续沿着顺时针方向使用自然语言描述对应声明符号直到所有符号描述成为止</li>
<li>圆括号<code>()</code>内的符号要先描述</li>
</ol>
<p>示例1:简单声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     +-------+</span><br><span class="line">     | +-+   |</span><br><span class="line">     | ^ |   |</span><br><span class="line">char *str[10];</span><br><span class="line"> ^   ^   |   |</span><br><span class="line"> |   +---+   |</span><br><span class="line"> +-----------+</span><br></pre></td></tr></table></figure><br>首先问,变量<code>str</code>是什么<br><code>str is an... (变量str 是一个 ...)</code></p>
<ul>
<li>从变量名<code>str</code>开始沿着顺时针方向(向上)走,遇到第一个字符是<code>[</code>,即有数组,所以:<br><code>str is an array 10 of... (变量str 是一个数组大小为10的..).</code></li>
<li>继续沿着顺时针方向,下一个遇到的字符是<code>*</code>,即有指针,所以:<br><code>str is an array 10 of pointers to... (变量str 是一个数组大小为10的指针...)</code></li>
<li>继续沿着顺时针方向,下一个遇到的字符是本行结束符<code>;</code>,so跳过,下一个是<code>char</code>:<br><code>str is an array 10 of pointers to char (变量str 是一个数组大小为10的指针指向char类型)</code></li>
<li>现在每个字符都遍历了,因此完结</li>
</ul>
<p>示例2:指向函数的指针的声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     +--------------------+</span><br><span class="line">     | +---+              |</span><br><span class="line">     | |+-+|              |</span><br><span class="line">     | |^ ||              |</span><br><span class="line">char *(*fp)( int, float *);</span><br><span class="line"> ^   ^ ^  ||              |</span><br><span class="line"> |   | +--+|              |</span><br><span class="line"> |   +-----+              |</span><br><span class="line"> +------------------------+</span><br></pre></td></tr></table></figure><br>首先问,变量<code>fp</code>是什么?<br><code>fp is a... (fp是...)</code></p>
<ul>
<li>从fp开始,沿着顺时针方向(向上)遇到的第一个是<code>)</code>;因此<code>fp</code>是在圆括号<code>()</code>内的,所以在圆括号内以顺时针螺旋方式继续,下一个是<code>*</code>:<br><code>fp is a pointer to... (fp是一个指针指向...)</code></li>
<li>继续,出了圆括号范围后看到的是<code>(</code>,也即有函数:<br><code>fp is a pointer to a function passing an int and a pointer to float returning... (fp是一个指针指向函数,该函数传入int类型和指向float的指针类型)</code></li>
<li>继续,下个是<code>*</code>:<br><code>fp is a pointer to a function passing an int and a pointer to float returning a pointer to... (fp是一个指针指向函数,该函数传入int类型和指向float的指针类型并返回一个指针)</code></li>
<li>继续,下个是<code>;</code>,虽然到了行结束符,但还没有遍历完全部声明符号,因此继续并最后遇到<code>char</code>:<br><code>fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char ((fp是一个指针指向函数,该函数传入int类型和指向float的指针类型并返回一个指针,该指针指向char类型)</code></li>
</ul>
<p>示例3:「究极版」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      +-----------------------------+</span><br><span class="line">      |                  +---+      |</span><br><span class="line">      |  +---+           |+-+|      |</span><br><span class="line">      |  ^   |           |^ ||      |</span><br><span class="line">void (*signal(int, void (*fp)(int)))(int);</span><br><span class="line"> ^    ^      |      ^    ^  ||      |</span><br><span class="line"> |    +------+      |    +--+|      |</span><br><span class="line"> |                  +--------+      |</span><br><span class="line"> +----------------------------------+</span><br></pre></td></tr></table></figure><br>首先问,signal是?<br>注意signal是在圆括号内的,所以先描述</p>
<ul>
<li>从signal按照顺时针方式先向上走,遇到<code>(</code>:<br><code>signal is a function passing an int and a...</code></li>
<li>以同样方式从fp开始,遇到的第一个字符是<code>)</code>即fp在圆括号内,所以继续,下一个是<code>*</code>:<br><code>fp is a pointer to... (fp是一个指针指向)</code></li>
<li>继续顺时针螺旋方向遇到的下一个字符是<code>)</code>:<br><code>fp is a pointer to a function passing int returning... fp是一个指针,指向一个函数,该函数传入int返回...</code></li>
<li>继续遇到的是<code>void</code>关键字:<br><code>fp is a pointer to a function passing [int] returning [void] fp是一个指针,指向一个函数,该函数传入int返回void</code></li>
<li>到此完成了围绕<code>变量fp</code>声明的字符的描述,现在回到<code>变量signal</code>:<br><code>signal is a function passing {an int and a pointer to a function passing [an int] returning [void]} returning {...}</code></li>
<li>接着下一个字符是<code>*</code><br><code>signal is a function passing {an int and a pointer to a function passing [an int] returning [void]} returning {a pointer to...}</code></li>
<li>现在圆括号内的字符都描述完毕,继续下一个字符是<code>(</code><br><code>signal is a function passing {an int and a pointer to a function passing [an int] returning [void]} returning {a pointer to a function passing [an int] returning [...]}</code></li>
<li>继续,最后一个字符是<code>void</code>,所以最后signal的描述/定义是:<br><code>signal is a function passing {an int and a pointer to a function passing [an int] returning [void]} returning {a pointer to a function passing [an int] returning [void]}</code></li>
</ul>
<p>同样,该原则可以应用到const常量和volatile:</p>
<p>示例4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *chptr;</span><br></pre></td></tr></table></figure><br>chptr是什么? <code>chptr is a pointer to a char constant. chptr是一个指针,指向char常量</code></p>
<p>示例5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * const chptr;</span><br></pre></td></tr></table></figure><br>chptr是什么? <code>chptr is a constant pointer to char. chptr是一个常量指针,指向char</code></p>
<p>示例6:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile char * const chptr;</span><br></pre></td></tr></table></figure><br>chptr是什么? <code>chptr is a constant pointer to a char volatile. chptr是一个常量指针,指向char volatile</code></p>
<p>欢迎转载但请附上原文链接，谢谢。</p>
<p>参考:</p>
<p><a href="http://c-faq.com/decl/spiral.anderson.html">The Clockwise/Spiral Rule 顺时针螺旋原则</a></p>
<p>搭配食用:</p>
<p><a href="https://blog.go-zh.org/gos-declaration-syntax">Go’s Declaration Syntax</a></p>
<p>如有错误，欢迎指出、讨论，大家共同进步 ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文主要讲解何为顺时针螺旋原则&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="代码之上" scheme="http://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="原则" scheme="http://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="原则" scheme="http://gingjan.com/tags/%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Laravel-自动发现扩展包</title>
    <link href="http://gingjan.com/2019/09/24/laravels-package-auto-discovery/"/>
    <id>http://gingjan.com/2019/09/24/laravels-package-auto-discovery/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文主要讲解Laravel如果基于Composer实现自动发现扩展包<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>Laravel附带了一个composer.json文件,当一些Laravel包被拉取到本地后,还需要几步手动配置使之能在Laravel项目中使用</p>
<ul>
<li>注册 Service Provider</li>
<li>注册 Alias或Facade</li>
<li>发布 asset<br>第一、二步已被 Taylor Otwell 确认有点繁琐,因此联合 Dries Vints 开发并推出了「自动注册 Service Provider 和 Facade」功能</li>
</ul>
<p>在搜索并安装/更新不同的扩展包时,Composer会触发多个事件,这些事件可供订阅,一旦订阅的事件被触发,可调起一段自定义的代码或一条可执行的命令行.<br>当Composer生成最终的类加载文件.其中一个名为 post-autoload-dump 的事件将会被触发.而后,Laravel已可访问所有类并且项目可使用这些类了</p>
<p>之所以会这样,是因为Laravel在composer.json文件里订阅了 post-autoload-dump 事件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"post-autoload-dump"</span>: [</span><br><span class="line">        <span class="string">"Illuminate\\Foundation\\ComposerScripts::postAutoloadDump"</span>,</span><br><span class="line">        <span class="string">"@php artisan package:discover"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先,调起postAutoloadDump方法,该方法负责清除之前缓存的services和包.然后运行 package:discover 命令,这是关键所在</p>
<p>找寻扩展包<br><code>Illuminate\Foundation\Console\PackageDiscoverCommand</code> 调用 <code>Illuminate\Foundation\PackageManifest</code> 类的 <code>build()</code> 方法. <code>PackageManifest</code> 类里包含 Laravel自动找寻已安装包 的实现<br><code>PackageManifest</code> 类在应用启动时就被注册入容器里了(是在 <code>Illuminate\Foundation\Application::registerBaseServiceProviders()</code> 里注册)</p>
<p>在 <code>build()</code> 方法内,Laravel会去寻找 <code>vendor/composer/installed.json</code> 文件(该文件由composer生成),Laravel会映射这个文件的内容并且递归搜索含有 <code>extra.laravel</code> 的包<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"extra"</span>: &#123;</span><br><span class="line">    <span class="string">"laravel"</span>: &#123;</span><br><span class="line">        <span class="string">"providers"</span>: [</span><br><span class="line">            <span class="string">"Barryvdh\\Debugbar\\ServiceProvider"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"aliases"</span>: &#123;</span><br><span class="line">            <span class="string">"Debugbar"</span>: <span class="string">"Barryvdh\\Debugbar\\Facade"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后搜索 <code>composer.json</code> 文件的 <code>extra.laravel.dont-discover</code> 区段来判断是否有指定无需自动发现的包<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"extra"</span>: &#123;</span><br><span class="line">    <span class="string">"laravel"</span>: &#123;</span><br><span class="line">        <span class="string">"dont-discover"</span>: [</span><br><span class="line">            <span class="string">"barryvdh/laravel-debugbar"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以添加 <code>*</code> 到数组区段里来告诉laravel不执行自动发现</p>
<p>至此,laravel已经收集好了有关扩展包的信息.接下来是把这些信息写入到 <code>bootstrap/cache/packages.php</code> 文件<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">return</span> <span class="keyword">array</span> (</span><br><span class="line">  <span class="string">'barryvdh/laravel-debugbar'</span> =&gt;</span><br><span class="line">  <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'providers'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">      <span class="number">0</span> =&gt; <span class="string">'Barryvdh\\Debugbar\\ServiceProvider'</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'aliases'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">      <span class="string">'Debugbar'</span> =&gt; <span class="string">'Barryvdh\\Debugbar\\Facade'</span>,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>注册扩展包<br>当Laravel Kernel启动时,会有两个 <code>bootstrapper启动器</code> 会被调用到</p>
<ul>
<li><code>\Illuminate\Foundation\Bootstrap\RegisterFacades</code></li>
<li><code>\Illuminate\Foundation\Bootstrap\RegisterProviders</code></li>
</ul>
<p>第一个使用 <code>Illuminate\Foundation\AliasLoader</code> 将所有 <code>Facade</code> 加载到容器里,现在唯一不同的是laravel会把 <code>packages.php</code> 里需要加载的 <code>aliases</code> 都一并加载到容器.(使用 <code>PackageManifest::aliases()</code> 方法来收集这些信息)<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in RegisterFacades::bootstrap()</span></span><br><span class="line">AliasLoader::getInstance(array_merge(</span><br><span class="line">    $app-&gt;make(<span class="string">'config'</span>)-&gt;get(<span class="string">'app.aliases'</span>, []),</span><br><span class="line">    $app-&gt;make(PackageManifest::class)-&gt;aliases()</span><br><span class="line">))-&gt;register();</span><br></pre></td></tr></table></figure></p>
<p>如上所示,<code>config/app.php</code> 里配置的 <code>aliases</code> 和 <code>PackageManifest类</code> 的 <code>aliases</code> 合并到一起.</p>
<p>相似地,<code>Service Provider</code> 也是这样注册. <code>RegisterProviders</code> 启动器调用 <code>Foundation\Application::registerConfiguredProviders()</code> 把Laravel从所有扩展包中收集的 <code>Service Provider</code> 注册入容器<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$providers = Collection::make(<span class="keyword">$this</span>-&gt;config[<span class="string">'app.providers'</span>])</span><br><span class="line">                -&gt;partition(<span class="function"><span class="keyword">function</span> <span class="params">($provider)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Str::startsWith($provider, <span class="string">'Illuminate\\'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">$providers-&gt;splice(<span class="number">1</span>, <span class="number">0</span>, [<span class="keyword">$this</span>-&gt;make(PackageManifest::class)-&gt;providers()]);</span><br></pre></td></tr></table></figure></p>
<p>欢迎转载但请附上链接，谢谢。</p>
<p><a href="https://divinglaravel.com/laravels-package-auto-discovery">原文：laravels-package-auto-discovery</a></p>
<p>如有什么错误，欢迎提出、讨论，大家共同进步 ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文主要讲解Laravel如果基于Composer实现自动发现扩展包&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Laravel" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Laravel/"/>
    
    
      <category term="PHP" scheme="http://gingjan.com/tags/PHP/"/>
    
      <category term="框架" scheme="http://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Laravel" scheme="http://gingjan.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>如何选择AES加密模式(CBC、ECB、CTR、OCB、CFB)</title>
    <link href="http://gingjan.com/2018/08/12/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb/"/>
    <id>http://gingjan.com/2018/08/12/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb/</id>
    <published>2018-08-12T03:39:41.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　如果加密的数据块超过 1 block则不要选择ECB模式<br>    <Excerpt in index | 首页摘要></p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>如果加密的数据块超过 1 block则不要选择ECB模式</p>
<p>CBC, OFB 和 CFB 模式很相似,然而如果你只是要加密而不需要解密,则选择OFB或CFB更合适,因为这两种模式可以节约空间</p>
<p>如果需要更快的加密速度(并行加密),选择CTR 而不是 CBC/OFB/CFB.</p>
<p>如果需要 对随机访问介质内的数据(如磁盘或内存中的数据)进行加密,选择XTS模式更合适</p>
<p>OCB是目前为止最好的模式,因为它可以一次性对数据进行加密和验证,然后在美国该模式是需要专利授权的</p>
<p>ECB 很少使用到除非只是加密1个数据块.如果是加密磁盘或内存的数据而不是stream(stream是一段一段的),XTS应该更适合你</p>
<p>每次加密时都要使用唯一且随机的IV(init vector,初始化向量),如果你无法保证随机性,则使用OCB模式,因为它只需要传入nonce而无需传入IV,IV和nonce这两个有点不同,如果被人猜到下一个nonce是不会导致安全问题,而被人猜到下一个IV则会导致安全问题(因为需要保证IV每次是随机的)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　如果加密的数据块超过 1 block则不要选择ECB模式&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="http://gingjan.com/categories/%E5%AE%89%E5%85%A8/"/>
    
      <category term="算法" scheme="http://gingjan.com/categories/%E5%AE%89%E5%85%A8/%E7%AE%97%E6%B3%95/"/>
    
      <category term="加密算法" scheme="http://gingjan.com/categories/%E5%AE%89%E5%85%A8/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://gingjan.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="安全" scheme="http://gingjan.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Composer常用命令</title>
    <link href="http://gingjan.com/2018/08/09/composer-command/"/>
    <id>http://gingjan.com/2018/08/09/composer-command/</id>
    <published>2018-08-09T09:18:33.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文讲解并且亲测了常用的Composer命令<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>composer required</td>
<td></td>
<td>“xxx/xxx:v0.0.1”</td>
<td>更新包，自动判断包存不存在，不存在就安装，存在就更新</td>
</tr>
<tr>
<td>composer dump-autoload</td>
<td></td>
<td></td>
<td>不更新依赖,只更新autoload文件</td>
</tr>
<tr>
<td>composer install</td>
<td></td>
<td></td>
<td>根据composer.lock 更新/安装依赖</td>
</tr>
<tr>
<td>composer update</td>
<td></td>
<td></td>
<td>根据composer.json 更新/安装依赖 并更新composer.lock文件</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      本文持续更新中…
    
    </summary>
    
      <category term="依赖管理" scheme="http://gingjan.com/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
      <category term="PHP" scheme="http://gingjan.com/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/PHP/"/>
    
    
      <category term="Composer" scheme="http://gingjan.com/tags/Composer/"/>
    
      <category term="依赖管理" scheme="http://gingjan.com/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>如何在mac上解压分离的压缩文件</title>
    <link href="http://gingjan.com/2017/02/12/how-to-unzip-a-split-archive-on-mac-osx/"/>
    <id>http://gingjan.com/2017/02/12/how-to-unzip-a-split-archive-on-mac-osx/</id>
    <published>2017-02-12T14:04:40.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本篇文章向各位展示如何解压分离的压缩文件<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<p><The rest of contents | 余下全文><br>首先，目前据我所知，有两种不同类型的分离压缩文件</p>
<h3 id="一、xxx-zip-001、xxx-zip-002、xxx-zip003类型"><a href="#一、xxx-zip-001、xxx-zip-002、xxx-zip003类型" class="headerlink" title="一、xxx.zip.001、xxx.zip.002、xxx.zip003类型"></a>一、xxx.zip.001、xxx.zip.002、xxx.zip003类型</h3><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>在终端中输入：</p>
<p><code>for i in</code>seq  1 5<code>; do cat xxx.zip.00$i &gt;&gt; single.zip; done</code> #实则为一个循环语句</p>
<p><code>unzip single.zip</code></p>
<p>解压成功。</p>
<p>其实上面那句循环相当于：</p>
<p><code>cat xxx.zip.001 &gt; single.zip</code> #把数据重定向到single.zip</p>
<p><code>cat xxx.zip.002 &gt;&gt; single.zip</code> #把数据以追加方式重定向到single.zip</p>
<p><code>cat xxx.zip.003 &gt;&gt; single.zip</code></p>
<p><code>cat xxx.zip.004 &gt;&gt; single.zip</code></p>
<p><code>cat xxx.zip.005 &gt;&gt; single.zip</code></p>
<p>或者可以：<code>cat xxx.zip.00* &gt;&gt; already_exist_single.zip</code></p>
<h3 id="二、xxx-z01、xxx-z02、xxx-z03、xxx-zip类型"><a href="#二、xxx-z01、xxx-z02、xxx-z03、xxx-zip类型" class="headerlink" title="二、xxx.z01、xxx.z02、xxx.z03、xxx.zip类型"></a>二、xxx.z01、xxx.z02、xxx.z03、xxx.zip类型</h3><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>zip -s 0 xxx.zip —out unsplit.zip</code> #把分开的文件合并成一个文件</p>
<p><code>-s</code> 代表把压缩的文件分为几部分压缩，<code>0</code> 代表不分割，具体数字如 <code>100m</code> 则代表分为每份大小100m。</p>
<p>以上，如有错误，请指正，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本篇文章向各位展示如何解压分离的压缩文件&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mac" scheme="http://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mac/"/>
    
    
      <category term="Mac" scheme="http://gingjan.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Linux-让耗时任务在后台运行</title>
    <link href="http://gingjan.com/2016/09/01/Linux-run-in-background/"/>
    <id>http://gingjan.com/2016/09/01/Linux-run-in-background/</id>
    <published>2016-09-01T04:10:41.000Z</published>
    <updated>2020-05-05T05:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 让终端的任务/耗时任务在后台运行 </strong>：我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>


<p>涉及命令<br><code>ps -ef</code> 查看进程<br><code>pstree</code> 查看进程树<br><code>jobs</code> 查看当前终端的任务列表<br><code>commands &amp;</code>，命令后加<code>&amp;</code>代表将该命令放置后台运行<br><code>nohup commands &amp;</code><br><code>setsid commands</code><br><code>(commands &amp;)</code> 效果同上面setsid<br><code>ctrl+z</code> (暂停/挂起当前 作业，在使用编辑器时特别有用，退出编辑器时，保存了光标所在的当前位置，下次进入编辑器时不用再次寻找上次光标所处位置)<br><code>bg %work_num如bg %1</code>（把作业从挂起转为继续运行）<br><code>disown -h %1work_num</code>使某个作业忽略HUP信号<br><code>disown -ah</code> 所有作业忽略HUP信号<br><code>disown -rh</code> 使正在运行的作业忽略HUP信号<br><code>screen -dmS session_name</code> 建立一个断开模式的会话<br><code>screen -list</code> 列出所有会话<br><code>screen -r session_name</code> 重新连接指定会话</p>
<p>我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？</p>
<h2 id="一、逐个添加"><a href="#一、逐个添加" class="headerlink" title="一、逐个添加"></a>一、逐个添加</h2><p>1.通过忽略hangup信号（此信号在终端关闭或者网络断开时就会发出），该种方式可通过jobs命令来查看作业列表<br><code>nohup ping www.google.com &amp;</code><br>查看进程<br><code>ps -ef | grep www.google.com</code></p>
<p>2.通过把任务移为其他进程（非终端进程）的子进程来运行，这样就不会受到终端的HUP信号影响了，该种方式通过jobs命令是无法查看作业列表<br><code>setsid ping www.google.com</code></p>
<p>3.把任务放置到子shell(subshell)下运行，这样就不会受到终端的HUP信号影响了，该种方式通过jobs命令是无法查看作业列表，因为任务已经不属于该终端的作业了<br><code>(ping www.google.com &amp;)</code></p>
<hr>
<h2 id="二、补救"><a href="#二、补救" class="headerlink" title="二、补救"></a>二、补救</h2><p>如果我们执行了一个耗时任务，想在该耗时任务运行期间让它到后台运行，这时添加nohup或setsid已经迟了，怎么做？</p>
<h3 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h3><p><code>disown -h %1</code></p>
<hr>
<h2 id="三、一步完成"><a href="#三、一步完成" class="headerlink" title="三、一步完成"></a>三、一步完成</h2><p>当有很多耗时任务，而我们又不想一个一个去加nohup ,setsid时，怎么办？</p>
<h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p><code>screen -dmS session_name</code></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/">参考：https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 让终端的任务/耗时任务在后台运行 &lt;/strong&gt;：我们在终端中打开耗时任务时，无法进行其他操作或者当网络端口时，任务未执行完毕就终止了。有什么办法令任务在后台运行呢？&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
      <category term="常用命令" scheme="http://gingjan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="http://gingjan.com/tags/Linux/"/>
    
      <category term="命令" scheme="http://gingjan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>查看一次SQL的执行时间与相关参数</title>
    <link href="http://gingjan.com/2016/07/03/mysql-sql-execution-check-out/"/>
    <id>http://gingjan.com/2016/07/03/mysql-sql-execution-check-out/</id>
    <published>2016-07-03T09:02:47.000Z</published>
    <updated>2020-05-05T05:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> mysql之sql执行过程窥探 </strong>：本文讲解如何窥探sql执行过程的相关参数<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>1.首先查看当前session（会话）的profiling是否打开<br><code>select @@profiling</code><br><img src="/img/mysql-sql-execution-check-out/mysql1.png" alt="profiling=0，未打开"><br>若为0，则未打开，</p>
<p>2.打开profiling<br><code>set profiling=1</code><br><img src="/img/mysql-sql-execution-check-out/mysql2.png" alt="set profiling=1，开启profiling"></p>
<p>3.执行一些sql<br><img src="/img/mysql-sql-execution-check-out/mysql3.png" alt="执行sql"></p>
<p>4.查看所有已执行的sql的profile<br><code>show profiles</code><br><img src="/img/mysql-sql-execution-check-out/mysql4.png" alt="profiles"></p>
<p>5.看看刚才某条sql执行的具体时间拆分，2是个某次查询的id<br><code>show profile for query id</code><br><img src="/img/mysql-sql-execution-check-out/mysql5.png" alt="profile for query 2"></p>
<p>6.看看刚才某条sql执行的具体时间拆分，并加上相应的cpu信息 (cpu也可以换成all，以查看更多系统指标)<br><code>show profile cpu for query id</code><br><img src="/img/mysql-sql-execution-check-out/mysql6.png" alt="profile cpu for query 2"></p>
<p>整理自：<a href="http://itindex.net/detail/51526-mysql-sql-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4">http://itindex.net/detail/51526-mysql-sql-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; mysql之sql执行过程窥探 &lt;/strong&gt;：本文讲解如何窥探sql执行过程的相关参数&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="http://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
    
      <category term="MySQL" scheme="http://gingjan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/MySQL/"/>
    
    
      <category term="性能优化" scheme="http://gingjan.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="SQL" scheme="http://gingjan.com/tags/SQL/"/>
    
      <category term="数据库" scheme="http://gingjan.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://gingjan.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>REST API 响应状态码</title>
    <link href="http://gingjan.com/2016/06/21/rest-status-code-setting/"/>
    <id>http://gingjan.com/2016/06/21/rest-status-code-setting/</id>
    <published>2016-06-21T11:18:08.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文简单介绍了设计REST API时，返回的响应应该设置什么样的状态码<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>在涉及REST风格的API时，使用适当和Http响应状态码是很重要的，这样可以提高API消费者（客户端）对API响应信息的理解</p>
<h3 id="状态码分为5大类"><a href="#状态码分为5大类" class="headerlink" title="状态码分为5大类"></a>状态码分为5大类</h3><ul>
<li>1xx：临时响应</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：请求错误</li>
<li>5xx：服务器错误</li>
</ul>
<h3 id="每类的详细"><a href="#每类的详细" class="headerlink" title="每类的详细"></a>每类的详细</h3><table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">HTTP方法</th>
<th style="text-align:center">响应体内容</th>
<th style="text-align:center">含义</th>
<th>Status text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1xx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">2xx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center">GET,PUT</td>
<td style="text-align:center">资源</td>
<td style="text-align:center">操作成功</td>
<td>OK</td>
</tr>
<tr>
<td style="text-align:center">201</td>
<td style="text-align:center">POST</td>
<td style="text-align:center">资源,元数据</td>
<td style="text-align:center">资源创建成功</td>
<td>Created </td>
</tr>
<tr>
<td style="text-align:center">202</td>
<td style="text-align:center">POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">请求已被接受</td>
<td>Accepted</td>
</tr>
<tr>
<td style="text-align:center">204</td>
<td style="text-align:center">DELETE,PUT,PATCH</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">操作已经执行成功，但是响应体没有数据返回。多用于多次修改同一个资源时填写表单的情况下</td>
<td>No Content</td>
</tr>
<tr>
<td style="text-align:center">205</td>
<td style="text-align:center">POST</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">操作已经执行成功，但是响应体没有数据返回。多用于创建资源时填写表单的情况下。请看下面解释与204的区别</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">3xx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">301</td>
<td style="text-align:center">GET</td>
<td style="text-align:center">uri链接</td>
<td style="text-align:center">资源已被移除（永久重定向）</td>
<td>Moved permamently</td>
</tr>
<tr>
<td style="text-align:center">302</td>
<td style="text-align:center">GET</td>
<td style="text-align:center">uri链接</td>
<td style="text-align:center">重定向（临时重定向），http/1.0 的产物</td>
<td>Found</td>
</tr>
<tr>
<td style="text-align:center">303</td>
<td style="text-align:center">GET</td>
<td style="text-align:center">uri链接</td>
<td style="text-align:center">重定向（临时重定向），同302，http/1.1的产物，浏览器会根据返回的uri，自动请求该uri</td>
<td>See Other</td>
</tr>
<tr>
<td style="text-align:center">304</td>
<td style="text-align:center">GET</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">资源没有被修改，使用时header必须带上If-Modified_Since或者If-None-Match</td>
<td>Not Modified</td>
</tr>
<tr>
<td style="text-align:center">307</td>
<td style="text-align:center">GET</td>
<td style="text-align:center">uri链接</td>
<td style="text-align:center">重定向（临时重定向），同302，http/1.1的产物，浏览器会根据返回的uri，自动请求该uri</td>
<td>Temporary Redirect</td>
</tr>
<tr>
<td style="text-align:center">4xx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">参数列表错误(缺少，格式不匹配)</td>
</tr>
<tr>
<td style="text-align:center">401</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">未授权</td>
</tr>
<tr>
<td style="text-align:center">403</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">访问受限，授权过期</td>
</tr>
<tr>
<td style="text-align:center">404</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">资源，服务未找到</td>
</tr>
<tr>
<td style="text-align:center">405</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">不允许的http方法</td>
</tr>
<tr>
<td style="text-align:center">409</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">资源冲突，或者资源被锁定</td>
</tr>
<tr>
<td style="text-align:center">415</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">不支持的数据(媒体)类型</td>
</tr>
<tr>
<td style="text-align:center">429</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">请求过多被限制</td>
</tr>
<tr>
<td style="text-align:center">5xx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">500</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">服务器内部错误/应用系统内部错误</td>
</tr>
<tr>
<td style="text-align:center">501</td>
<td style="text-align:center">GET,POST,PUT,DELETE,PATCH</td>
<td style="text-align:center">错误提示(消息)</td>
<td style="text-align:center">接口未实现</td>
</tr>
</tbody>
</table>
<blockquote>
<p>附加说明：N/A 代表不适用</p>
</blockquote>
<hr>
<h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul>
<li>简单说明</li>
<li>访问地址</li>
<li>请求方式</li>
<li>返回结果</li>
<li>返回结果的字段说明</li>
<li>错误代码</li>
<li>更新记录</li>
</ul>
<hr>
<h2 id="状态码的详解"><a href="#状态码的详解" class="headerlink" title="状态码的详解"></a>状态码的详解</h2><h3 id="HTTP响应状态码主要分为这几种大类："><a href="#HTTP响应状态码主要分为这几种大类：" class="headerlink" title="HTTP响应状态码主要分为这几种大类："></a>HTTP响应状态码主要分为这几种大类：</h3><ul>
<li>1xx：临时响应</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：请求错误</li>
<li>5xx：服务器错误</li>
</ul>
<h3 id="204"><a href="#204" class="headerlink" title="204"></a>204</h3><p>请求执行成功，但是响应体没有数据返回，浏览器不用刷新页面也不用跳转页面，所以如果是表单页面，那么表单里填写的数据将不会被清除。另外一点，即使是<a>标签，如果a标签里的链接返回的是204，那么页面也是不会发生跳转。同时返回204也是代表客户端和服务器端的状态（指该资源状态）已经同步</p>
<h3 id="205-（204与205区别）"><a href="#205-（204与205区别）" class="headerlink" title="205 （204与205区别）"></a>205 （204与205区别）</h3><p>请求执行成功，但是响应体没有数据返回，浏览器清空表单数据，方便用户再次填写新数据。</p>
<h3 id="304（304与204区别）"><a href="#304（304与204区别）" class="headerlink" title="304（304与204区别）"></a>304（304与204区别）</h3><p>注意与204的区别，204情况下是返回空文档，并且该文档会替换上次缓存的文件，因此会有文档/文件没有加载的情况（如没有加载jQuery文件因此提示无$函数等）。而304是使用上次缓存</p>
<hr>
<h2 id="其他需要注意的地方"><a href="#其他需要注意的地方" class="headerlink" title="其他需要注意的地方"></a>其他需要注意的地方</h2><p>这里谈谈REST其他需要注意的地方，注意，以下内容不是标准。</p>
<h3 id="PUT与PATCH区别"><a href="#PUT与PATCH区别" class="headerlink" title="PUT与PATCH区别"></a>PUT与PATCH区别</h3><p>我们都知道，更新操作可以通过PUT与PATCH方式提交请求，但是问题来了，PUT和PATCH有什么区别呢？<br>PUT，正如其词，就是把一大堆数据PUT到服务端，使用PUT更新资源时，需要把资源的所有属性都要提交到服务端。<br>PATCH，补丁，碎片，可以知道，使用PATCH更新资源时，只需要把资源的部分属性/信息提交到服务端即可。</p>
<h3 id="关于URI设计"><a href="#关于URI设计" class="headerlink" title="关于URI设计"></a>关于URI设计</h3><ul>
<li>从属关系使用嵌套形式，即articles/1/comments，articles/1/comments/2</li>
<li>筛选使用查询键值对的形式，即?key=value，articles?title=first_api</li>
</ul>
<h2 id="关于各种框架对REST的支持与实现"><a href="#关于各种框架对REST的支持与实现" class="headerlink" title="关于各种框架对REST的支持与实现"></a>关于各种框架对REST的支持与实现</h2><p>本节内容打算放到另一篇文章讲<br>未完待续…</p>
<p><a href="http://www.cnblogs.com/cathsfz/archive/2012/06/19/2553431.html">整理自</a><br><a href="http://www.bkjia.com/headlines/491296.html">整理自</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">整理自</a><br><a href="http://www.cnblogs.com/cathsfz/archive/2012/06/19/2553431.html">整理自</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文简单介绍了设计REST API时，返回的响应应该设置什么样的状态码&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="代码之上" scheme="http://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="API接口设计" scheme="http://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="REST" scheme="http://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/REST/"/>
    
    
      <category term="REST" scheme="http://gingjan.com/tags/REST/"/>
    
      <category term="API接口" scheme="http://gingjan.com/tags/API%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Yii的redirect()方法无法终止执行代码</title>
    <link href="http://gingjan.com/2016/06/16/yii-redirect-cannot-stop-execution/"/>
    <id>http://gingjan.com/2016/06/16/yii-redirect-cannot-stop-execution/</id>
    <published>2016-06-16T02:55:54.000Z</published>
    <updated>2020-05-05T05:01:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 坑爹的redirect() </strong>：在controller里的redirect方法在跳转后，无法终止后续代码的执行。特别在init方法中更棘手。<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<h3 id="遇到的情况-问题"><a href="#遇到的情况-问题" class="headerlink" title="遇到的情况/问题"></a>遇到的情况/问题</h3><p>在写权限控制的时候，在BaseController里的init方法设置了权限检测，如果权限不足则跳转并且终止执行后续代码，可是问题来了，使用了redirect()方法后，确实是跳转了，但是后续操作依然可以执行，显然没有做到控制权限的效果。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>查看redirect源码后，发现redirect()方法只是做了一些头的设置和跳转，并不会终止后续代码的执行，通过在init方法里加<code>return</code> 、<code>return false</code>、 <code>return true</code>等方法后，依然无效。难道要用<code>header(&#39;Location: &#39; . $redirect_url);exit;</code>来解决问题？测试后，使用该方法确实可以解决问题，但是这样写会不会有点恶心啊，于是乎发现Yii有提供<code>Yii:$app-&gt;response-&gt;send();</code>和<code>Yii:$app-&gt;end();</code>可以做到同样效果，最后就在init里使用了<code>Yii::$app-&gt;end();</code>来解决了这个问题。</p>
<h3 id="再次遇到问题"><a href="#再次遇到问题" class="headerlink" title="再次遇到问题"></a>再次遇到问题</h3><p>经过检验，在普通的actionName()方法里，可以使用return 来终止后续代码的执行，但是在init里却不管用，什么情况？<strong>有待研究</strong>(因为init()只是执行了并没有return？)</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>在普通的actionName方法里，可以使用<code>return</code>、<code>Yii:$app-&gt;response-&gt;send();</code>、<code>Yii:$app-&gt;end();</code>来解决问题，建议使用<code>return</code>更简洁</li>
<li>在init方法里，只能使用<code>Yii:$app-&gt;response-&gt;send();</code>和<code>Yii:$app-&gt;end();</code>来解决问题了。</li>
</ul>
<p>如有什么错误，欢迎指定和讨论</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 坑爹的redirect() &lt;/strong&gt;：在controller里的redirect方法在跳转后，无法终止后续代码的执行。特别在init方法中更棘手。&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Yii" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Yii/"/>
    
    
      <category term="框架" scheme="http://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Yii" scheme="http://gingjan.com/tags/Yii/"/>
    
  </entry>
  
  <entry>
    <title>在Yii中如何处理级联删除</title>
    <link href="http://gingjan.com/2016/06/13/cascade-delete-in-yii/"/>
    <id>http://gingjan.com/2016/06/13/cascade-delete-in-yii/</id>
    <published>2016-06-13T03:39:41.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　Yii框架在代码层进行级联删除<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<p><The rest of contents | 余下全文><br>数据库表里使用了外键并且使用了Restrict模式，导致删除一张表的记录时，因为外键和其他表关联起来了，导致无法删除，需要把关联表的记录同时也删除了才可以操作目标表记录的删除操作。</p>
<p>第一步：重写beforeDelete()<br>在Model里，重写beforeDelete()，然后在该方法的最后一行<code>return parent::beforeDelete();</code>即可<br>当然与beforeDelete方法对应的afterDelete方法也能做其他事情。<br>充分发挥before和after的作用吧<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $id = <span class="keyword">$this</span>-&gt;id;;</span><br><span class="line">        A::deleteAll([<span class="string">'id'</span>=&gt;$id]);<span class="comment">//级联删除</span></span><br><span class="line">        B::deleteAll([<span class="string">'id'</span>=&gt;$id]);</span><br><span class="line">        C::deleteAll([<span class="string">'id'</span>=&gt;$id]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>::beforeDelete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Yii框架在代码层进行级联删除&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Yii" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Yii/"/>
    
    
      <category term="框架" scheme="http://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Yii" scheme="http://gingjan.com/tags/Yii/"/>
    
  </entry>
  
  <entry>
    <title>访问修饰符的意义</title>
    <link href="http://gingjan.com/2016/06/06/accessing-control-and-locator-qualifer-purpose/"/>
    <id>http://gingjan.com/2016/06/06/accessing-control-and-locator-qualifer-purpose/</id>
    <published>2016-06-06T14:45:07.000Z</published>
    <updated>2020-05-05T05:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 访问修饰符和访问控制的意义 </strong>：本文主要讲解为何有些成员变量需要设置成私有的，为什么不能直接设置成public直接在外部访问，以及PHP魔术方法<strong>get()和</strong>set()的使用<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>先上一段代码好说明问题<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_salary;<span class="comment">//私用属性命名加_</span></span><br><span class="line">    <span class="comment">//setter and getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;<span class="comment">//如果只有get，那么说明该 属性/成员变量 只是可读，不可写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSalary</span><span class="params">($salary)</span> </span>&#123;<span class="comment">//如果只有set，说明该 属性/成员变量 只是可写，不可读</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_salary = $salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如上，我们觉得好像private改成public也没什么大问题，但是如果有这样一个场景，调用代码中，多处调用了User的salary属性，有写的也有读的，但是有一天，你不想让调用者修改salary了（禁用写），那怎么办？要怎么保证调用者的代码中没有直接修改salary的代码？如果提供了setter，那么只要把setter删掉，一旦调用代码中有没清理干净的对salary进行写入/修改 的代码，那么就会抛出异常。而使用public $salary这种方式的话，改成private后，虽然是可以禁止写了但是连读取也被禁止了。</li>
<li>对写入数据的操作/过滤，使用setter和getter，可以统一对写入/读取 进行操作或者过滤，比如要去掉写入数据中的空格，如果使用public，那么要在每个调用处写上trim()，但是我们无法保证每处都写上trim了。如果用setter，那么我们可以在setter中写一次trim即可，而且也保证对每次写入都会进行过滤，不会有遗漏。</li>
</ul>
<blockquote>
<p>注意:由于 <strong>get() 和 </strong>set() 是在遍历所有成员变量，找不到匹配的成员变量时才被调用。因此，其效率是低于直接访问成员变量的形式。在一些表示数据结构、数据集合等简单情况下，且不需读写控制等， 可以考虑使用成员变量作为属性直接访问，这样可以提高一点效率。<br>另外一个提高效率的技巧就是：使用 $k1 = $obj-&gt;getK1() 来代替 $k1 = $obj-&gt;K1 ， 用 $obj-&gt;setK1($value) 来代替 $obj-&gt;K1 = $value 。 这在功能上是完全一样的效果，但是避免了使用 <strong>get() 和 </strong>set() ，相当于绕过了遍历的过程。</p>
</blockquote>
<p>这里还要区分，在类里成员变量和属性的区别。成员变量和属性的区别与联系在于：</p>
<ul>
<li>成员变量是一个“内”概念，反映的是就类的结构构成而言的该你那。属性是一个“外”概念，反映的是类的功能逻辑意义而言的概念。</li>
<li>成员变量没有读写权限控制，而属性可以指定为只读或只写，或可读可写。</li>
<li>成员变量不对读出作任何后处理，不对写入作任何预处理，而属性则可以。</li>
<li>public成员变量可以视为一个可读可写、没有任何预处理或后处理的属性。 而private成员变量由于外部不可见，与属性“外”的特性不相符，所以不能视为属性。</li>
<li>虽然大多数情况下，属性会由某个或某些成员变量来表示，但属性与成员变量没有必然的对应关系， 比如与非门的 output 属性，就没有一个所谓的 $output 成员变量与之对应。</li>
</ul>
<p>为了更形象，我们看个例子<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAndGate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_k1;</span><br><span class="line">    <span class="keyword">private</span> $_k2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setK1</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$_k1 = $value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setK2</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$_k2 = $value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getOutput</span><span class="params">()</span> </span>&#123;<span class="comment">//与非门有两个输入，当两个输入都为真时，与非门的输出为假，否则，输出为真。</span></span><br><span class="line">        <span class="keyword">if</span> ( !<span class="keyword">$this</span>-&gt;_k1 || !<span class="keyword">$this</span>-&gt;_k2 ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;_k1 &amp;&amp; <span class="keyword">$this</span>-&gt;_k2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，与非门类有两个成员变量， <code>$_k1</code> 和 <code>$_k2</code> 。<strong>但是有3个属性</strong>，表示2个输入的 <code>key1</code> 和 <code>key2</code> ，以及表示输出的 <code>output</code>。<br>由于我们知道，属性一般是通过<code>$obj-&gt;property</code>方式来访问的，但是这里根本没有<code>output</code>这个成员变量呀？那还怎么访问呢？<br>没错，这时候就要靠我们的<code>魔术方法__get()</code>来配合<code>getter</code>了，上<code>__get()</code>的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    $getter = <span class="string">'get'</span> . $name;<span class="comment">//如此，当调用$obj-&gt;output属性时，就会去调用getOutput()，以达到具有output属性的效果</span></span><br><span class="line">    <span class="keyword">if</span> (method_exists(<span class="keyword">$this</span>, $getter)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$getter();</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (method_exists(<span class="keyword">$this</span>, <span class="string">'set'</span>.$name)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'只存在setter，也即该属性为只写'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'无'</span> , $name , <span class="string">'属性'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欢迎转载但请附上链接，谢谢。</p>
<p><a href="http://www.digpage.com/property.html">参考：http://www.digpage.com/property.html</a></p>
<p>如有什么错误，欢迎提出、讨论，大家共同进步 ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 访问修饰符和访问控制的意义 &lt;/strong&gt;：本文主要讲解为何有些成员变量需要设置成私有的，为什么不能直接设置成public直接在外部访问，以及PHP魔术方法&lt;strong&gt;get()和&lt;/strong&gt;set()的使用&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="代码之上" scheme="http://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/"/>
    
      <category term="OOP" scheme="http://gingjan.com/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A/OOP/"/>
    
    
      <category term="OOP" scheme="http://gingjan.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Yii框架的服务定位器</title>
    <link href="http://gingjan.com/2016/06/02/yii-service-locator/"/>
    <id>http://gingjan.com/2016/06/02/yii-service-locator/</id>
    <published>2016-06-02T12:02:51.000Z</published>
    <updated>2020-05-05T05:02:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> Yii——组件注册 </strong>：Yii的组件相当于Laravel的服务，同样需要注册到一个IOC容器中，以便在应用其他地方使用这些组件/服务<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>这相当与在laravel中，使用$app应用的register或者singleton方法注册服务，而在Yii中则称为服务定位器Service Locator。</p>
<h2 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h2><p>在Yii中，要注册组件(laravel中称之为服务)可以使用如下方式：</p>
<h3 id="方法一：set方法"><a href="#方法一：set方法" class="headerlink" title="方法一：set方法"></a>方法一：set方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">yii</span>\<span class="title">di</span>\<span class="title">ServiceLocator</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">yii</span>\<span class="title">caching</span>\<span class="title">FileCache</span>;</span><br><span class="line">$locator = <span class="keyword">new</span> ServiceLocator;</span><br><span class="line">$locator-&gt;set(<span class="string">'cache'</span>, <span class="string">'yii\caching\ApcCache'</span>);<span class="comment">//使用类名直接创建</span></span><br><span class="line">$locator-&gt;set(<span class="string">'db'</span>, [<span class="comment">//通过配置数组来注册</span></span><br><span class="line"><span class="string">'class'</span> =&gt; <span class="string">'yii\db\Connection'</span>,</span><br><span class="line"><span class="string">'dsn'</span> =&gt; <span class="string">'mysql:host=localhost;dbname=demo'</span>,</span><br><span class="line"><span class="string">'username'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line"><span class="string">'password'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">]);</span><br><span class="line">$locator-&gt;set(<span class="string">'search'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="comment">//通过一个匿名函数返回实例来注册</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> app\components\SolrService;</span><br><span class="line">&#125;);</span><br><span class="line">$locator-&gt;set(<span class="string">'pageCache'</span>, <span class="keyword">new</span> FileCache);<span class="comment">//直接使用new实例化来注册</span></span><br></pre></td></tr></table></figure>
<h3 id="方法二：在配置文件中配置"><a href="#方法二：在配置文件中配置" class="headerlink" title="方法二：在配置文件中配置"></a>方法二：在配置文件中配置</h3><p>返回配置数组的方式，即在应用的配置文件中配置components项<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'components'</span> =&gt; [</span><br><span class="line">        <span class="string">'db'</span> =&gt; [</span><br><span class="line">            <span class="string">'class'</span> =&gt; <span class="string">'yii\db\Connection'</span>,</span><br><span class="line">            <span class="string">'dsn'</span> =&gt; <span class="string">'mysql:host=localhost;dbname=demo'</span>,</span><br><span class="line">            <span class="string">'username'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line">            <span class="string">'password'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'cache'</span> =&gt; <span class="string">'yii\caching\ApcCache'</span>,</span><br><span class="line">        <span class="string">'search'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> app\components\SolrService;</span><br><span class="line">        &#125;，</span><br><span class="line">    ]，</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>请谨慎注册太多应用组件，应用组件就像全局变量，使用太多可能加大测试和维护的难度。 一般情况下可以在需要时再创建本地组件。</p>
</blockquote>
<hr>
<h2 id="使用-访问-组件"><a href="#使用-访问-组件" class="headerlink" title="使用/访问 组件"></a>使用/访问 组件</h2><p>通过访问上面注册时的名字/ID 来访问，两种方式，get(‘name/id’)和属性<br>$cache = $locator-&gt;get(‘cache’);<br>$cache = $locator-&gt;cache;//通过属性</p>
<hr>
<h2 id="检查是否注册某个组件"><a href="#检查是否注册某个组件" class="headerlink" title="检查是否注册某个组件"></a>检查是否注册某个组件</h2><p>$locator-&gt;has(‘name’);</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; Yii——组件注册 &lt;/strong&gt;：Yii的组件相当于Laravel的服务，同样需要注册到一个IOC容器中，以便在应用其他地方使用这些组件/服务&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PHP" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/"/>
    
      <category term="Yii" scheme="http://gingjan.com/categories/%E6%A1%86%E6%9E%B6/PHP/Yii/"/>
    
    
      <category term="框架" scheme="http://gingjan.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Yii" scheme="http://gingjan.com/tags/Yii/"/>
    
  </entry>
  
  <entry>
    <title>Javascript的单线程和异步之间的关系</title>
    <link href="http://gingjan.com/2016/06/01/js-async-single-thread-queue/"/>
    <id>http://gingjan.com/2016/06/01/js-async-single-thread-queue/</id>
    <published>2016-06-01T03:26:32.000Z</published>
    <updated>2020-05-05T05:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文介绍javascript的异步和单线程的关系，以及简单解释了单线程的js怎么异步处理。<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<p><The rest of contents | 余下全文></p>
<h2 id="异步计时函数setTimeout"><a href="#异步计时函数setTimeout" class="headerlink" title="异步计时函数setTimeout()"></a>异步计时函数setTimeout()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> begin = <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="comment">//代码开始</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    alert(<span class="string">'你好，这个程序已经运行了'</span> + (end - begin) + <span class="string">'毫秒'</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>);<span class="comment">//1秒后弹出对话框</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">new</span> <span class="built_in">Date</span>() - begin) &lt; <span class="number">6000</span>) &#123;&#125;<span class="comment">//循环代码持续3秒，3秒后，整个js调用栈的程序才执行完毕（在控制台中可以看到3秒后才出现一个响应undefined）</span></span><br></pre></td></tr></table></figure>
<p>上面的代码跟下面的对比一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> begin = <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="comment">//代码开始</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    alert(<span class="string">'你好，这个程序已经运行了'</span> + (end - begin) + <span class="string">'毫秒'</span>);</span><br><span class="line">&#125;,<span class="number">6000</span>);<span class="comment">//6秒后弹出对话框</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">new</span> <span class="built_in">Date</span>() - begin) &lt; <span class="number">3000</span>) &#123;&#125;<span class="comment">//循环代码持续3秒，3秒后，js调用栈执行完毕，控制台出现undefined，然后再过6-3=3秒后，出现弹框</span></span><br></pre></td></tr></table></figure><br>解析：<br>当js解析器解析到setTimeout时，就调用了浏览器的api——异步函数setTimeout，此时js继续往下解析执行，而浏览器就另有一个线程来处理异步函数setTimeout，也就是1秒后把回调函数放入js执行队列中。而此时，js调用栈中继续执行剩下的代码，直至完成了后面的循环后（调用栈中所有代码已经执行完毕）才解析队列中的回调函数来执行。</p>
<hr>
<h2 id="异步IO函数"><a href="#异步IO函数" class="headerlink" title="异步IO函数"></a>异步IO函数</h2><p>这里我们介绍下ajax，为了方便起见，直接使用jquery来说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('http://blog.zjien.com', function(resData)&#123;</span><br><span class="line">alert(resData);</span><br><span class="line">&#125; );</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><br>js在解析并执行到$.get()时，发起http请求，我看打开F12可以看到请求是处于Pending状态，通过WireShark或Fiddler2可以查看到HTTP请求状态，可知请求是成功发送并且有响应，但是因为下面的while是死循环，因此$.get()里的回调函数一直在队列中排队，得不到js的解析和执行，呈现出假死的状态。<br>换一种形式来展示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('http://blog.zjien.com',function(resData)&#123;</span><br><span class="line">alert(resData);</span><br><span class="line">&#125;);</span><br><span class="line">alert(<span class="string">'go on?'</span>);</span><br></pre></td></tr></table></figure><br>js解析并执行到go on时，浏览器弹出窗口，暂时不要关闭窗口，通过F12可以看到，请求是Pending状态，但通过Wireshark等工具看到请求是完成并得到响应的，只是因为go on阻塞/阻止了时间循环，导致$.get的回调无法执行，只有按下确定关闭了go on框，回调才得以执行。这是在chrome的情况如此。<br>在Firefox下却不会出现此情况，go on并不能阻止事件循环，所以上面两个代码段的ajax（$.get）的回调都可以执行，于是界面出现3个alert弹框。</p>
<blockquote>
<p>注意，每个窗口有一个js线程(单线程)，若一个窗口中有多个tag，那么这多个tag都是用同一个js线程。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文介绍javascript的异步和单线程的关系，以及简单解释了单线程的js怎么异步处理。&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"/>
    
      <category term="基础" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/Javascript/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="js" scheme="http://gingjan.com/tags/js/"/>
    
      <category term="异步" scheme="http://gingjan.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="线程" scheme="http://gingjan.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="队列" scheme="http://gingjan.com/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="Javascript" scheme="http://gingjan.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>超时调用和循环调用</title>
    <link href="http://gingjan.com/2016/05/25/settimeout-and-setintervel/"/>
    <id>http://gingjan.com/2016/05/25/settimeout-and-setintervel/</id>
    <published>2016-05-25T15:36:28.000Z</published>
    <updated>2020-05-05T04:59:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> setTimeout和setInterval </strong>：本文介绍这两个浏览器提供的api及其底层的原理<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<h3 id="超时调用就是setTimeout-function-delay"><a href="#超时调用就是setTimeout-function-delay" class="headerlink" title="超时调用就是setTimeout(function(){}, delay);"></a>超时调用就是setTimeout(function(){}, delay);</h3><p>第一参数：要执行的回调函数<br>第二参数：延迟多少毫秒，表示在指定时间之后添加回调函数到执行队列中，如果指定时间之后队列中没有其他要执行的代码，那么被添加的代码（即回调函数）会被立即执行。如果队列中有其他代码，那么回调函数会在队列里的代码执行完毕之后才执行。</p>
<p>可以使用<code>clearTimeout()；</code>来清楚 未执行 的任务<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="number">1000</span>);</span><br><span class="line">clearTimeout(a);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="循环调用就是setInterval"><a href="#循环调用就是setInterval" class="headerlink" title="循环调用就是setInterval();"></a>循环调用就是setInterval();</h3><p>第一参数：要执行的回调函数<br>第二参数：延迟多少毫秒，表示定期添加回调函数到执行队列中，如果指定时间之后队列中没有其他要执行的代码，那么被添加的代码（即回调函数）会被立即执行。如果队列中有其他代码，那么回调函数会在队列里的代码执行完毕之后才执行。注意，这个函数会定期不停的添加回调函数到执行队列的。</p>
<p>清除同上，使用<code>clearInterval(a);</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="number">1000</span>);</span><br><span class="line">clearInterval(a);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>以上两个函数都不一定会严格按照指定的时间间隔执行，这主要看执行队列中是否还有其他待执行的代码（也因为JS是单线程的）</p>
<p>注意,setTimeout和setInterval都是浏览器的api（由浏览器提供的内置函数），是一种异步函数。上面所说的队列是准确来说是指 异步任务队列 ，而js在执行着的代码是处于js调用栈里的代码<br><img src="/img/js-called-stack1.png" alt="js调用栈和异步队列1"><br><img src="/img/js-called-stack2.png" alt="js调用栈和异步队列2"></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; setTimeout和setInterval &lt;/strong&gt;：本文介绍这两个浏览器提供的api及其底层的原理&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"/>
    
      <category term="基础" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/Javascript/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="异步" scheme="http://gingjan.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Javascript" scheme="http://gingjan.com/tags/Javascript/"/>
    
      <category term="回调" scheme="http://gingjan.com/tags/%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="http://gingjan.com/2016/05/24/git-command/"/>
    <id>http://gingjan.com/2016/05/24/git-command/</id>
    <published>2016-05-24T09:08:33.000Z</published>
    <updated>2020-05-05T05:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文讲解并且亲测了常用的Git命令<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>git init</td>
<td></td>
<td></td>
<td>初始化/新建 当前目录为本地git仓库</td>
</tr>
<tr>
<td>git add</td>
<td>-A或-add</td>
<td></td>
<td>添加当前目录下所有未被tracking以及被修改的文件到index中</td>
</tr>
<tr>
<td>git add</td>
<td></td>
<td>file</td>
<td>添加 file文件/指定文件 到index中</td>
</tr>
<tr>
<td>git add</td>
<td></td>
<td>.</td>
<td>递归添加当前目录下的所有文件(包含目录)到index中</td>
</tr>
<tr>
<td>git rm</td>
<td>–cached</td>
<td>file</td>
<td>只删除index中指定的文件，而处于工作目录（也即文件目录）中的文件不会受到影响（不会被删除）</td>
</tr>
<tr>
<td>git rm</td>
<td>-f或–force</td>
<td>file</td>
<td>同时删除index和工作目录中指定的文件</td>
</tr>
<tr>
<td>git rm</td>
<td>-r</td>
<td>*</td>
<td>删除index暂存区里的全部文件 </td>
</tr>
<tr>
<td>git status</td>
<td></td>
<td></td>
<td>查看整个项目已经初始化的目录下所有文件的状态(处于 .gitignore 文件里的文件会被)</td>
</tr>
<tr>
<td>git status</td>
<td></td>
<td>.</td>
<td>查看当前目录下所有文件和目录的状态(非递归,也即当前目录内的子目录内的文件无法查看)</td>
</tr>
<tr>
<td>git commit</td>
<td>-m</td>
<td>‘message’</td>
<td>提交当前index中的文件到仓库repo中，并且附上提交说明/信息</td>
</tr>
<tr>
<td>git commit</td>
<td>-am</td>
<td>‘message’</td>
<td>git add 和 git commit 的组合</td>
</tr>
<tr>
<td>git commit</td>
<td>–amend -m</td>
<td>‘this is amend command’</td>
<td>当index没有新文件/修改的文件的前提下，该参数可以用来修改上一次commit的说明。当index中有新的文件或者修改的文件，该参数就会把这次index里的文件追加到上一次的commit中，而不会产生一次新的commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td></td>
<td>显示所有的commit记录</td>
</tr>
<tr>
<td>git log</td>
<td>-1</td>
<td></td>
<td>显示1行日志 -n为n行</td>
</tr>
<tr>
<td>git log</td>
<td>–stat</td>
<td></td>
<td>显示每个文件的变动信息</td>
</tr>
<tr>
<td>git log</td>
<td>-p -m</td>
<td></td>
<td></td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>v1.0</td>
<td>显示v1.0的日志</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1 ^branch-2</td>
<td>查看 branch-1 有，而 branch-2 中没有的 commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-2 ^branch-1</td>
<td>同理 查看 branch-2 有，而 branch-1 中没有的 commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1..branch-2</td>
<td>查看 branch-2 中比 branch-1 中多提交了哪些commit，注意，列出来的是两个点后边（此处即branch-2）比前边（此处即branch-1）多提交的内容。</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-2..branch-1</td>
<td>同理 查看 branch-1 中比 branch-2 中多提交了哪些commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1…branch-2</td>
<td>不知道谁提交的多谁提交的少，单纯想知道有什么不一样，注意三个点</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>–left-right branch-1…branch-2</td>
<td>在上述情况下，再显示出每个提交是在哪个分支上，注意 commit 后面的箭头，根据我们在 –left-right branch-1…branch-2 的顺序，左箭头 &lt; 表示是 branch-1 的，右箭头 &gt; 表示是 branch-2的。</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>fjf01</td>
<td>显示某个commit的详细内容</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>HEAD</td>
<td>显示HEAD指向的commit的提交日志</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>HEAD^</td>
<td>显示HEAD的父(上一个版本)的commit的提交日志</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>HEAD^^</td>
<td>显示HEAD的上两个版本的commit的提交日志</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>HEAD^5</td>
<td>显示HEAD的上5个版本的commit的提交日志</td>
</tr>
<tr>
<td>git show</td>
<td></td>
<td>v1.0</td>
<td>显示v1.0标签的版本信息</td>
</tr>
<tr>
<td>git tag</td>
<td></td>
<td></td>
<td>显示已存在的tag</td>
</tr>
<tr>
<td>git tag</td>
<td>-l</td>
<td></td>
<td>显示已存在的tag</td>
</tr>
<tr>
<td>git tag</td>
<td>-a v3.0 -m ‘new version’</td>
<td></td>
<td>给当前HEAD指向的commit打上标签(tag)，每次打tag都需要加上说明-m</td>
</tr>
<tr>
<td>git tag</td>
<td>-a v3.1 eci3t8 -m ‘new version’</td>
<td></td>
<td>给以前的某个历史提交打上标签(tag)，并附加上说明-m</td>
</tr>
<tr>
<td>git push</td>
<td>–tags</td>
<td></td>
<td>把本地全部标签推送到远程仓库，不加–tags参数默认是不会把标签推送到远程的</td>
</tr>
<tr>
<td>git push</td>
<td>remote_host</td>
<td>v1.0.1</td>
<td>推送本地指定标签到远程</td>
</tr>
<tr>
<td>git push</td>
<td>remote_host –delete tag</td>
<td>v1.0.1</td>
<td>删除远程指定标签</td>
</tr>
<tr>
<td>git clone</td>
<td></td>
<td>xxx.git</td>
<td>克隆远程仓库到本地</td>
</tr>
<tr>
<td>git clone</td>
<td></td>
<td>xxx.git local_dir</td>
<td>克隆远程仓库到本地指定目录下</td>
</tr>
<tr>
<td>git clone</td>
<td>-b</td>
<td>new_branch_name <a href="https://xxxxx.git">https://xxxxx.git</a></td>
<td>clone时创建新的分支替代默认Origin HEAD（master）</td>
</tr>
</tbody>
</table>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>git config</td>
<td>–system</td>
<td>user.name “your name”</td>
<td>该系统下，所有用户使用的配置</td>
</tr>
<tr>
<td>git config</td>
<td>–global</td>
<td>user.name “your name”</td>
<td>该用户下的配置</td>
</tr>
<tr>
<td>git config</td>
<td>–local</td>
<td>user.name “your name”</td>
<td>该 项目project/仓库repository 下的配置</td>
</tr>
<tr>
<td>git config</td>
<td>–system</td>
<td>user.email myemail@gmail.com</td>
<td></td>
</tr>
<tr>
<td>git config</td>
<td>–global</td>
<td>user.email myemail@gmail.com</td>
<td></td>
</tr>
<tr>
<td>git config</td>
<td>–local</td>
<td>user.email myemail@gmail.com</td>
<td></td>
</tr>
<tr>
<td>git config</td>
<td>–list</td>
<td></td>
<td>查看配置，注意，所处的目录不同，显示的配置信息也不同哦</td>
</tr>
</tbody>
</table>
<h3 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h3><table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git checkout</td>
<td></td>
<td>dev</td>
<td>切换到dev分支上，也是把dev分支的代码检出到工作区（working tree）</td>
</tr>
<tr>
<td>git checkout</td>
<td></td>
<td>sha1-value</td>
<td>把指定历史版本的代码完整检出到工作区</td>
</tr>
<tr>
<td>git checkout</td>
<td></td>
<td>sha1-value /path/to/file</td>
<td>将指定文件的某个历史版本检出到工作区</td>
</tr>
<tr>
<td>git checkout</td>
<td></td>
<td>sha1-value:/path/to/file new-name</td>
<td>将指定文件的某个历史版本检出到工作区并且修改该文件名</td>
</tr>
<tr>
<td>git checkout</td>
<td>-t</td>
<td>origin/dev</td>
<td>创建本地dev分支(与远程对应分支同名)并换到该分支上，并且设置新分支dev的upstream信息</td>
</tr>
<tr>
<td>git checkout</td>
<td>-b</td>
<td>dev origin/dev</td>
<td>等同于上面命令。从当前分支创建并检出（切换到）新分支的命令。实际上是git checkout -b new-branch-name current-branch 的简写形式，即默认从当前HEAD分支创建新新分支</td>
</tr>
<tr>
<td>git checkout</td>
<td>-b</td>
<td>new-branch-name 172je2</td>
<td>从历史版本为 172je2 上创建新分支并且切换到该分之上</td>
</tr>
<tr>
<td>git checkout</td>
<td>–</td>
<td><file-name></td>
<td>取消对文件的修改,还原到最近的版本,废弃本地做的修改</td>
</tr>
<tr>
<td>git branch</td>
<td>new-branch-name</td>
<td>172je2</td>
<td>从历史版本为 172je2 上创建新分支，但不会切换到该分之上</td>
</tr>
<tr>
<td>git branch</td>
<td>-a</td>
<td></td>
<td>查看所有分支</td>
</tr>
<tr>
<td>git branch</td>
<td>-d</td>
<td>branch_name</td>
<td>删除branch_name分支</td>
</tr>
<tr>
<td>git merge</td>
<td></td>
<td>branch_name</td>
<td>把branch_name分支合并到本分支中（fast-forward模式）</td>
</tr>
<tr>
<td>git merge</td>
<td>–no-ff</td>
<td>branch_name</td>
<td>把branch_name分支合并到本分支中，非fast-forward模式，即会创建一个合并的提交</td>
</tr>
</tbody>
</table>
<h3 id="分支对比"><a href="#分支对比" class="headerlink" title="分支对比"></a>分支对比</h3><table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git diff branch1 branch2</td>
<td>–stat</td>
<td></td>
<td>显示出所有有差异的文件列表</td>
</tr>
<tr>
<td>git diff branch1 branch2</td>
<td></td>
<td>文件名(带路径)</td>
<td>显示指定文件的详细差异</td>
</tr>
<tr>
<td>git diff branch1 branch2</td>
<td></td>
<td></td>
<td>显示出所有有差异的文件的详细差异</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1 ^branch-2</td>
<td>查看 branch-1 有，而 branch-2 中没有的 commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-2 ^branch-1</td>
<td>同理 查看 branch-2 有，而 branch-1 中没有的 commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1..branch-2</td>
<td>查看 branch-2 中比 branch-1 中多提交了哪些commit，注意，列出来的是两个点后边（此处即branch-2）比前边（此处即branch-1）多提交的内容。</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-2..branch-1</td>
<td>同理 查看 branch-1 中比 branch-2 中多提交了哪些commit</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>branch-1…branch-2</td>
<td>不知道谁提交的多谁提交的少，单纯想知道有什么不一样，注意三个点</td>
</tr>
<tr>
<td>git log</td>
<td></td>
<td>–left-right branch-1…branch-2</td>
<td>在上述情况下，再显示出每个提交是在哪个分支上，注意 commit 后面的箭头，根据我们在 –left-right branch-1…branch-2 的顺序，左箭头 &lt; 表示是 branch-1 的，右箭头 &gt; 表示是 branch-2的。</td>
</tr>
</tbody>
</table>
<h3 id="修改commit"><a href="#修改commit" class="headerlink" title="修改commit"></a>修改commit</h3><table>
<thead>
<tr>
<th>Git命令</th>
<th>选项</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git rebase</td>
<td>-i</td>
<td>到哪个旧commit的hash值</td>
<td>注意，该commit是不会被合并的。接着进入交互模式，排第一行的是最旧的commit，除了这一个外，把每个commit前的pick改成squash，就相当于合并到第一行的commit上，接着修改commit信息。 </td>
</tr>
</tbody>
</table>
<h2 id="按功能排序"><a href="#按功能排序" class="headerlink" title="按功能排序"></a>按功能排序</h2><h3 id="取消修改-恢复版本"><a href="#取消修改-恢复版本" class="headerlink" title="取消修改,恢复版本"></a>取消修改,恢复版本</h3><p><strong>取消对文件的修改。还原到最近的版本，废弃本地做的修改。</strong><br><code>git checkout -- &lt;file&gt;</code></p>
<p><strong>取消已经暂存的文件。即，撤销先前”git add”的操作</strong><br><code>git reset HEAD &lt;file&gt;...</code></p>
<p><strong>修改最后一次提交。用于修改上一次的提交信息，或漏提交文件等情况。</strong><br><code>git commit --amend</code></p>
<p><strong>回退所有内容到上一个版本</strong><br><code>git reset HEAD^</code></p>
<p><strong>回退a.py这个文件的版本到上一个版本</strong><br><code>git reset HEAD^ a.py</code></p>
<p><strong>向前回退到第3个版本</strong><br><code>git reset –soft HEAD~3</code></p>
<p><strong>将本地的状态回退到和远程的一样</strong><br><code>git reset –hard origin/master</code></p>
<p><strong>回退到某个版本</strong><br><code>git reset 057d</code></p>
<p><strong>回退到上一次提交的状态，按照某一次的commit完全反向的进行一次commit.(代码回滚到上个版本，并提交git)</strong><br><code>git revert HEAD</code></p>
<p><strong>回滚单个文件</strong><br><code>git reset sha-1 path/to/file</code><br><code>git commit path/to/file -m &#39;message&#39;</code><br><code>git checkout path/to/file</code></p>
<blockquote>
<p>几点说明：</p>
<ul>
<li>一次commit是指当你输入git log是，看到的一串码，如commit e7d1b777de790970af704dbeac8c0ef3d21335b4，这算一次commit</li>
</ul>
</blockquote>
<p>[<a href="https://www.pureweber.com/article/git-pretty-output/">https://www.pureweber.com/article/git-pretty-output/</a>]</p>
]]></content>
    
    <summary type="html">
    
      本文持续更新中…
    
    </summary>
    
      <category term="CVS" scheme="http://gingjan.com/categories/CVS/"/>
    
      <category term="Git" scheme="http://gingjan.com/categories/CVS/Git/"/>
    
      <category term="Git命令" scheme="http://gingjan.com/categories/CVS/Git/Git%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Git" scheme="http://gingjan.com/tags/Git/"/>
    
      <category term="CVS" scheme="http://gingjan.com/tags/CVS/"/>
    
  </entry>
  
  <entry>
    <title>同步编程与异步编程的转换和对比</title>
    <link href="http://gingjan.com/2016/05/24/sync-vs-async-and-they-transfers/"/>
    <id>http://gingjan.com/2016/05/24/sync-vs-async-and-they-transfers/</id>
    <published>2016-05-23T18:38:42.000Z</published>
    <updated>2020-05-05T05:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 同步转换异步 </strong>： 本文介绍了nodejs下的同步模型转换成异步模型（异步代码的设计）<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<h2 id="开始转变思路"><a href="#开始转变思路" class="headerlink" title="开始转变思路"></a>开始转变思路</h2><p>这里转变思路是指由同步模型代码转换成异步模型代码<br>要使用Node.js，就有必要了解异步编程的工作原理。异步代码设计并非简单的设计，需要一番学习。本文在同步代码示例旁边给出了异步代码示例，表明如何更改同步代码，才能变成异步代码。这些示例都围绕Node.js的文件系统(fs)模块，因为它是唯一含有同步I/O操作及异步I/O操作的模块。有了这两种示例，你可以开始转变思路了。</p>
<hr>
<h2 id="相关代码和独立代码"><a href="#相关代码和独立代码" class="headerlink" title="相关代码和独立代码"></a>相关代码和独立代码</h2><p>回调函数(callback function)是Node.js中异步事件驱动型编程的基本构建模块。它们是作为变量，传递给异步I/O操作的函数。一旦操作完成，回调函数就被调用。回调函数是Node.js中实现事件的机制。<br>下面显示的示例表明了如何将同步I/O操作转换成异步I/O操作，并显示了回调函数的使用。示例使用异步fs.readdirSync()调用，读取当前目录的文件名称，然后把文件名称记录到控制台，最后读取当前进程的进程编号(process id)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*相关代码和独立代码*/</span></span><br><span class="line">    <span class="comment">//任务：读取当前目录下的所有文件名称。并获取当前进程的编号pid</span></span><br><span class="line">    <span class="comment">//对任务的分析：因为读取文件名称 和 获取当前进程pid 是两件无关联的独立事情，所以如果要在一份代码中完成这两任务，可以考虑对它们进行异步处理</span></span><br><span class="line"><span class="comment">//同步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),filenames,i,processId;</span><br><span class="line"><span class="comment">//1、读取当前目录下的文件名称</span></span><br><span class="line">filenames = fs.readdirSync(<span class="string">'.'</span>);<span class="comment">//处理器等待该处的IO操作，所以此处需要改成异步fs.readdir()</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; filenames.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(filenames[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到此，都是做了同一件事，就是读取文件名称并且显示在控制台上。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ready"</span>);</span><br><span class="line"><span class="comment">//2、获取当前进程的pid</span></span><br><span class="line">processId = process.getuid();<span class="comment">//因为是同步模式，所以要在上面readdirSync执行完后才会执行此行代码。</span></span><br><span class="line"><span class="comment">//异步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>), filenames, i, processId;</span><br><span class="line"><span class="comment">//1、读取当前目录下的文件名称</span></span><br><span class="line">fs.readdir(<span class="string">'.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, filenames</span>) </span>&#123;<span class="comment">//第二个参数为回调，因为这里是异步模式，而跟任务1有关的一系列操作都放到回调里面，因为当读取完成后，相关联的一系列操作将会被回调，执行。</span></span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;filenames.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(filenames[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ready'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//2、获取当前进程的pid</span></span><br><span class="line">processId = process.getuid();<span class="comment">//因为是异步模式，所以当上面readdir被调用后，不用等待它执行完毕，就马上执行此行代码。这就是异步模式</span></span><br></pre></td></tr></table></figure><br>在同步示例中，处理器等待fs.readdirSync() I/O操作，所以这是需要更改的操作。Node.js中该函数的异步版本是fs.readdir()。它与fs.readdirSync()一样，但是回调函数作为第二个参数。<br>使用回调函数模式的规则如下：把同步函数换成对应的异步函数，然后把原先在同步调用后执行的代码放在回调函数里面。回调函数中的代码与同步示例中的代码执行一模一样的操作。它把文件名称记录到控制台。它在异步I/O操作返回之后执行。<br>就像文件名称的记录依赖fs.readdirSync() I/O操作的结果，所列文件数量的记录也依赖其结果。进程编号的存储独立于I/O操作的结果。因而，必须把它们移到异步代码中的不同位置。<br>规则就是将相关代码移到回调函数中，而独立代码的位置不用管。一旦I/O操作完成，相关代码就被执行，而独立代码在I/O操作被调用之后立即执行。</p>
<hr>
<h2 id="对顺序要求严格的任务"><a href="#对顺序要求严格的任务" class="headerlink" title="对顺序要求严格的任务"></a>对顺序要求严格的任务</h2><p>同步代码中的标准模式是线性顺序：几行代码都必须下一行接上一行来执行，因为每一行代码依赖上一行代码的结果。在下面示例中，代码首先变更了文件的访问模式(比如Unix chmod命令)，对文件更名，然后检查更名后文件是不是符号链接。很显然，该代码无法乱序运行，不然文件在模式变更前就被更名了，或者符号链接检查在文件被更名前就执行了。这两种情况都会导致出错。因而，顺序必须予以保留。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序严格的任务*/</span></span><br><span class="line"><span class="comment">//任务：1、修改文件的访问权限。2、然后对文件改名。3、然后检查更名后的文件是不是符号链接(symlink也即Linux里的软连接)。</span></span><br><span class="line"><span class="comment">//对任务的分析：很显然，该任务无法乱序运行，不然文件在访问权限变更前就被改名了，或者对符号链接的检查在文件被更名前就执行了。这两种情况都会导致出错。因而，顺序完成这两任务是必须予以保留的。</span></span><br><span class="line"><span class="comment">//同步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>), oldFilename, newFilename, isSymLink;</span><br><span class="line">oldFilename = <span class="string">'./processId.txt'</span>;</span><br><span class="line">newFilename = <span class="string">'./processIdOld.txt'</span>;</span><br><span class="line">fs.chmodSync(oldFilename, <span class="number">777</span>);</span><br><span class="line">fs.renameSync(oldFilename, newFilename);</span><br><span class="line">isSymLink = fs.lstatSync(newFilename).isSymbolicLink();</span><br><span class="line"><span class="comment">//异步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>), oldFilename, newFilename, isSymLink;</span><br><span class="line">oldFilename = <span class="string">'./processId.txt'</span>;</span><br><span class="line">newFilename = <span class="string">'./processIdOld.txt'</span>;</span><br><span class="line">fs.chmod(oldFilename, <span class="number">777</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;<span class="comment">//虽然这里是采用了异步处理，但是因为这些任务都是需要顺序处理才不会出错，因为在回调里嵌套回调，这里才能保证异步模式下顺序处理这种顺序任务</span></span><br><span class="line">    fs.rename(oldFilename, newFilename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        fs.lstat(newFilename, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> isSymLink = stats.isSymbolicLink();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>在异步代码中，这些顺序变成了嵌套回调。该示例显示了fs.lstat()回调嵌套在fs.rename()回调里面，而fs.rename()回调嵌套在fs.chmod()回调里面。</p>
<hr>
<h2 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h2><p>异步代码特别适合操作I/O操作的并行处理：代码的执行并不因I/O调用的返回而受阻。多个I/O操作可以并行开始。在下面示例中，某个目录中所有文件的大小都在循环中累加，以获得那些文件占用的总字节数。使用异步代码，循环的每次迭代都必须等到获取单个文件大小的I/O调用返回为止。<br>异步代码允许快速连续地在循环中开始所有I/O调用，不用等结果返回。只要其中一个I/O操作完成，回调函数就被调用，而该文件的大小就可以添加到总字节数中。<br>唯一必不可少的有一个恰当的停止标准，它决定着我们完成处理后，就计算所有文件的总字节数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*并行处理*/</span></span><br><span class="line"><span class="comment">//任务：1、获取当前目录下所用文件的大小。2、然后统计所有文件的总大小</span></span><br><span class="line"><span class="comment">//分析：因为需要首先知道每个文件的大小，而对每个文件的大小的获取是独立的，因此可以使用异步模式来同时读取多个文件的大小，最后需要设置一个标志用以告诉所有文件(最后一个文件)的大小都已经获取到并且总大小已经统计完成了，可以输出到控制台。</span></span><br><span class="line"><span class="comment">//同步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateByteSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalBytes = <span class="number">0</span>, i, filenames, stats;</span><br><span class="line">    filenames = fs.readdirSync(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;filenames.length;i++) &#123;</span><br><span class="line">        stat = fs.statSync(<span class="string">'./'</span> + filenames[i]);<span class="comment">//同步，这样下一个文件大小的获取需要等到本轮读取该文件大小完成才能进行。</span></span><br><span class="line">        totalBytes += stats.size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(totalBytes);</span><br><span class="line">&#125;</span><br><span class="line">calculateByteSize();<span class="comment">//等到里面全部操作(都是同步操作)都执行完毕，函数才返回（结束）【同步】</span></span><br><span class="line"><span class="comment">//异步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">totalBytes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateByteSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readdir(<span class="string">'.'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, filenames</span>) </span>&#123;<span class="comment">//引申出的一个问题，在一个函数内调用一个异步操作，那么是异步操作全部完成后该函数才结束，还是函数先结束，但是异步操作依然还在运行？</span></span><br><span class="line">        <span class="keyword">var</span> i;</span><br><span class="line">        count = filenames.length;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;filenames.length;i++) &#123;</span><br><span class="line">            fs.stat(<span class="string">'./'</span>+filenames[i], <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;<span class="comment">//调用fs.stat()了就马上继续下一轮循环，不等待该轮执行完成。这样就可以多个文件同时进行大小的获取。</span></span><br><span class="line">                totalBytes += stats.size;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(totalBytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">calculateByteSize();<span class="comment">//就此例而言，该函数被调用后就马上结束了。而里面的操作(都是异步操作)还在运行中【异步】。至于为什么函数结束后，里面的变量还能用，这就涉及到了闭包的知识点了</span></span><br></pre></td></tr></table></figure><br>同步示例简单又直观。在异步版本中，第一个fs.readdir()被调用，以读取目录中的文件名称。在回调函数中，针对每个文件调用fs.stat()，返回该文件的统计信息。这部分不出所料。</p>
<p>值得关注的方面出现在计算总字节数的fs.stat()回调函数中。所用的停止标准是目录的文件数量。变量count以文件数量来初始化，倒计数回调函数执行的次数。一旦数量为0，所有I/O操作都被回调，所有文件的总字节数被计算出来。计算完毕后，字节数可以记录到控制台。</p>
<p>异步示例有另一个值得关注的特性：它使用闭包(closure)。闭包是函数里面的函数，内层函数访问外层函数中声明的变量，即便在外层函数已完成之后。fs.stat()回调函数是闭包，因为它早在fs.readdir()回调函数完成后，访问在该函数中声明的count和totalBytes这两个变量。闭包有关于它自己的上下文。在该上下文中，可以放置在函数中访问的变量。</p>
<p>要是没有闭包，count和totalBytes这两个变量都必须是全局变量。这是由于fs.stat()回调函数没有放置变量的任何上下文。calculateBiteSize()函数早已结束，只有全局上下文仍在那里。这时候闭包就能派得上用场。变量可以放在该上下文中，那样可以从函数里面访问它们。</p>
<hr>
<h2 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h2><p>代码片段可以在JavaScript中复用，只要把代码片段包在函数里面。然后，可以从程序中的不同位置调用这些函数。如果函数中使用了I/O操作，那么改成异步代码时，就需要某种重构。</p>
<p>下面的异步示例显示了返回某个目录中文件数量的函数countFiles()。countFiles()使用I/O操作fs.readdirSync() 来确定文件数量。span&gt;countFiles()本身被调用，使用两个不同的输入参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*代码复用*/</span></span><br><span class="line"><span class="comment">//任务：1、返回某个目录中文件数量</span></span><br><span class="line"><span class="comment">//同步版本</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path1 = <span class="string">'./'</span>, path2 = <span class="string">'.././'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countFiles</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> filenames = fs.readdirSync(path);<span class="comment">//同步方式获取目录下所有文件</span></span><br><span class="line">    <span class="keyword">return</span> filenames.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(countFiles(path1)+<span class="string">'files in '</span> + path1);</span><br><span class="line"><span class="built_in">console</span>.log(countFiles(path2)+<span class="string">'files in '</span> + path2);</span><br><span class="line"><span class="comment">//异步</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path1 = <span class="string">'./'</span>, path2 = <span class="string">'.././'</span>, logCount;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countFiles</span>(<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">    fs.readdir(path, <span class="function"><span class="keyword">function</span> (<span class="params">err, filenames</span>) </span>&#123;</span><br><span class="line">        callback(err, path, filenames.length);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">logCount = <span class="function"><span class="keyword">function</span>(<span class="params">err, path, count</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">'files in '</span>+ path);</span><br><span class="line">&#125;;</span><br><span class="line">countFiles(path1, logCount);<span class="comment">//若这里依然是使用console.log去调用countFiles，因为countFiles是异步的，等到countFiles处理完毕返回值的时候，console.log已经结束运行了(因为countFile是异步的，所以console.log调用了countFiles之后就马上结束而不等待countFiles返回结果了)。所以是由conutFiles去调用console.log。于是把log放进异步的回调函数里才可以</span></span><br><span class="line">countFiles(path2, logCount);</span><br></pre></td></tr></table></figure><br>把fs.readdirSync()换成异步fs.readdir()迫使闭包函数countFiles()也变成异步，因为调用countFiles()的代码依赖该函数的结果。毕竟，只有fs.readdir()返回后，结果才会出现。这导致了countFiles()重构，以便还能接受回调函数。整个控制流程突然倒过来了：不是console.log()调用countiles()，countFiles()再调用fs.readdirSync()，在异步示例中，而是countFiles()调用fs.readdir()，然后countFiles()再调用console.log()。</p>
<hr>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文着重介绍了异步编程的一些基本模式。将思路转变到异步编程绝非易事，需要一段时间来适应。虽然难度增加了，但是获得的回报是显著提高了并发性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 同步转换异步 &lt;/strong&gt;： 本文介绍了nodejs下的同步模型转换成异步模型（异步代码的设计）&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="NodeJS" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/NodeJS/"/>
    
      <category term="基础" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/NodeJS/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="NodeJS" scheme="http://gingjan.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>push.default的 matching和simple</title>
    <link href="http://gingjan.com/2016/05/22/git-push-default/"/>
    <id>http://gingjan.com/2016/05/22/git-push-default/</id>
    <published>2016-05-22T13:33:44.000Z</published>
    <updated>2020-05-05T05:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> push.default的设置 </strong>：本文介绍push.default的两种设置，因为有两种不同设置是因为Git版本升级，导致默认设置不一样。<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<The rest of contents | 余下全文>

<p>因为git的版本升级，导致了<code>push.default</code>的值改变了，因此会询问你，使用<code>matching</code>还是<code>simple</code>，下面讲讲这两者的区别</p>
<h3 id="Matching"><a href="#Matching" class="headerlink" title="Matching"></a>Matching</h3><p>该参数是 Git 1.*的默认值，意思是如果在执行git push时没有指定分支，那么它将把所有本地的分支push到远程仓库中对应的分支</p>
<h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>该参数是 Git 2.*的默认值，意思是如果在执行git push时没有指定分支，那么它只会把当前分支push到你用git pull时指定的那个分支。</p>
<h3 id="修改默认设置"><a href="#修改默认设置" class="headerlink" title="修改默认设置"></a>修改默认设置</h3><p>通过修改全局配置来隐藏git push时的提示，如果要设置matching模式则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global push.default matching</span><br></pre></td></tr></table></figure></p>
<p>设置simple模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; push.default的设置 &lt;/strong&gt;：本文介绍push.default的两种设置，因为有两种不同设置是因为Git版本升级，导致默认设置不一样。&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="CVS" scheme="http://gingjan.com/categories/CVS/"/>
    
      <category term="Git" scheme="http://gingjan.com/categories/CVS/Git/"/>
    
      <category term="基础" scheme="http://gingjan.com/categories/CVS/Git/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Git" scheme="http://gingjan.com/tags/Git/"/>
    
      <category term="CVS" scheme="http://gingjan.com/tags/CVS/"/>
    
  </entry>
  
  <entry>
    <title>标题和段落文字大小以及排版设计</title>
    <link href="http://gingjan.com/2016/05/20/title-paragraph-font-size/"/>
    <id>http://gingjan.com/2016/05/20/title-paragraph-font-size/</id>
    <published>2016-05-20T03:04:53.000Z</published>
    <updated>2020-05-05T05:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong> 标题和段落字体大小 </strong>：本文我们讨论使用em来设置标题和段落字体大小，并且相关排版的设计<br>    <Excerpt in index | 首页摘要> </p>
<a id="more"></a>
<p><The rest of contents | 余下全文><br>这一类的排版建议把标题设置为默认字体大小的1.125em，也即1.125倍，而正文字体为0.75em，line-height为相对正文字体大小的1.5em（注意不是相对默认字体16px设定，是相对正文字体大小设定），建议再设置标题块（如h1）和段落块（如p）的margin同为相对正文字体大小的1.5em。下面我们写出具体代码以及解释</p>
<p>假设默认字体大小为16px（事实也确实如此）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基本css样式设置*/</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span>;<span class="comment">/*为了兼容IE*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">46.25em</span>; <span class="comment">/*740px/16px=46.25em*/</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1.5em</span> auto</span><br><span class="line">    border : <span class="number">0.0625em</span> solid <span class="number">#ccc</span> <span class="comment">/*1px/16px=0.0625em*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>给标题设置样式：“18px”的字体，“18px”的行高以及margin值<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.125em</span> <span class="comment">/*先继承它的父元素的默认大小16px，然后换成：18px/16px=1.125em*/</span></span><br><span class="line">    <span class="comment">/*为了美观，建议加上行高和margin*/</span></span><br><span class="line">    line-height: <span class="number">1em</span>;<span class="comment">/*也是18px，但是它这里是相对于上面的font-size来说，因此是18px(line-height)÷18px(font-size)=1em*/</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span>; <span class="comment">/*18px(margin) ÷ 18px(font-size) = 1em */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>给标题设置样式：“12px”的字体，“18px”的行高以及margin值<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.75em</span> <span class="comment">/*先继承它的父元素的默认大小16px，然后换成：12px/16px=0.75em*/</span></span><br><span class="line">    <span class="comment">/*为了美观，建议加上行高和margin*/</span></span><br><span class="line">    line-height: <span class="number">1.5em</span>;<span class="comment">/*也是18px，但是它这里是相对于上面的font-size来说，因此是18px(line-height) ÷ 12(font-size) = 1.5em */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1.5em</span>;<span class="comment">/*18px(margin) ÷ 12(font-size) = 1.5em */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt; 标题和段落字体大小 &lt;/strong&gt;：本文我们讨论使用em来设置标题和段落字体大小，并且相关排版的设计&lt;br&gt;    &lt;Excerpt in index | 首页摘要&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
      <category term="基础" scheme="http://gingjan.com/categories/%E5%89%8D%E7%AB%AF/CSS/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="CSS" scheme="http://gingjan.com/tags/CSS/"/>
    
  </entry>
  
</feed>
